{"version":3,"sources":["../src/app/subscribe.ts","app/subscribe.js"],"names":["createSubscribe","async","executor","onNoObservers","proxy","ObserverProxy","subscribe","bind","_this","observers","unsubscribes","observerCount","task","resolve","finalized","then","catch","e","error","prototype","next","value","forEachObserver","observer","close","complete","nextOrObserver","undefined","Error","implementsAnyMethods","noop","unsub","unsubscribeOne","length","finalError","push","i","fn","sendOne","console","err","onError","args","_i","arguments","apply","obj","methods","methods_1","method"],"mappings":"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","file":"subscribe.js","sourcesContent":["/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\nexport type NextFn<T> = (value: T) => void;\nexport type ErrorFn = (error: Error) => void;\nexport type CompleteFn = () => void;\n\nexport interface Observer<T> {\n  // Called once for each value in a stream of values.\n  next: NextFn<T>;\n\n  // A stream terminates by a single call to EITHER error() or complete().\n  error: ErrorFn;\n\n  // No events will be sent to next() once complete() is called.\n  complete: CompleteFn;\n}\n\n// Allow for any of the Observer methods to be undefined.\nexport interface PartialObserver<T> {\n  next?: NextFn<T>;\n  error?: ErrorFn;\n  complete?: CompleteFn;\n}\n\n// TODO: Support also Unsubscribe.unsubscribe?\nexport type Unsubscribe = () => void;\n\n/**\n * The Subscribe interface has two forms - passing the inline function\n * callbacks, or a object interface with callback properties.\n */\nexport interface Subscribe<T> {\n  (next?: NextFn<T>, error?: ErrorFn, complete?: CompleteFn): Unsubscribe;\n  (observer: PartialObserver<T>): Unsubscribe;\n}\n\nexport interface Observable<T> {\n  // Subscribe method\n  subscribe: Subscribe<T>;\n}\n\nimport { PromiseImpl } from '../utils/promise';\n\nexport type Executor<T> = (observer: Observer<T>) => void;\n\n/**\n * Helper to make a Subscribe function (just like Promise helps make a\n * Thenable).\n *\n * @param executor Function which can make calls to a single Observer\n *     as a proxy.\n * @param onNoObservers Callback when count of Observers goes to zero.\n */\nexport function createSubscribe<T>(\n  executor: Executor<T>,\n  onNoObservers?: Executor<T>\n): Subscribe<T> {\n  let proxy = new ObserverProxy<T>(executor, onNoObservers);\n  return proxy.subscribe.bind(proxy);\n}\n\n/**\n * Implement fan-out for any number of Observers attached via a subscribe\n * function.\n */\nclass ObserverProxy<T> implements Observer<T> {\n  private observers: Array<Observer<T>> | undefined = [];\n  private unsubscribes: Unsubscribe[] = [];\n  private onNoObservers: Executor<T> | undefined;\n  private observerCount = 0;\n  // Micro-task scheduling by calling task.then().\n  private task = PromiseImpl.resolve();\n  private finalized = false;\n  private finalError: Error;\n\n  /**\n   * @param executor Function which can make calls to a single Observer\n   *     as a proxy.\n   * @param onNoObservers Callback when count of Observers goes to zero.\n   */\n  constructor(executor: Executor<T>, onNoObservers?: Executor<T>) {\n    this.onNoObservers = onNoObservers;\n    // Call the executor asynchronously so subscribers that are called\n    // synchronously after the creation of the subscribe function\n    // can still receive the very first value generated in the executor.\n    this.task\n      .then(() => {\n        executor(this);\n      })\n      .catch(e => {\n        this.error(e);\n      });\n  }\n\n  next(value: T) {\n    this.forEachObserver((observer: Observer<T>) => {\n      observer.next(value);\n    });\n  }\n\n  error(error: Error) {\n    this.forEachObserver((observer: Observer<T>) => {\n      observer.error(error);\n    });\n    this.close(error);\n  }\n\n  complete() {\n    this.forEachObserver((observer: Observer<T>) => {\n      observer.complete();\n    });\n    this.close();\n  }\n\n  /**\n   * Subscribe function that can be used to add an Observer to the fan-out list.\n   *\n   * - We require that no event is sent to a subscriber sychronously to their\n   *   call to subscribe().\n   */\n  subscribe(\n    nextOrObserver: PartialObserver<T> | Function,\n    error?: ErrorFn,\n    complete?: CompleteFn\n  ): Unsubscribe {\n    let observer: Observer<T>;\n\n    if (\n      nextOrObserver === undefined &&\n      error === undefined &&\n      complete === undefined\n    ) {\n      throw new Error('Missing Observer.');\n    }\n\n    // Assemble an Observer object when passed as callback functions.\n    if (implementsAnyMethods(nextOrObserver, ['next', 'error', 'complete'])) {\n      observer = nextOrObserver as Observer<T>;\n    } else {\n      observer = {\n        next: (nextOrObserver as any) as NextFn<T>,\n        error: error,\n        complete: complete\n      } as Observer<T>;\n    }\n\n    if (observer.next === undefined) {\n      observer.next = noop as NextFn<T>;\n    }\n    if (observer.error === undefined) {\n      observer.error = noop as ErrorFn;\n    }\n    if (observer.complete === undefined) {\n      observer.complete = noop as CompleteFn;\n    }\n\n    let unsub = this.unsubscribeOne.bind(this, this.observers!.length);\n\n    // Attempt to subscribe to a terminated Observable - we\n    // just respond to the Observer with the final error or complete\n    // event.\n    if (this.finalized) {\n      this.task.then(() => {\n        try {\n          if (this.finalError) {\n            observer.error(this.finalError);\n          } else {\n            observer.complete();\n          }\n        } catch (e) {\n          // nothing\n        }\n        return;\n      });\n    }\n\n    this.observers!.push(observer as Observer<T>);\n\n    return unsub;\n  }\n\n  // Unsubscribe is synchronous - we guarantee that no events are sent to\n  // any unsubscribed Observer.\n  private unsubscribeOne(i: number) {\n    if (this.observers === undefined || this.observers[i] === undefined) {\n      return;\n    }\n\n    delete this.observers[i];\n\n    this.observerCount -= 1;\n    if (this.observerCount === 0 && this.onNoObservers !== undefined) {\n      this.onNoObservers(this);\n    }\n  }\n\n  private forEachObserver(fn: (observer: Observer<T>) => void): void {\n    if (this.finalized) {\n      // Already closed by previous event....just eat the additional values.\n      return;\n    }\n\n    // Since sendOne calls asynchronously - there is no chance that\n    // this.observers will become undefined.\n    for (let i = 0; i < this.observers!.length; i++) {\n      this.sendOne(i, fn);\n    }\n  }\n\n  // Call the Observer via one of it's callback function. We are careful to\n  // confirm that the observe has not been unsubscribed since this asynchronous\n  // function had been queued.\n  private sendOne(i: number, fn: (observer: Observer<T>) => void): void {\n    // Execute the callback asynchronously\n    this.task.then(() => {\n      if (this.observers !== undefined && this.observers[i] !== undefined) {\n        try {\n          fn(this.observers[i]);\n        } catch (e) {\n          // Ignore exceptions raised in Observers or missing methods of an\n          // Observer.\n          // Log error to console. b/31404806\n          if (typeof console !== 'undefined' && console.error) {\n            console.error(e);\n          }\n        }\n      }\n    });\n  }\n\n  private close(err?: Error): void {\n    if (this.finalized) {\n      return;\n    }\n    this.finalized = true;\n    if (err !== undefined) {\n      this.finalError = err;\n    }\n    // Proxy is no longer needed - garbage collect references\n    this.task.then(() => {\n      this.observers = undefined;\n      this.onNoObservers = undefined;\n    });\n  }\n}\n\n/** Turn synchronous function into one called asynchronously. */\nexport function async(fn: Function, onError?: ErrorFn): Function {\n  return (...args: any[]) => {\n    PromiseImpl.resolve(true)\n      .then(() => {\n        fn(...args);\n      })\n      .catch((error: Error) => {\n        if (onError) {\n          onError(error);\n        }\n      });\n  };\n}\n\n/**\n * Return true if the object passed in implements any of the named methods.\n */\nfunction implementsAnyMethods(obj: any, methods: string[]): boolean {\n  if (typeof obj !== 'object' || obj === null) {\n    return false;\n  }\n\n  for (let method of methods) {\n    if (method in obj && typeof obj[method] === 'function') {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction noop(): void {\n  // do nothing\n}\n","import { PromiseImpl } from '../utils/promise';\n/**\n * Helper to make a Subscribe function (just like Promise helps make a\n * Thenable).\n *\n * @param executor Function which can make calls to a single Observer\n *     as a proxy.\n * @param onNoObservers Callback when count of Observers goes to zero.\n */\nexport function createSubscribe(executor, onNoObservers) {\n    var proxy = new ObserverProxy(executor, onNoObservers);\n    return proxy.subscribe.bind(proxy);\n}\n/**\n * Implement fan-out for any number of Observers attached via a subscribe\n * function.\n */\nvar ObserverProxy = (function () {\n    /**\n     * @param executor Function which can make calls to a single Observer\n     *     as a proxy.\n     * @param onNoObservers Callback when count of Observers goes to zero.\n     */\n    function ObserverProxy(executor, onNoObservers) {\n        var _this = this;\n        this.observers = [];\n        this.unsubscribes = [];\n        this.observerCount = 0;\n        // Micro-task scheduling by calling task.then().\n        this.task = PromiseImpl.resolve();\n        this.finalized = false;\n        this.onNoObservers = onNoObservers;\n        // Call the executor asynchronously so subscribers that are called\n        // synchronously after the creation of the subscribe function\n        // can still receive the very first value generated in the executor.\n        this.task\n            .then(function () {\n            executor(_this);\n        })\n            .catch(function (e) {\n            _this.error(e);\n        });\n    }\n    ObserverProxy.prototype.next = function (value) {\n        this.forEachObserver(function (observer) {\n            observer.next(value);\n        });\n    };\n    ObserverProxy.prototype.error = function (error) {\n        this.forEachObserver(function (observer) {\n            observer.error(error);\n        });\n        this.close(error);\n    };\n    ObserverProxy.prototype.complete = function () {\n        this.forEachObserver(function (observer) {\n            observer.complete();\n        });\n        this.close();\n    };\n    /**\n     * Subscribe function that can be used to add an Observer to the fan-out list.\n     *\n     * - We require that no event is sent to a subscriber sychronously to their\n     *   call to subscribe().\n     */\n    ObserverProxy.prototype.subscribe = function (nextOrObserver, error, complete) {\n        var _this = this;\n        var observer;\n        if (nextOrObserver === undefined &&\n            error === undefined &&\n            complete === undefined) {\n            throw new Error('Missing Observer.');\n        }\n        // Assemble an Observer object when passed as callback functions.\n        if (implementsAnyMethods(nextOrObserver, ['next', 'error', 'complete'])) {\n            observer = nextOrObserver;\n        }\n        else {\n            observer = {\n                next: nextOrObserver,\n                error: error,\n                complete: complete\n            };\n        }\n        if (observer.next === undefined) {\n            observer.next = noop;\n        }\n        if (observer.error === undefined) {\n            observer.error = noop;\n        }\n        if (observer.complete === undefined) {\n            observer.complete = noop;\n        }\n        var unsub = this.unsubscribeOne.bind(this, this.observers.length);\n        // Attempt to subscribe to a terminated Observable - we\n        // just respond to the Observer with the final error or complete\n        // event.\n        if (this.finalized) {\n            this.task.then(function () {\n                try {\n                    if (_this.finalError) {\n                        observer.error(_this.finalError);\n                    }\n                    else {\n                        observer.complete();\n                    }\n                }\n                catch (e) {\n                    // nothing\n                }\n                return;\n            });\n        }\n        this.observers.push(observer);\n        return unsub;\n    };\n    // Unsubscribe is synchronous - we guarantee that no events are sent to\n    // any unsubscribed Observer.\n    ObserverProxy.prototype.unsubscribeOne = function (i) {\n        if (this.observers === undefined || this.observers[i] === undefined) {\n            return;\n        }\n        delete this.observers[i];\n        this.observerCount -= 1;\n        if (this.observerCount === 0 && this.onNoObservers !== undefined) {\n            this.onNoObservers(this);\n        }\n    };\n    ObserverProxy.prototype.forEachObserver = function (fn) {\n        if (this.finalized) {\n            // Already closed by previous event....just eat the additional values.\n            return;\n        }\n        // Since sendOne calls asynchronously - there is no chance that\n        // this.observers will become undefined.\n        for (var i = 0; i < this.observers.length; i++) {\n            this.sendOne(i, fn);\n        }\n    };\n    // Call the Observer via one of it's callback function. We are careful to\n    // confirm that the observe has not been unsubscribed since this asynchronous\n    // function had been queued.\n    ObserverProxy.prototype.sendOne = function (i, fn) {\n        var _this = this;\n        // Execute the callback asynchronously\n        this.task.then(function () {\n            if (_this.observers !== undefined && _this.observers[i] !== undefined) {\n                try {\n                    fn(_this.observers[i]);\n                }\n                catch (e) {\n                    // Ignore exceptions raised in Observers or missing methods of an\n                    // Observer.\n                    // Log error to console. b/31404806\n                    if (typeof console !== 'undefined' && console.error) {\n                        console.error(e);\n                    }\n                }\n            }\n        });\n    };\n    ObserverProxy.prototype.close = function (err) {\n        var _this = this;\n        if (this.finalized) {\n            return;\n        }\n        this.finalized = true;\n        if (err !== undefined) {\n            this.finalError = err;\n        }\n        // Proxy is no longer needed - garbage collect references\n        this.task.then(function () {\n            _this.observers = undefined;\n            _this.onNoObservers = undefined;\n        });\n    };\n    return ObserverProxy;\n}());\n/** Turn synchronous function into one called asynchronously. */\nexport function async(fn, onError) {\n    return function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        PromiseImpl.resolve(true)\n            .then(function () {\n            fn.apply(void 0, args);\n        })\n            .catch(function (error) {\n            if (onError) {\n                onError(error);\n            }\n        });\n    };\n}\n/**\n * Return true if the object passed in implements any of the named methods.\n */\nfunction implementsAnyMethods(obj, methods) {\n    if (typeof obj !== 'object' || obj === null) {\n        return false;\n    }\n    for (var _i = 0, methods_1 = methods; _i < methods_1.length; _i++) {\n        var method = methods_1[_i];\n        if (method in obj && typeof obj[method] === 'function') {\n            return true;\n        }\n    }\n    return false;\n}\nfunction noop() {\n    // do nothing\n}\n\n\n"]}