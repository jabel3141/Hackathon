{"version":3,"sources":["../src/app/errors.ts","app/errors.js"],"names":["patchCapture","ERROR_NAME","captureStackTrace","Error","captureFake","result","FirebaseError","code","message","stack","ErrorFactory","prototype","create","err_1","apply","arguments","name","Object","defineProperty","get","constructor","service","serviceName","errors","pattern","data","undefined","template","fullCode","replace","match","key","value","toString","err","prop","hasOwnProperty","slice"],"mappings":";;;;;QAmEMA,Y,GAAAA,Y;AAVN,IAAMC,aAAa,eAAnB;AAMA,IAAIC,oBAA2DC,MAC5DD,iBADH;AAGA;AACM,SAAAF,YAAA,CAAuBI,WAAvB,EAAwC;AAC5C,QAAIC,SAAcH,iBAAlB;AACAA,wBAAoBE,WAApB;AACA,WAAOC,MAAP;AACD;AAgBD,IAAAC,gBAAA,YAAA;AAIE,aAAAA,aAAA,CAAmBC,IAAnB,EAAwCC,OAAxC,EAAuD;AAApC,aAAAD,IAAA,GAAAA,IAAA;AAAqB,aAAAC,OAAA,GAAAA,OAAA;AACtC,YAAIC,KAAJ;AACA;AACA,YAAIP,iBAAJ,EAAuB;AACrB;AACAA,8BAAkB,IAAlB,EAAwBQ,aAAaC,SAAb,CAAuBC,MAA/C;AACD,SAHD,MAGO;AACL,gBAAIC,QAAMV,MAAMW,KAAN,CAAY,IAAZ,EAAkBC,SAAlB,CAAV;AACA,iBAAKC,IAAL,GAAYf,UAAZ;AACA;AACAgB,mBAAOC,cAAP,CAAsB,IAAtB,EAA4B,OAA5B,EAAqC;AACnCC,qBAAK,eAAA;AACH,2BAAON,MAAIJ,KAAX;AACD;AAHkC,aAArC;AAKD;AACF;AACH,WAAAH,aAAA;AArBA,CAAA,EAAA;QCvDSA,a,GAAAA,a;AD8ET;;AACAA,cAAcK,SAAd,GAA0BM,OAAOL,MAAP,CAAcT,MAAMQ,SAApB,CAA1B;AACAL,cAAcK,SAAd,CAAwBS,WAAxB,GAAsCd,aAAtC;AACCA,cAAcK,SAAd,CAAgCK,IAAhC,GAAuCf,UAAvC;AAED,IAAAS,eAAA,YAAA;AAIE,aAAAA,YAAA,CACUW,OADV,EAEUC,WAFV,EAGUC,MAHV,EAG8B;AAFpB,aAAAF,OAAA,GAAAA,OAAA;AACA,aAAAC,WAAA,GAAAA,WAAA;AACA,aAAAC,MAAA,GAAAA,MAAA;AANV;AACO,aAAAC,OAAA,GAAU,eAAV;AAOL;AACD;AAEDd,iBAAAC,SAAA,CAAAC,MAAA,GAAA,UAAOL,IAAP,EAAgBkB,IAAhB,EAAqD;AACnD,YAAIA,SAASC,SAAb,EAAwB;AACtBD,mBAAO,EAAP;AACD;AAED,YAAIE,WAAW,KAAKJ,MAAL,CAAYhB,IAAZ,CAAf;AAEA,YAAIqB,WAAW,KAAKP,OAAL,GAAe,GAAf,GAAqBd,IAApC;AACA,YAAIC,OAAJ;AAEA,YAAImB,aAAaD,SAAjB,EAA4B;AAC1BlB,sBAAU,OAAV;AACD,SAFD,MAEO;AACLA,sBAAUmB,SAASE,OAAT,CAAiB,KAAKL,OAAtB,EAA+B,UAACM,KAAD,EAAQC,GAAR,EAAW;AAClD,oBAAIC,QAAQP,KAAMM,GAAN,CAAZ;AACA,uBAAOC,UAAUN,SAAV,GAAsBM,MAAMC,QAAN,EAAtB,GAAyC,MAAMF,GAAN,GAAY,IAA5D;AACD,aAHS,CAAV;AAID;AAED;AACAvB,kBAAU,KAAKc,WAAL,GAAmB,IAAnB,GAA0Bd,OAA1B,GAAoC,IAApC,GAA2CoB,QAA3C,GAAsD,IAAhE;AACA,YAAIM,MAAM,IAAI5B,aAAJ,CAAkBsB,QAAlB,EAA4BpB,OAA5B,CAAV;AAEA;AACA;AACA,aAAK,IAAI2B,IAAT,IAAiBV,IAAjB,EAAuB;AACrB,gBAAI,CAACA,KAAKW,cAAL,CAAoBD,IAApB,CAAD,IAA8BA,KAAKE,KAAL,CAAW,CAAC,CAAZ,MAAmB,GAArD,EAA0D;AACxD;AACD;AACAH,gBAAYC,IAAZ,IAAoBV,KAAKU,IAAL,CAApB;AACF;AAED,eAAOD,GAAP;AACD,KAjCD;AAkCF,WAAAxB,YAAA;AA9CA,CAAA,EAAA;QCtCSA,Y,GAAAA,Y","file":"errors.js","sourcesContent":["/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n/**\n * @fileoverview Standardized Firebase Error.\n *\n * Usage:\n *\n *   // Typescript string literals for type-safe codes\n *   type Err =\n *     'unknown' |\n *     'object-not-found'\n *     ;\n *\n *   // Closure enum for type-safe error codes\n *   // at-enum {string}\n *   var Err = {\n *     UNKNOWN: 'unknown',\n *     OBJECT_NOT_FOUND: 'object-not-found',\n *   }\n *\n *   let errors: Map<Err, string> = {\n *     'generic-error': \"Unknown error\",\n *     'file-not-found': \"Could not find file: {$file}\",\n *   };\n *\n *   // Type-safe function - must pass a valid error code as param.\n *   let error = new ErrorFactory<Err>('service', 'Service', errors);\n *\n *   ...\n *   throw error.create(Err.GENERIC);\n *   ...\n *   throw error.create(Err.FILE_NOT_FOUND, {'file': fileName});\n *   ...\n *   // Service: Could not file file: foo.txt (service/file-not-found).\n *\n *   catch (e) {\n *     assert(e.message === \"Could not find file: foo.txt.\");\n *     if (e.code === 'service/file-not-found') {\n *       console.log(\"Could not read file: \" + e['file']);\n *     }\n *   }\n */\nexport type ErrorList<T> = { [code: string]: string };\n\nconst ERROR_NAME = 'FirebaseError';\n\nexport interface StringLike {\n  toString: () => string;\n}\n\nlet captureStackTrace: (obj: Object, fn?: Function) => void = (Error as any)\n  .captureStackTrace;\n\n// Export for faking in tests\nexport function patchCapture(captureFake?: any): any {\n  let result: any = captureStackTrace;\n  captureStackTrace = captureFake;\n  return result;\n}\n\nexport interface FirebaseError {\n  // Unique code for error - format is service/error-code-string\n  code: string;\n\n  // Developer-friendly error message.\n  message: string;\n\n  // Always 'FirebaseError'\n  name: string;\n\n  // Where available - stack backtrace in a string\n  stack: string;\n}\n\nexport class FirebaseError implements FirebaseError {\n  public stack: string;\n  public name: string;\n\n  constructor(public code: string, public message: string) {\n    let stack: string;\n    // We want the stack value, if implemented by Error\n    if (captureStackTrace) {\n      // Patches this.stack, omitted calls above ErrorFactory#create\n      captureStackTrace(this, ErrorFactory.prototype.create);\n    } else {\n      let err = Error.apply(this, arguments);\n      this.name = ERROR_NAME;\n      // Make non-enumerable getter for the property.\n      Object.defineProperty(this, 'stack', {\n        get: function() {\n          return err.stack;\n        }\n      });\n    }\n  }\n}\n\n// Back-door inheritance\nFirebaseError.prototype = Object.create(Error.prototype) as FirebaseError;\nFirebaseError.prototype.constructor = FirebaseError;\n(FirebaseError.prototype as any).name = ERROR_NAME;\n\nexport class ErrorFactory<T extends string> {\n  // Matches {$name}, by default.\n  public pattern = /\\{\\$([^}]+)}/g;\n\n  constructor(\n    private service: string,\n    private serviceName: string,\n    private errors: ErrorList<T>\n  ) {\n    // empty\n  }\n\n  create(code: T, data?: { [prop: string]: StringLike }): FirebaseError {\n    if (data === undefined) {\n      data = {};\n    }\n\n    let template = this.errors[code as string];\n\n    let fullCode = this.service + '/' + code;\n    let message: string;\n\n    if (template === undefined) {\n      message = 'Error';\n    } else {\n      message = template.replace(this.pattern, (match, key) => {\n        let value = data![key];\n        return value !== undefined ? value.toString() : '<' + key + '?>';\n      });\n    }\n\n    // Service: Error message (service/code).\n    message = this.serviceName + ': ' + message + ' (' + fullCode + ').';\n    let err = new FirebaseError(fullCode, message);\n\n    // Populate the Error object with message parts for programmatic\n    // accesses (e.g., e.file).\n    for (let prop in data) {\n      if (!data.hasOwnProperty(prop) || prop.slice(-1) === '_') {\n        continue;\n      }\n      (err as any)[prop] = data[prop];\n    }\n\n    return err;\n  }\n}\n","var ERROR_NAME = 'FirebaseError';\nvar captureStackTrace = Error\n    .captureStackTrace;\n// Export for faking in tests\nexport function patchCapture(captureFake) {\n    var result = captureStackTrace;\n    captureStackTrace = captureFake;\n    return result;\n}\nvar FirebaseError = (function () {\n    function FirebaseError(code, message) {\n        this.code = code;\n        this.message = message;\n        var stack;\n        // We want the stack value, if implemented by Error\n        if (captureStackTrace) {\n            // Patches this.stack, omitted calls above ErrorFactory#create\n            captureStackTrace(this, ErrorFactory.prototype.create);\n        }\n        else {\n            var err_1 = Error.apply(this, arguments);\n            this.name = ERROR_NAME;\n            // Make non-enumerable getter for the property.\n            Object.defineProperty(this, 'stack', {\n                get: function () {\n                    return err_1.stack;\n                }\n            });\n        }\n    }\n    return FirebaseError;\n}());\nexport { FirebaseError };\n// Back-door inheritance\nFirebaseError.prototype = Object.create(Error.prototype);\nFirebaseError.prototype.constructor = FirebaseError;\nFirebaseError.prototype.name = ERROR_NAME;\nvar ErrorFactory = (function () {\n    function ErrorFactory(service, serviceName, errors) {\n        this.service = service;\n        this.serviceName = serviceName;\n        this.errors = errors;\n        // Matches {$name}, by default.\n        this.pattern = /\\{\\$([^}]+)}/g;\n        // empty\n    }\n    ErrorFactory.prototype.create = function (code, data) {\n        if (data === undefined) {\n            data = {};\n        }\n        var template = this.errors[code];\n        var fullCode = this.service + '/' + code;\n        var message;\n        if (template === undefined) {\n            message = 'Error';\n        }\n        else {\n            message = template.replace(this.pattern, function (match, key) {\n                var value = data[key];\n                return value !== undefined ? value.toString() : '<' + key + '?>';\n            });\n        }\n        // Service: Error message (service/code).\n        message = this.serviceName + ': ' + message + ' (' + fullCode + ').';\n        var err = new FirebaseError(fullCode, message);\n        // Populate the Error object with message parts for programmatic\n        // accesses (e.g., e.file).\n        for (var prop in data) {\n            if (!data.hasOwnProperty(prop) || prop.slice(-1) === '_') {\n                continue;\n            }\n            err[prop] = data[prop];\n        }\n        return err;\n    };\n    return ErrorFactory;\n}());\nexport { ErrorFactory };\n\n\n"]}