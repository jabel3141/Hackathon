{"version":3,"sources":["../src/app/firebase_app.ts","app/firebase_app.js"],"names":["createFirebaseNamespace","contains","obj","key","Object","prototype","hasOwnProperty","call","DEFAULT_ENTRY_NAME","tokenListeners","FirebaseAppImpl","options","name","firebase_","isDeleted_","services_","name_","options_","INTERNAL","getUid","getToken","resolve","addAuthTokenListener","callback","push","setTimeout","removeAuthTokenListener","filter","listener","defineProperty","get","checkDestroyed_","enumerable","configurable","delete","_this","then","removeApp","services","keys","forEach","serviceKey","instanceKey","all","map","service","_getService","instanceIdentifier","instanceSpecifier","undefined","factories","extendApp","bind","props","error","console","log","apps_","appHooks","namespace","__esModule","initializeApp","app","apps","Promise","SDK_VERSION","registerService","extendNamespace","createSubscribe","ErrorFactory","useAsService","deepExtend","getApps","callAppHooks","createService","serviceProperties","appHook","allowMultipleInstances","serviceNamespace","appArg","args","_i","arguments","length","serviceFxn","apply","eventName","serviceName","factoryName","useService","code","appErrors","create","errors"],"mappings":"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","file":"firebase_app.js","sourcesContent":["/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\nimport { createSubscribe, Observer, Subscribe } from './subscribe';\nimport { ErrorFactory, FirebaseError } from './errors';\nimport { PromiseImpl } from '../utils/promise';\nimport { patchProperty, deepCopy, deepExtend } from '../utils/deep_copy';\n\nexport interface FirebaseAuthTokenData {\n  accessToken: string;\n}\n\nexport interface FirebaseAppInternals {\n  getToken(refreshToken?: boolean): Promise<FirebaseAuthTokenData | null>;\n  getUid(): string | null;\n  addAuthTokenListener(fn: (token: string | null) => void): void;\n  removeAuthTokenListener(fn: (token: string | null) => void): void;\n}\n\nexport type FirebaseOptions = {\n  apiKey?: string;\n  authDomain?: string;\n  databaseURL?: string;\n  projectId?: string;\n  storageBucket?: string;\n  messagingSenderId?: string;\n  [name: string]: any;\n};\n\n// An instance of the firebase.App\nexport interface FirebaseApp {\n  /**\n   * The (read-only) name (identifier) for this App. '[DEFAULT]' is the default\n   * App.\n   */\n  name: string;\n\n  /**\n   * The (read-only) configuration options from the app initialization.\n   */\n  options: FirebaseOptions;\n\n  /**\n   * Make the given App unusable and free resources.\n   */\n  delete(): Promise<void>;\n\n  INTERNAL: FirebaseAppInternals;\n}\n\nexport interface FirebaseServiceInternals {\n  /**\n   * Delete the service and free it's resources - called from\n   * app.delete().\n   */\n  delete(): Promise<void>;\n}\n\n// Services are exposed through instances - each of which is associated with a\n// FirebaseApp.\nexport interface FirebaseService {\n  app: FirebaseApp;\n  INTERNAL?: FirebaseServiceInternals;\n}\n\nexport type AppHook = (event: string, app: FirebaseApp) => void;\n\n/**\n * Firebase Services create instances given a Firebase App instance and can\n * optionally add properties and methods to each FirebaseApp via the extendApp()\n * function.\n */\nexport interface FirebaseServiceFactory {\n  (\n    app: FirebaseApp,\n    extendApp?: (props: { [prop: string]: any }) => void,\n    instanceString?: string\n  ): FirebaseService;\n}\n\n/**\n * All ServiceNamespaces extend from FirebaseServiceNamespace\n */\nexport interface FirebaseServiceNamespace<T extends FirebaseService> {\n  (app?: FirebaseApp): T;\n}\n\nexport interface FirebaseErrorFactory<T> {\n  create(code: T, data?: { [prop: string]: any }): FirebaseError;\n}\n\nexport interface FirebaseErrorFactoryClass {\n  new (\n    service: string,\n    serviceName: string,\n    errors: { [code: string]: string }\n  ): FirebaseErrorFactory<any>;\n}\n\nexport interface FirebaseNamespace {\n  /**\n   * Create (and intialize) a FirebaseApp.\n   *\n   * @param options Options to configure the services use in the App.\n   * @param name The optional name of the app to initialize ('[DEFAULT]' if\n   *   none)\n   */\n  initializeApp(options: FirebaseOptions, name?: string): FirebaseApp;\n\n  app: {\n    /**\n     * Retrieve an instance of a FirebaseApp.\n     *\n     * Usage: firebase.app()\n     *\n     * @param name The optional name of the app to return ('[DEFAULT]' if none)\n     */\n    (name?: string): FirebaseApp;\n\n    /**\n     * For testing FirebaseApp instances:\n     *   app() instanceof firebase.app.App\n     * DO NOT call this constuctor directly (use firebase.app() instead).\n     */\n    App: Function;\n  };\n\n  /**\n   * A (read-only) array of all the initialized Apps.\n   */\n  apps: FirebaseApp[];\n\n  // Inherit the type information of our exported Promise implementation from\n  // es6-promises.\n  Promise: typeof Promise;\n\n  // The current SDK version ('4.3.1').\n  SDK_VERSION: string;\n\n  // TODO: Migrate to firebase-app-internal.d.ts\n  INTERNAL: {\n    /**\n     * Internal API to register a Firebase Service into the firebase namespace.\n     *\n     * Each service will create a child namespace (firease.name) which acts as\n     * both a namespace for service specific properties, and also as a service\n     * accessor function (firebase.name() or firebase.name(app)).\n     *\n     * @param name The Firebase Service being registered.\n     * @param createService Factory function to create a service instance.\n     * @param serviceProperties Properties to copy to the service's namespace.\n     * @param appHook All appHooks called before intializeApp returns to caller.\n     * @param allowMultipleInstances Whether the registered service supports\n     *   multiple instances per app. If not specified, the default is false.\n     */\n    registerService(\n      name: string,\n      createService: FirebaseServiceFactory,\n      serviceProperties?: { [prop: string]: any },\n      appHook?: AppHook,\n      allowMultipleInstances?: boolean\n    ): FirebaseServiceNamespace<FirebaseService>;\n\n    /**\n     * Just used for testing to start from a fresh namespace.\n     */\n    createFirebaseNamespace(): FirebaseNamespace;\n\n    /**\n     * Internal API to install properties on the top-level firebase namespace.\n     * @prop props The top level properties of this object are copied to the\n     *   namespace.\n     */\n    extendNamespace(props: { [prop: string]: any }): void;\n\n    /**\n     * Create a Subscribe function.  A proxy Observer is created so that\n     * events can be sent to single Observer to be fanned out automatically.\n     */\n    createSubscribe<T>(\n      executor: (observer: Observer<T>) => void,\n      onNoObservers?: (observer: Observer<T>) => void\n    ): Subscribe<T>;\n\n    /**\n     * Utility exposed for internal testing.\n     */\n    deepExtend(target: any, source: any): any;\n\n    /**\n     * Internal API to remove an app from the list of registered apps.\n     */\n    removeApp(name: string): void;\n\n    /**\n     * Service factories for each registered service.\n     */\n    factories: { [name: string]: FirebaseServiceFactory };\n\n    /*\n     * Convert service name to factory name to use.\n     */\n    useAsService(app: FirebaseApp, serviceName: string): string | null;\n\n    /**\n     * Use to construct all thrown FirebaseError's.\n     */\n    ErrorFactory: FirebaseErrorFactoryClass;\n  };\n}\n\nconst contains = function(obj, key) {\n  return Object.prototype.hasOwnProperty.call(obj, key);\n};\n\nconst DEFAULT_ENTRY_NAME = '[DEFAULT]';\n\n// An array to capture listeners before the true auth functions\n// exist\nlet tokenListeners = [];\n\n/**\n * Global context object for a collection of services using\n * a shared authentication state.\n */\nclass FirebaseAppImpl implements FirebaseApp {\n  private options_: FirebaseOptions;\n  private name_: string;\n  private isDeleted_ = false;\n  private services_: {\n    [name: string]: {\n      [serviceName: string]: FirebaseService;\n    };\n  } = {};\n\n  public INTERNAL;\n\n  constructor(\n    options: FirebaseOptions,\n    name: string,\n    private firebase_: FirebaseNamespace\n  ) {\n    this.name_ = name;\n    this.options_ = deepCopy<FirebaseOptions>(options);\n    this.INTERNAL = {\n      getUid: () => null,\n      getToken: () => PromiseImpl.resolve(null),\n      addAuthTokenListener: (callback: (token: string | null) => void) => {\n        tokenListeners.push(callback);\n        // Make sure callback is called, asynchronously, in the absence of the auth module\n        setTimeout(() => callback(null), 0);\n      },\n      removeAuthTokenListener: callback => {\n        tokenListeners = tokenListeners.filter(\n          listener => listener !== callback\n        );\n      }\n    };\n  }\n\n  get name(): string {\n    this.checkDestroyed_();\n    return this.name_;\n  }\n\n  get options(): FirebaseOptions {\n    this.checkDestroyed_();\n    return this.options_;\n  }\n\n  delete(): Promise<void> {\n    return new PromiseImpl(resolve => {\n      this.checkDestroyed_();\n      resolve();\n    })\n      .then(() => {\n        this.firebase_.INTERNAL.removeApp(this.name_);\n        let services: FirebaseService[] = [];\n        Object.keys(this.services_).forEach(serviceKey => {\n          Object.keys(this.services_[serviceKey]).forEach(instanceKey => {\n            services.push(this.services_[serviceKey][instanceKey]);\n          });\n        });\n        return PromiseImpl.all(\n          services.map(service => {\n            return service.INTERNAL!.delete();\n          })\n        );\n      })\n      .then((): void => {\n        this.isDeleted_ = true;\n        this.services_ = {};\n      });\n  }\n\n  /**\n   * Return a service instance associated with this app (creating it\n   * on demand), identified by the passed instanceIdentifier.\n   * \n   * NOTE: Currently storage is the only one that is leveraging this\n   * functionality. They invoke it by calling:\n   * \n   * ```javascript\n   * firebase.app().storage('STORAGE BUCKET ID')\n   * ```\n   * \n   * The service name is passed to this already\n   * @internal\n   */\n  _getService(\n    name: string,\n    instanceIdentifier: string = DEFAULT_ENTRY_NAME\n  ): FirebaseService {\n    this.checkDestroyed_();\n\n    if (!this.services_[name]) {\n      this.services_[name] = {};\n    }\n\n    if (!this.services_[name][instanceIdentifier]) {\n      /**\n       * If a custom instance has been defined (i.e. not '[DEFAULT]')\n       * then we will pass that instance on, otherwise we pass `null`\n       */\n      const instanceSpecifier =\n        instanceIdentifier !== DEFAULT_ENTRY_NAME\n          ? instanceIdentifier\n          : undefined;\n      const service = this.firebase_.INTERNAL.factories[name](\n        this,\n        this.extendApp.bind(this),\n        instanceSpecifier\n      );\n      this.services_[name][instanceIdentifier] = service;\n    }\n\n    return this.services_[name][instanceIdentifier];\n  }\n\n  /**\n   * Callback function used to extend an App instance at the time\n   * of service instance creation.\n   */\n  private extendApp(props: { [name: string]: any }): void {\n    // Copy the object onto the FirebaseAppImpl prototype\n    deepExtend(this, props);\n\n    /**\n     * If the app has overwritten the addAuthTokenListener stub, forward\n     * the active token listeners on to the true fxn.\n     * \n     * TODO: This function is required due to our current module\n     * structure. Once we are able to rely strictly upon a single module\n     * implementation, this code should be refactored and Auth should \n     * provide these stubs and the upgrade logic\n     */\n    if (props.INTERNAL && props.INTERNAL.addAuthTokenListener) {\n      tokenListeners.forEach(listener => {\n        this.INTERNAL.addAuthTokenListener(listener);\n      });\n      tokenListeners = [];\n    }\n  }\n\n  /**\n   * This function will throw an Error if the App has already been deleted -\n   * use before performing API actions on the App.\n   */\n  private checkDestroyed_(): void {\n    if (this.isDeleted_) {\n      error('app-deleted', { name: this.name_ });\n    }\n  }\n}\n\n// Prevent dead-code elimination of these methods w/o invalid property\n// copying.\n(FirebaseAppImpl.prototype.name && FirebaseAppImpl.prototype.options) ||\n  FirebaseAppImpl.prototype.delete ||\n  console.log('dc');\n\n/**\n * Return a firebase namespace object.\n *\n * In production, this will be called exactly once and the result\n * assigned to the 'firebase' global.  It may be called multiple times\n * in unit tests.\n */\nexport function createFirebaseNamespace(): FirebaseNamespace {\n  let apps_: { [name: string]: FirebaseApp } = {};\n  let factories: { [service: string]: FirebaseServiceFactory } = {};\n  let appHooks: { [service: string]: AppHook } = {};\n\n  // A namespace is a plain JavaScript Object.\n  let namespace = {\n    // Hack to prevent Babel from modifying the object returned\n    // as the firebase namespace.\n    __esModule: true,\n    initializeApp: initializeApp,\n    app: app as any,\n    apps: null as any,\n    Promise: PromiseImpl,\n    SDK_VERSION: '4.3.1',\n    INTERNAL: {\n      registerService: registerService,\n      createFirebaseNamespace: createFirebaseNamespace,\n      extendNamespace: extendNamespace,\n      createSubscribe: createSubscribe,\n      ErrorFactory: ErrorFactory,\n      removeApp: removeApp,\n      factories: factories,\n      useAsService: useAsService,\n      Promise: PromiseImpl,\n      deepExtend: deepExtend\n    }\n  };\n\n  // Inject a circular default export to allow Babel users who were previously\n  // using:\n  //\n  //   import firebase from 'firebase';\n  //   which becomes: var firebase = require('firebase').default;\n  //\n  // instead of\n  //\n  //   import * as firebase from 'firebase';\n  //   which becomes: var firebase = require('firebase');\n  patchProperty(namespace, 'default', namespace);\n\n  // firebase.apps is a read-only getter.\n  Object.defineProperty(namespace, 'apps', {\n    get: getApps\n  });\n\n  /**\n   * Called by App.delete() - but before any services associated with the App\n   * are deleted.\n   */\n  function removeApp(name: string): void {\n    let app = apps_[name];\n    callAppHooks(app, 'delete');\n    delete apps_[name];\n  }\n\n  /**\n   * Get the App object for a given name (or DEFAULT).\n   */\n  function app(name?: string): FirebaseApp {\n    name = name || DEFAULT_ENTRY_NAME;\n    if (!contains(apps_, name)) {\n      error('no-app', { name: name });\n    }\n    return apps_[name];\n  }\n\n  patchProperty(app, 'App', FirebaseAppImpl);\n\n  /**\n   * Create a new App instance (name must be unique).\n   */\n  function initializeApp(options: FirebaseOptions, name?: string): FirebaseApp {\n    if (name === undefined) {\n      name = DEFAULT_ENTRY_NAME;\n    } else {\n      if (typeof name !== 'string' || name === '') {\n        error('bad-app-name', { name: name + '' });\n      }\n    }\n    if (contains(apps_, name)) {\n      error('duplicate-app', { name: name });\n    }\n\n    let app = new FirebaseAppImpl(\n      options,\n      name!,\n      namespace as FirebaseNamespace\n    );\n\n    apps_[name!] = app;\n    callAppHooks(app, 'create');\n\n    return app;\n  }\n\n  /*\n   * Return an array of all the non-deleted FirebaseApps.\n   */\n  function getApps(): FirebaseApp[] {\n    // Make a copy so caller cannot mutate the apps list.\n    return Object.keys(apps_).map(name => apps_[name]);\n  }\n\n  /*\n   * Register a Firebase Service.\n   *\n   * firebase.INTERNAL.registerService()\n   *\n   * TODO: Implement serviceProperties.\n   */\n  function registerService(\n    name: string,\n    createService: FirebaseServiceFactory,\n    serviceProperties?: { [prop: string]: any },\n    appHook?: AppHook,\n    allowMultipleInstances?: boolean\n  ): FirebaseServiceNamespace<FirebaseService> {\n    // Cannot re-register a service that already exists\n    if (factories[name]) {\n      error('duplicate-service', { name: name });\n    }\n\n    // Capture the service factory for later service instantiation\n    factories[name] = createService;\n\n    // Capture the appHook, if passed\n    if (appHook) {\n      appHooks[name] = appHook;\n\n      // Run the **new** app hook on all existing apps\n      getApps().forEach(app => {\n        appHook('create', app);\n      });\n    }\n\n    // The Service namespace is an accessor function ...\n    const serviceNamespace = (appArg: FirebaseApp = app()) => {\n      if (typeof (appArg as any)[name] !== 'function') {\n        // Invalid argument.\n        // This happens in the following case: firebase.storage('gs:/')\n        error('invalid-app-argument', { name: name });\n      }\n\n      // Forward service instance lookup to the FirebaseApp.\n      return (appArg as any)[name]();\n    };\n\n    // ... and a container for service-level properties.\n    if (serviceProperties !== undefined) {\n      deepExtend(serviceNamespace, serviceProperties);\n    }\n\n    // Monkey-patch the serviceNamespace onto the firebase namespace\n    (namespace as any)[name] = serviceNamespace;\n\n    // Patch the FirebaseAppImpl prototype\n    FirebaseAppImpl.prototype[name] = function(...args) {\n      const serviceFxn = this._getService.bind(this, name);\n      return serviceFxn.apply(this, allowMultipleInstances ? args : []);\n    };\n\n    return serviceNamespace;\n  }\n\n  /**\n   * Patch the top-level firebase namespace with additional properties.\n   *\n   * firebase.INTERNAL.extendNamespace()\n   */\n  function extendNamespace(props: { [prop: string]: any }): void {\n    deepExtend(namespace, props);\n  }\n\n  function callAppHooks(app: FirebaseApp, eventName: string) {\n    Object.keys(factories).forEach(serviceName => {\n      // Ignore virtual services\n      let factoryName = useAsService(app, serviceName);\n      if (factoryName === null) {\n        return;\n      }\n\n      if (appHooks[factoryName]) {\n        appHooks[factoryName](eventName, app);\n      }\n    });\n  }\n\n  // Map the requested service to a registered service name\n  // (used to map auth to serverAuth service when needed).\n  function useAsService(app: FirebaseApp, name: string): string | null {\n    if (name === 'serverAuth') {\n      return null;\n    }\n\n    let useService = name;\n    let options = app.options;\n\n    return useService;\n  }\n\n  return (namespace as any) as FirebaseNamespace;\n}\n\ntype AppError =\n  | 'no-app'\n  | 'bad-app-name'\n  | 'duplicate-app'\n  | 'app-deleted'\n  | 'duplicate-service'\n  | 'sa-not-supported'\n  | 'invalid-app-argument';\n\nfunction error(code: AppError, args?: { [name: string]: any }) {\n  throw appErrors.create(code, args);\n}\n\n// TypeScript does not support non-string indexes!\n// let errors: {[code: AppError: string} = {\nlet errors: { [code: string]: string } = {\n  'no-app':\n    \"No Firebase App '{$name}' has been created - \" +\n    'call Firebase App.initializeApp()',\n  'bad-app-name': \"Illegal App name: '{$name}\",\n  'duplicate-app': \"Firebase App named '{$name}' already exists\",\n  'app-deleted': \"Firebase App named '{$name}' already deleted\",\n  'duplicate-service': \"Firebase service named '{$name}' already registered\",\n  'sa-not-supported':\n    'Initializing the Firebase SDK with a service ' +\n    'account is only allowed in a Node.js environment. On client ' +\n    'devices, you should instead initialize the SDK with an api key and ' +\n    'auth domain',\n  'invalid-app-argument':\n    'firebase.{$name}() takes either no argument or a ' +\n    'Firebase App instance.'\n};\n\nlet appErrors = new ErrorFactory<AppError>('app', 'Firebase', errors);\n","/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\nimport { createSubscribe } from './subscribe';\nimport { ErrorFactory } from './errors';\nimport { PromiseImpl } from '../utils/promise';\nimport { patchProperty, deepCopy, deepExtend } from '../utils/deep_copy';\nvar contains = function (obj, key) {\n    return Object.prototype.hasOwnProperty.call(obj, key);\n};\nvar DEFAULT_ENTRY_NAME = '[DEFAULT]';\n// An array to capture listeners before the true auth functions\n// exist\nvar tokenListeners = [];\n/**\n * Global context object for a collection of services using\n * a shared authentication state.\n */\nvar FirebaseAppImpl = (function () {\n    function FirebaseAppImpl(options, name, firebase_) {\n        this.firebase_ = firebase_;\n        this.isDeleted_ = false;\n        this.services_ = {};\n        this.name_ = name;\n        this.options_ = deepCopy(options);\n        this.INTERNAL = {\n            getUid: function () { return null; },\n            getToken: function () { return PromiseImpl.resolve(null); },\n            addAuthTokenListener: function (callback) {\n                tokenListeners.push(callback);\n                // Make sure callback is called, asynchronously, in the absence of the auth module\n                setTimeout(function () { return callback(null); }, 0);\n            },\n            removeAuthTokenListener: function (callback) {\n                tokenListeners = tokenListeners.filter(function (listener) { return listener !== callback; });\n            }\n        };\n    }\n    Object.defineProperty(FirebaseAppImpl.prototype, \"name\", {\n        get: function () {\n            this.checkDestroyed_();\n            return this.name_;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(FirebaseAppImpl.prototype, \"options\", {\n        get: function () {\n            this.checkDestroyed_();\n            return this.options_;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    FirebaseAppImpl.prototype.delete = function () {\n        var _this = this;\n        return new PromiseImpl(function (resolve) {\n            _this.checkDestroyed_();\n            resolve();\n        })\n            .then(function () {\n            _this.firebase_.INTERNAL.removeApp(_this.name_);\n            var services = [];\n            Object.keys(_this.services_).forEach(function (serviceKey) {\n                Object.keys(_this.services_[serviceKey]).forEach(function (instanceKey) {\n                    services.push(_this.services_[serviceKey][instanceKey]);\n                });\n            });\n            return PromiseImpl.all(services.map(function (service) {\n                return service.INTERNAL.delete();\n            }));\n        })\n            .then(function () {\n            _this.isDeleted_ = true;\n            _this.services_ = {};\n        });\n    };\n    /**\n     * Return a service instance associated with this app (creating it\n     * on demand), identified by the passed instanceIdentifier.\n     *\n     * NOTE: Currently storage is the only one that is leveraging this\n     * functionality. They invoke it by calling:\n     *\n     * ```javascript\n     * firebase.app().storage('STORAGE BUCKET ID')\n     * ```\n     *\n     * The service name is passed to this already\n     * @internal\n     */\n    FirebaseAppImpl.prototype._getService = function (name, instanceIdentifier) {\n        if (instanceIdentifier === void 0) { instanceIdentifier = DEFAULT_ENTRY_NAME; }\n        this.checkDestroyed_();\n        if (!this.services_[name]) {\n            this.services_[name] = {};\n        }\n        if (!this.services_[name][instanceIdentifier]) {\n            /**\n             * If a custom instance has been defined (i.e. not '[DEFAULT]')\n             * then we will pass that instance on, otherwise we pass `null`\n             */\n            var instanceSpecifier = instanceIdentifier !== DEFAULT_ENTRY_NAME\n                ? instanceIdentifier\n                : undefined;\n            var service = this.firebase_.INTERNAL.factories[name](this, this.extendApp.bind(this), instanceSpecifier);\n            this.services_[name][instanceIdentifier] = service;\n        }\n        return this.services_[name][instanceIdentifier];\n    };\n    /**\n     * Callback function used to extend an App instance at the time\n     * of service instance creation.\n     */\n    FirebaseAppImpl.prototype.extendApp = function (props) {\n        var _this = this;\n        // Copy the object onto the FirebaseAppImpl prototype\n        deepExtend(this, props);\n        /**\n         * If the app has overwritten the addAuthTokenListener stub, forward\n         * the active token listeners on to the true fxn.\n         *\n         * TODO: This function is required due to our current module\n         * structure. Once we are able to rely strictly upon a single module\n         * implementation, this code should be refactored and Auth should\n         * provide these stubs and the upgrade logic\n         */\n        if (props.INTERNAL && props.INTERNAL.addAuthTokenListener) {\n            tokenListeners.forEach(function (listener) {\n                _this.INTERNAL.addAuthTokenListener(listener);\n            });\n            tokenListeners = [];\n        }\n    };\n    /**\n     * This function will throw an Error if the App has already been deleted -\n     * use before performing API actions on the App.\n     */\n    FirebaseAppImpl.prototype.checkDestroyed_ = function () {\n        if (this.isDeleted_) {\n            error('app-deleted', { name: this.name_ });\n        }\n    };\n    return FirebaseAppImpl;\n}());\n// Prevent dead-code elimination of these methods w/o invalid property\n// copying.\n(FirebaseAppImpl.prototype.name && FirebaseAppImpl.prototype.options) ||\n    FirebaseAppImpl.prototype.delete ||\n    console.log('dc');\n/**\n * Return a firebase namespace object.\n *\n * In production, this will be called exactly once and the result\n * assigned to the 'firebase' global.  It may be called multiple times\n * in unit tests.\n */\nexport function createFirebaseNamespace() {\n    var apps_ = {};\n    var factories = {};\n    var appHooks = {};\n    // A namespace is a plain JavaScript Object.\n    var namespace = {\n        // Hack to prevent Babel from modifying the object returned\n        // as the firebase namespace.\n        __esModule: true,\n        initializeApp: initializeApp,\n        app: app,\n        apps: null,\n        Promise: PromiseImpl,\n        SDK_VERSION: '4.3.1',\n        INTERNAL: {\n            registerService: registerService,\n            createFirebaseNamespace: createFirebaseNamespace,\n            extendNamespace: extendNamespace,\n            createSubscribe: createSubscribe,\n            ErrorFactory: ErrorFactory,\n            removeApp: removeApp,\n            factories: factories,\n            useAsService: useAsService,\n            Promise: PromiseImpl,\n            deepExtend: deepExtend\n        }\n    };\n    // Inject a circular default export to allow Babel users who were previously\n    // using:\n    //\n    //   import firebase from 'firebase';\n    //   which becomes: var firebase = require('firebase').default;\n    //\n    // instead of\n    //\n    //   import * as firebase from 'firebase';\n    //   which becomes: var firebase = require('firebase');\n    patchProperty(namespace, 'default', namespace);\n    // firebase.apps is a read-only getter.\n    Object.defineProperty(namespace, 'apps', {\n        get: getApps\n    });\n    /**\n     * Called by App.delete() - but before any services associated with the App\n     * are deleted.\n     */\n    function removeApp(name) {\n        var app = apps_[name];\n        callAppHooks(app, 'delete');\n        delete apps_[name];\n    }\n    /**\n     * Get the App object for a given name (or DEFAULT).\n     */\n    function app(name) {\n        name = name || DEFAULT_ENTRY_NAME;\n        if (!contains(apps_, name)) {\n            error('no-app', { name: name });\n        }\n        return apps_[name];\n    }\n    patchProperty(app, 'App', FirebaseAppImpl);\n    /**\n     * Create a new App instance (name must be unique).\n     */\n    function initializeApp(options, name) {\n        if (name === undefined) {\n            name = DEFAULT_ENTRY_NAME;\n        }\n        else {\n            if (typeof name !== 'string' || name === '') {\n                error('bad-app-name', { name: name + '' });\n            }\n        }\n        if (contains(apps_, name)) {\n            error('duplicate-app', { name: name });\n        }\n        var app = new FirebaseAppImpl(options, name, namespace);\n        apps_[name] = app;\n        callAppHooks(app, 'create');\n        return app;\n    }\n    /*\n     * Return an array of all the non-deleted FirebaseApps.\n     */\n    function getApps() {\n        // Make a copy so caller cannot mutate the apps list.\n        return Object.keys(apps_).map(function (name) { return apps_[name]; });\n    }\n    /*\n     * Register a Firebase Service.\n     *\n     * firebase.INTERNAL.registerService()\n     *\n     * TODO: Implement serviceProperties.\n     */\n    function registerService(name, createService, serviceProperties, appHook, allowMultipleInstances) {\n        // Cannot re-register a service that already exists\n        if (factories[name]) {\n            error('duplicate-service', { name: name });\n        }\n        // Capture the service factory for later service instantiation\n        factories[name] = createService;\n        // Capture the appHook, if passed\n        if (appHook) {\n            appHooks[name] = appHook;\n            // Run the **new** app hook on all existing apps\n            getApps().forEach(function (app) {\n                appHook('create', app);\n            });\n        }\n        // The Service namespace is an accessor function ...\n        var serviceNamespace = function (appArg) {\n            if (appArg === void 0) { appArg = app(); }\n            if (typeof appArg[name] !== 'function') {\n                // Invalid argument.\n                // This happens in the following case: firebase.storage('gs:/')\n                error('invalid-app-argument', { name: name });\n            }\n            // Forward service instance lookup to the FirebaseApp.\n            return appArg[name]();\n        };\n        // ... and a container for service-level properties.\n        if (serviceProperties !== undefined) {\n            deepExtend(serviceNamespace, serviceProperties);\n        }\n        // Monkey-patch the serviceNamespace onto the firebase namespace\n        namespace[name] = serviceNamespace;\n        // Patch the FirebaseAppImpl prototype\n        FirebaseAppImpl.prototype[name] = function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            var serviceFxn = this._getService.bind(this, name);\n            return serviceFxn.apply(this, allowMultipleInstances ? args : []);\n        };\n        return serviceNamespace;\n    }\n    /**\n     * Patch the top-level firebase namespace with additional properties.\n     *\n     * firebase.INTERNAL.extendNamespace()\n     */\n    function extendNamespace(props) {\n        deepExtend(namespace, props);\n    }\n    function callAppHooks(app, eventName) {\n        Object.keys(factories).forEach(function (serviceName) {\n            // Ignore virtual services\n            var factoryName = useAsService(app, serviceName);\n            if (factoryName === null) {\n                return;\n            }\n            if (appHooks[factoryName]) {\n                appHooks[factoryName](eventName, app);\n            }\n        });\n    }\n    // Map the requested service to a registered service name\n    // (used to map auth to serverAuth service when needed).\n    function useAsService(app, name) {\n        if (name === 'serverAuth') {\n            return null;\n        }\n        var useService = name;\n        var options = app.options;\n        return useService;\n    }\n    return namespace;\n}\nfunction error(code, args) {\n    throw appErrors.create(code, args);\n}\n// TypeScript does not support non-string indexes!\n// let errors: {[code: AppError: string} = {\nvar errors = {\n    'no-app': \"No Firebase App '{$name}' has been created - \" +\n        'call Firebase App.initializeApp()',\n    'bad-app-name': \"Illegal App name: '{$name}\",\n    'duplicate-app': \"Firebase App named '{$name}' already exists\",\n    'app-deleted': \"Firebase App named '{$name}' already deleted\",\n    'duplicate-service': \"Firebase service named '{$name}' already registered\",\n    'sa-not-supported': 'Initializing the Firebase SDK with a service ' +\n        'account is only allowed in a Node.js environment. On client ' +\n        'devices, you should instead initialize the SDK with an api key and ' +\n        'auth domain',\n    'invalid-app-argument': 'firebase.{$name}() takes either no argument or a ' +\n        'Firebase App instance.'\n};\nvar appErrors = new ErrorFactory('app', 'Firebase', errors);\n\n\n"]}