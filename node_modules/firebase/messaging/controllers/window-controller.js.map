{"version":3,"sources":["src/messaging/controllers/window-controller.ts","messaging/controllers/window-controller.js"],"names":["__extends","extendStatics","Object","setPrototypeOf","__proto__","Array","d","b","p","hasOwnProperty","__","constructor","prototype","create","WindowController","_super","app","_this","call","registrationToUse_","manifestCheckPromise_","messageObserver_","onMessage_","observer","tokenRefreshObserver_","onTokenRefresh_","setupSWMessageListener_","getToken","isSupported_","Promise","reject","errorFactory_","codes","UNSUPPORTED_BROWSER","manifestCheck_","then","manifestTag","document","querySelector","resolve","fetch","href","response","json","catch","manifestContent","INCORRECT_GCM_SENDER_ID","requestPermission","Notification","permission","granted","managePermissionResult","result","denied","PERMISSION_BLOCKED","PERMISSION_DEFAULT","permissionPromise","useServiceWorker","registration","ServiceWorkerRegistration","SW_REGISTRATION_EXPECTED","USE_SW_BEFORE_GET_TOKEN","onMessage","nextOrObserver","optError","optCompleted","onTokenRefresh","waitForRegistrationToActivate_","serviceWorker","installing","waiting","active","NO_SW_IN_REG","state","SW_REG_REDUNDANT","stateChangeListener","removeEventListener","addEventListener","getSWRegistration_","navigator","register","path","scope","err","FAILED_DEFAULT_REGISTRATION","browserErrorMessage","message","update","event","data","PARAMS","TYPE_OF_MSG","workerPageMessage","TYPES_OF_MSG","PUSH_MSG_RECEIVED","NOTIFICATION_CLICKED","pushMessage","DATA","next","window","PushSubscription"],"mappings":"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","file":"window-controller.js","sourcesContent":["/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n'use strict';\n\nimport ControllerInterface from './controller-interface';\nimport Errors from '../models/errors';\nimport WorkerPageMessage from '../models/worker-page-message';\nimport DefaultSW from '../models/default-sw';\nimport NOTIFICATION_PERMISSION from '../models/notification-permission';\nimport { createSubscribe } from '../../app/subscribe';\n\ndeclare const firebase: any;\n\nexport default class WindowController extends ControllerInterface {\n  private registrationToUse_;\n  private manifestCheckPromise_;\n  private messageObserver_;\n  private onMessage_;\n  private tokenRefreshObserver_;\n  private onTokenRefresh_;\n\n  /**\n   * A service that provides a MessagingService instance.\n   * @param {!firebase.app.App} app\n   */\n  constructor(app) {\n    super(app);\n\n    /**\n     * @private\n     * @type {ServiceWorkerRegistration}\n     */\n    this.registrationToUse_;\n\n    /**\n     * @private\n     * @type {Promise}\n     */\n    this.manifestCheckPromise_;\n\n    /**\n     * @private\n     * @type {firebase.Observer}\n     */\n    this.messageObserver_ = null;\n    /**\n     * @private {!firebase.Subscribe} The subscribe function to the onMessage\n     * observer.\n     */\n    this.onMessage_ = createSubscribe(observer => {\n      this.messageObserver_ = observer;\n    });\n\n    /**\n     * @private\n     * @type {firebase.Observer}\n     */\n    this.tokenRefreshObserver_ = null;\n    this.onTokenRefresh_ = createSubscribe(observer => {\n      this.tokenRefreshObserver_ = observer;\n    });\n\n    this.setupSWMessageListener_();\n  }\n\n  /**\n   * This method returns an FCM token if it can be generated.\n   * The return promise will reject if the browser doesn't support\n   * FCM, if permission is denied for notifications or it's not\n   * possible to generate a token.\n   * @export\n   * @return {Promise<string> | Promise<null>} Returns a promise the\n   * resolves to an FCM token or null if permission isn't granted.\n   */\n  getToken() {\n    // Check that the required API's are available\n    if (!this.isSupported_()) {\n      return Promise.reject(\n        this.errorFactory_.create(Errors.codes.UNSUPPORTED_BROWSER)\n      );\n    }\n\n    return this.manifestCheck_().then(() => {\n      return super.getToken();\n    });\n  }\n\n  /**\n   * The method checks that a manifest is defined and has the correct GCM\n   * sender ID.\n   * @private\n   * @return {Promise} Returns a promise that resolves if the manifest matches\n   * our required sender ID\n   */\n  manifestCheck_() {\n    if (this.manifestCheckPromise_) {\n      return this.manifestCheckPromise_;\n    }\n\n    const manifestTag = <HTMLAnchorElement>document.querySelector(\n      'link[rel=\"manifest\"]'\n    );\n    if (!manifestTag) {\n      this.manifestCheckPromise_ = Promise.resolve();\n    } else {\n      this.manifestCheckPromise_ = fetch(manifestTag.href)\n        .then(response => {\n          return response.json();\n        })\n        .catch(() => {\n          // If the download or parsing fails allow check.\n          // We only want to error if we KNOW that the gcm_sender_id is incorrect.\n          return Promise.resolve();\n        })\n        .then(manifestContent => {\n          if (!manifestContent) {\n            return;\n          }\n\n          if (!manifestContent['gcm_sender_id']) {\n            return;\n          }\n\n          if (manifestContent['gcm_sender_id'] !== '103953800507') {\n            throw this.errorFactory_.create(\n              Errors.codes.INCORRECT_GCM_SENDER_ID\n            );\n          }\n        });\n    }\n\n    return this.manifestCheckPromise_;\n  }\n\n  /**\n   * Request permission if it is not currently granted\n   * @export\n   * @returns {Promise} Resolves if the permission was granted, otherwise\n   * rejects\n   */\n  requestPermission() {\n    if ((Notification as any).permission === NOTIFICATION_PERMISSION.granted) {\n      return Promise.resolve();\n    }\n\n    return new Promise((resolve, reject) => {\n      const managePermissionResult = result => {\n        if (result === NOTIFICATION_PERMISSION.granted) {\n          return resolve();\n        } else if (result === NOTIFICATION_PERMISSION.denied) {\n          return reject(\n            this.errorFactory_.create(Errors.codes.PERMISSION_BLOCKED)\n          );\n        } else {\n          return reject(\n            this.errorFactory_.create(Errors.codes.PERMISSION_DEFAULT)\n          );\n        }\n      };\n\n      // The Notification.requestPermission API was changed to\n      // return a promise so now have to handle both in case\n      // browsers stop support callbacks for promised version\n      const permissionPromise = Notification.requestPermission(result => {\n        if (permissionPromise) {\n          // Let the promise manage this\n          return;\n        }\n\n        managePermissionResult(result);\n      });\n\n      if (permissionPromise) {\n        // Prefer the promise version as it's the future API.\n        permissionPromise.then(managePermissionResult);\n      }\n    });\n  }\n\n  /**\n   * This method allows a developer to override the default service worker and\n   * instead use a custom service worker.\n   * @export\n   * @param {!ServiceWorkerRegistration} registration The service worker\n   * registration that should be used to receive the push messages.\n   */\n  useServiceWorker(registration) {\n    if (!(registration instanceof ServiceWorkerRegistration)) {\n      throw this.errorFactory_.create(Errors.codes.SW_REGISTRATION_EXPECTED);\n    }\n\n    if (typeof this.registrationToUse_ !== 'undefined') {\n      throw this.errorFactory_.create(Errors.codes.USE_SW_BEFORE_GET_TOKEN);\n    }\n\n    this.registrationToUse_ = registration;\n  }\n\n  /**\n   * @export\n   * @param {!firebase.Observer|function(*)} nextOrObserver An observer object\n   * or a function triggered on message.\n   * @param {function(!Error)=} optError Optional A function triggered on\n   * message error.\n   * @param {function()=} optCompleted Optional function triggered when the\n   * observer is removed.\n   * @return {!function()} The unsubscribe function for the observer.\n   */\n  onMessage(nextOrObserver, optError, optCompleted) {\n    return this.onMessage_(nextOrObserver, optError, optCompleted);\n  }\n\n  /**\n   * @export\n   * @param {!firebase.Observer|function()} nextOrObserver An observer object\n   * or a function triggered on token refresh.\n   * @param {function(!Error)=} optError Optional A function\n   * triggered on token refresh error.\n   * @param {function()=} optCompleted Optional function triggered when the\n   * observer is removed.\n   * @return {!function()} The unsubscribe function for the observer.\n   */\n  onTokenRefresh(nextOrObserver, optError, optCompleted) {\n    return this.onTokenRefresh_(nextOrObserver, optError, optCompleted);\n  }\n\n  /**\n   * Given a registration, wait for the service worker it relates to\n   * become activer\n   * @private\n   * @param  {ServiceWorkerRegistration} registration Registration to wait\n   * for service worker to become active\n   * @return {Promise<!ServiceWorkerRegistration>} Wait for service worker\n   * registration to become active\n   */\n  waitForRegistrationToActivate_(registration) {\n    const serviceWorker =\n      registration.installing || registration.waiting || registration.active;\n\n    return new Promise<ServiceWorkerRegistration>((resolve, reject) => {\n      if (!serviceWorker) {\n        // This is a rare scenario but has occured in firefox\n        reject(this.errorFactory_.create(Errors.codes.NO_SW_IN_REG));\n        return;\n      }\n      // Because the Promise function is called on next tick there is a\n      // small chance that the worker became active or redundant already.\n      if (serviceWorker.state === 'activated') {\n        resolve(registration);\n        return;\n      }\n\n      if (serviceWorker.state === 'redundant') {\n        reject(this.errorFactory_.create(Errors.codes.SW_REG_REDUNDANT));\n        return;\n      }\n\n      let stateChangeListener = () => {\n        if (serviceWorker.state === 'activated') {\n          resolve(registration);\n        } else if (serviceWorker.state === 'redundant') {\n          reject(this.errorFactory_.create(Errors.codes.SW_REG_REDUNDANT));\n        } else {\n          // Return early and wait to next state change\n          return;\n        }\n        serviceWorker.removeEventListener('statechange', stateChangeListener);\n      };\n      serviceWorker.addEventListener('statechange', stateChangeListener);\n    });\n  }\n\n  /**\n   * This will regiater the default service worker and return the registration\n   * @private\n   * @return {Promise<!ServiceWorkerRegistration>} The service worker\n   * registration to be used for the push service.\n   */\n  getSWRegistration_() {\n    if (this.registrationToUse_) {\n      return this.waitForRegistrationToActivate_(this.registrationToUse_);\n    }\n\n    // Make the registration null so we know useServiceWorker will not\n    // use a new service worker as registrationToUse_ is no longer undefined\n    this.registrationToUse_ = null;\n\n    return navigator.serviceWorker\n      .register(DefaultSW.path, {\n        scope: DefaultSW.scope\n      })\n      .catch(err => {\n        throw this.errorFactory_.create(\n          Errors.codes.FAILED_DEFAULT_REGISTRATION,\n          {\n            browserErrorMessage: err.message\n          }\n        );\n      })\n      .then(registration => {\n        return this.waitForRegistrationToActivate_(registration).then(() => {\n          this.registrationToUse_ = registration;\n\n          // We update after activation due to an issue with Firefox v49 where\n          // a race condition occassionally causes the service work to not\n          // install\n          registration.update();\n\n          return registration;\n        });\n      });\n  }\n\n  /**\n   * This method will set up a message listener to handle\n   * events from the service worker that should trigger\n   * events in the page.\n   *\n   * @private\n   */\n  setupSWMessageListener_() {\n    if (!('serviceWorker' in navigator)) {\n      return;\n    }\n\n    navigator.serviceWorker.addEventListener(\n      'message',\n      event => {\n        if (!event.data || !event.data[WorkerPageMessage.PARAMS.TYPE_OF_MSG]) {\n          // Not a message from FCM\n          return;\n        }\n\n        const workerPageMessage = event.data;\n        switch (workerPageMessage[WorkerPageMessage.PARAMS.TYPE_OF_MSG]) {\n          case WorkerPageMessage.TYPES_OF_MSG.PUSH_MSG_RECEIVED:\n          case WorkerPageMessage.TYPES_OF_MSG.NOTIFICATION_CLICKED:\n            const pushMessage =\n              workerPageMessage[WorkerPageMessage.PARAMS.DATA];\n            this.messageObserver_.next(pushMessage);\n            break;\n          default:\n            // Noop.\n            break;\n        }\n      },\n      false\n    );\n  }\n\n  /**\n   * Checks to see if the required API's are valid or not.\n   * @private\n   * @return {boolean} Returns true if the desired APIs are available.\n   */\n  isSupported_() {\n    return (\n      'serviceWorker' in navigator &&\n      'PushManager' in window &&\n      'Notification' in window &&\n      'fetch' in window &&\n      ServiceWorkerRegistration.prototype.hasOwnProperty('showNotification') &&\n      PushSubscription.prototype.hasOwnProperty('getKey')\n    );\n  }\n}\n","/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n'use strict';\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport ControllerInterface from './controller-interface';\nimport Errors from '../models/errors';\nimport WorkerPageMessage from '../models/worker-page-message';\nimport DefaultSW from '../models/default-sw';\nimport NOTIFICATION_PERMISSION from '../models/notification-permission';\nimport { createSubscribe } from '../../app/subscribe';\nvar WindowController = (function (_super) {\n    __extends(WindowController, _super);\n    /**\n     * A service that provides a MessagingService instance.\n     * @param {!firebase.app.App} app\n     */\n    function WindowController(app) {\n        var _this = _super.call(this, app) || this;\n        /**\n         * @private\n         * @type {ServiceWorkerRegistration}\n         */\n        _this.registrationToUse_;\n        /**\n         * @private\n         * @type {Promise}\n         */\n        _this.manifestCheckPromise_;\n        /**\n         * @private\n         * @type {firebase.Observer}\n         */\n        _this.messageObserver_ = null;\n        /**\n         * @private {!firebase.Subscribe} The subscribe function to the onMessage\n         * observer.\n         */\n        _this.onMessage_ = createSubscribe(function (observer) {\n            _this.messageObserver_ = observer;\n        });\n        /**\n         * @private\n         * @type {firebase.Observer}\n         */\n        _this.tokenRefreshObserver_ = null;\n        _this.onTokenRefresh_ = createSubscribe(function (observer) {\n            _this.tokenRefreshObserver_ = observer;\n        });\n        _this.setupSWMessageListener_();\n        return _this;\n    }\n    /**\n     * This method returns an FCM token if it can be generated.\n     * The return promise will reject if the browser doesn't support\n     * FCM, if permission is denied for notifications or it's not\n     * possible to generate a token.\n     * @export\n     * @return {Promise<string> | Promise<null>} Returns a promise the\n     * resolves to an FCM token or null if permission isn't granted.\n     */\n    WindowController.prototype.getToken = function () {\n        var _this = this;\n        // Check that the required API's are available\n        if (!this.isSupported_()) {\n            return Promise.reject(this.errorFactory_.create(Errors.codes.UNSUPPORTED_BROWSER));\n        }\n        return this.manifestCheck_().then(function () {\n            return _super.prototype.getToken.call(_this);\n        });\n    };\n    /**\n     * The method checks that a manifest is defined and has the correct GCM\n     * sender ID.\n     * @private\n     * @return {Promise} Returns a promise that resolves if the manifest matches\n     * our required sender ID\n     */\n    WindowController.prototype.manifestCheck_ = function () {\n        var _this = this;\n        if (this.manifestCheckPromise_) {\n            return this.manifestCheckPromise_;\n        }\n        var manifestTag = document.querySelector('link[rel=\"manifest\"]');\n        if (!manifestTag) {\n            this.manifestCheckPromise_ = Promise.resolve();\n        }\n        else {\n            this.manifestCheckPromise_ = fetch(manifestTag.href)\n                .then(function (response) {\n                return response.json();\n            })\n                .catch(function () {\n                // If the download or parsing fails allow check.\n                // We only want to error if we KNOW that the gcm_sender_id is incorrect.\n                return Promise.resolve();\n            })\n                .then(function (manifestContent) {\n                if (!manifestContent) {\n                    return;\n                }\n                if (!manifestContent['gcm_sender_id']) {\n                    return;\n                }\n                if (manifestContent['gcm_sender_id'] !== '103953800507') {\n                    throw _this.errorFactory_.create(Errors.codes.INCORRECT_GCM_SENDER_ID);\n                }\n            });\n        }\n        return this.manifestCheckPromise_;\n    };\n    /**\n     * Request permission if it is not currently granted\n     * @export\n     * @returns {Promise} Resolves if the permission was granted, otherwise\n     * rejects\n     */\n    WindowController.prototype.requestPermission = function () {\n        var _this = this;\n        if (Notification.permission === NOTIFICATION_PERMISSION.granted) {\n            return Promise.resolve();\n        }\n        return new Promise(function (resolve, reject) {\n            var managePermissionResult = function (result) {\n                if (result === NOTIFICATION_PERMISSION.granted) {\n                    return resolve();\n                }\n                else if (result === NOTIFICATION_PERMISSION.denied) {\n                    return reject(_this.errorFactory_.create(Errors.codes.PERMISSION_BLOCKED));\n                }\n                else {\n                    return reject(_this.errorFactory_.create(Errors.codes.PERMISSION_DEFAULT));\n                }\n            };\n            // The Notification.requestPermission API was changed to\n            // return a promise so now have to handle both in case\n            // browsers stop support callbacks for promised version\n            var permissionPromise = Notification.requestPermission(function (result) {\n                if (permissionPromise) {\n                    // Let the promise manage this\n                    return;\n                }\n                managePermissionResult(result);\n            });\n            if (permissionPromise) {\n                // Prefer the promise version as it's the future API.\n                permissionPromise.then(managePermissionResult);\n            }\n        });\n    };\n    /**\n     * This method allows a developer to override the default service worker and\n     * instead use a custom service worker.\n     * @export\n     * @param {!ServiceWorkerRegistration} registration The service worker\n     * registration that should be used to receive the push messages.\n     */\n    WindowController.prototype.useServiceWorker = function (registration) {\n        if (!(registration instanceof ServiceWorkerRegistration)) {\n            throw this.errorFactory_.create(Errors.codes.SW_REGISTRATION_EXPECTED);\n        }\n        if (typeof this.registrationToUse_ !== 'undefined') {\n            throw this.errorFactory_.create(Errors.codes.USE_SW_BEFORE_GET_TOKEN);\n        }\n        this.registrationToUse_ = registration;\n    };\n    /**\n     * @export\n     * @param {!firebase.Observer|function(*)} nextOrObserver An observer object\n     * or a function triggered on message.\n     * @param {function(!Error)=} optError Optional A function triggered on\n     * message error.\n     * @param {function()=} optCompleted Optional function triggered when the\n     * observer is removed.\n     * @return {!function()} The unsubscribe function for the observer.\n     */\n    WindowController.prototype.onMessage = function (nextOrObserver, optError, optCompleted) {\n        return this.onMessage_(nextOrObserver, optError, optCompleted);\n    };\n    /**\n     * @export\n     * @param {!firebase.Observer|function()} nextOrObserver An observer object\n     * or a function triggered on token refresh.\n     * @param {function(!Error)=} optError Optional A function\n     * triggered on token refresh error.\n     * @param {function()=} optCompleted Optional function triggered when the\n     * observer is removed.\n     * @return {!function()} The unsubscribe function for the observer.\n     */\n    WindowController.prototype.onTokenRefresh = function (nextOrObserver, optError, optCompleted) {\n        return this.onTokenRefresh_(nextOrObserver, optError, optCompleted);\n    };\n    /**\n     * Given a registration, wait for the service worker it relates to\n     * become activer\n     * @private\n     * @param  {ServiceWorkerRegistration} registration Registration to wait\n     * for service worker to become active\n     * @return {Promise<!ServiceWorkerRegistration>} Wait for service worker\n     * registration to become active\n     */\n    WindowController.prototype.waitForRegistrationToActivate_ = function (registration) {\n        var _this = this;\n        var serviceWorker = registration.installing || registration.waiting || registration.active;\n        return new Promise(function (resolve, reject) {\n            if (!serviceWorker) {\n                // This is a rare scenario but has occured in firefox\n                reject(_this.errorFactory_.create(Errors.codes.NO_SW_IN_REG));\n                return;\n            }\n            // Because the Promise function is called on next tick there is a\n            // small chance that the worker became active or redundant already.\n            if (serviceWorker.state === 'activated') {\n                resolve(registration);\n                return;\n            }\n            if (serviceWorker.state === 'redundant') {\n                reject(_this.errorFactory_.create(Errors.codes.SW_REG_REDUNDANT));\n                return;\n            }\n            var stateChangeListener = function () {\n                if (serviceWorker.state === 'activated') {\n                    resolve(registration);\n                }\n                else if (serviceWorker.state === 'redundant') {\n                    reject(_this.errorFactory_.create(Errors.codes.SW_REG_REDUNDANT));\n                }\n                else {\n                    // Return early and wait to next state change\n                    return;\n                }\n                serviceWorker.removeEventListener('statechange', stateChangeListener);\n            };\n            serviceWorker.addEventListener('statechange', stateChangeListener);\n        });\n    };\n    /**\n     * This will regiater the default service worker and return the registration\n     * @private\n     * @return {Promise<!ServiceWorkerRegistration>} The service worker\n     * registration to be used for the push service.\n     */\n    WindowController.prototype.getSWRegistration_ = function () {\n        var _this = this;\n        if (this.registrationToUse_) {\n            return this.waitForRegistrationToActivate_(this.registrationToUse_);\n        }\n        // Make the registration null so we know useServiceWorker will not\n        // use a new service worker as registrationToUse_ is no longer undefined\n        this.registrationToUse_ = null;\n        return navigator.serviceWorker\n            .register(DefaultSW.path, {\n            scope: DefaultSW.scope\n        })\n            .catch(function (err) {\n            throw _this.errorFactory_.create(Errors.codes.FAILED_DEFAULT_REGISTRATION, {\n                browserErrorMessage: err.message\n            });\n        })\n            .then(function (registration) {\n            return _this.waitForRegistrationToActivate_(registration).then(function () {\n                _this.registrationToUse_ = registration;\n                // We update after activation due to an issue with Firefox v49 where\n                // a race condition occassionally causes the service work to not\n                // install\n                registration.update();\n                return registration;\n            });\n        });\n    };\n    /**\n     * This method will set up a message listener to handle\n     * events from the service worker that should trigger\n     * events in the page.\n     *\n     * @private\n     */\n    WindowController.prototype.setupSWMessageListener_ = function () {\n        var _this = this;\n        if (!('serviceWorker' in navigator)) {\n            return;\n        }\n        navigator.serviceWorker.addEventListener('message', function (event) {\n            if (!event.data || !event.data[WorkerPageMessage.PARAMS.TYPE_OF_MSG]) {\n                // Not a message from FCM\n                return;\n            }\n            var workerPageMessage = event.data;\n            switch (workerPageMessage[WorkerPageMessage.PARAMS.TYPE_OF_MSG]) {\n                case WorkerPageMessage.TYPES_OF_MSG.PUSH_MSG_RECEIVED:\n                case WorkerPageMessage.TYPES_OF_MSG.NOTIFICATION_CLICKED:\n                    var pushMessage = workerPageMessage[WorkerPageMessage.PARAMS.DATA];\n                    _this.messageObserver_.next(pushMessage);\n                    break;\n                default:\n                    // Noop.\n                    break;\n            }\n        }, false);\n    };\n    /**\n     * Checks to see if the required API's are valid or not.\n     * @private\n     * @return {boolean} Returns true if the desired APIs are available.\n     */\n    WindowController.prototype.isSupported_ = function () {\n        return ('serviceWorker' in navigator &&\n            'PushManager' in window &&\n            'Notification' in window &&\n            'fetch' in window &&\n            ServiceWorkerRegistration.prototype.hasOwnProperty('showNotification') &&\n            PushSubscription.prototype.hasOwnProperty('getKey'));\n    };\n    return WindowController;\n}(ControllerInterface));\nexport default WindowController;\n\n\n"]}