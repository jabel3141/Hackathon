{"version":3,"sources":["src/messaging/controllers/sw-controller.ts","messaging/controllers/sw-controller.js"],"names":["__extends","extendStatics","Object","setPrototypeOf","__proto__","Array","d","b","p","hasOwnProperty","__","constructor","prototype","create","FCM_MSG","SWController","_super","app","_this","call","self","addEventListener","e","onPush_","onSubChange_","onNotificationClick_","bgMessageHandler_","event","msgPayload","data","json","err","handleMsgPromise","hasVisibleClients_","then","hasVisibleClients","notification","sendMessageToWindowClients_","notificationDetails","getNotificationData_","notificationTitle","title","registration","showNotification","waitUntil","promiseChain","getToken","token","errorFactory_","codes","NO_FCM_TOKEN_FOR_RESUBSCRIBE","tokenDetails","tokenManager","getTokenManager","getTokenDetailsFromToken","details","INVALID_SAVED_TOKEN","pushManager","subscribe","SUBSCRIPTION_OPTIONS","newSubscription","subscribeToFCM","fcmSenderId","fcmPushSet","catch","deleteToken","fcmToken","UNABLE_TO_RESUBSCRIBE","message","stopImmediatePropagation","close","clickAction","getWindowClient_","windowClient","clients","openWindow","notificationData","internalMsg","createNewMsg","TYPES_OF_MSG","NOTIFICATION_CLICKED","attemptToMessageClient_","notificationInformation","assign","_a","setBackgroundMessageHandler","callback","BG_HANDLER_FUNCTION_EXPECTED","url","parsedURL","URL","href","matchAll","type","includeUncontrolled","clientList","suitableClient","i","length","parsedClientUrl","focus","client","Promise","resolve","reject","NO_WINDOW_CLIENT_TO_MSG","postMessage","some","visibilityState","PUSH_MSG_RECEIVED","all","map","getSWRegistration_"],"mappings":"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","file":"sw-controller.js","sourcesContent":["/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n'use strict';\n\nimport ControllerInterface from './controller-interface';\nimport Errors from '../models/errors';\nimport WorkerPageMessage from '../models/worker-page-message';\nimport FCMDetails from '../models/fcm-details';\n\nconst FCM_MSG = 'FCM_MSG';\n\nexport default class SWController extends ControllerInterface {\n  private bgMessageHandler_: (input: Object) => Promise<any>;\n\n  constructor(app) {\n    super(app);\n\n    self.addEventListener('push', e => this.onPush_(e), false);\n    self.addEventListener(\n      'pushsubscriptionchange',\n      e => this.onSubChange_(e),\n      false\n    );\n    self.addEventListener(\n      'notificationclick',\n      e => this.onNotificationClick_(e),\n      false\n    );\n\n    /**\n     * @private\n     * @type {function(Object)|null}\n     */\n    this.bgMessageHandler_ = null;\n  }\n\n  /**\n  * A handler for push events that shows notifications based on the content of\n  * the payload.\n  *\n  * The payload must be a JSON-encoded Object with a `notification` key. The\n  * value of the `notification` property will be used as the NotificationOptions\n  * object passed to showNotification. Additionally, the `title` property of the\n  * notification object will be used as the title.\n  *\n  * If there is no notification data in the payload then no notification will be\n  * shown.\n  * @private\n  */\n  onPush_(event) {\n    let msgPayload;\n    try {\n      msgPayload = event.data.json();\n    } catch (err) {\n      // Not JSON so not an FCM message\n      return;\n    }\n\n    const handleMsgPromise = this.hasVisibleClients_().then(\n      hasVisibleClients => {\n        if (hasVisibleClients) {\n          // Do not need to show a notification.\n          if (msgPayload.notification || this.bgMessageHandler_) {\n            // Send to page\n            return this.sendMessageToWindowClients_(msgPayload);\n          }\n          return;\n        }\n\n        const notificationDetails = this.getNotificationData_(msgPayload);\n        if (notificationDetails) {\n          const notificationTitle = notificationDetails.title || '';\n          return (self as any).registration.showNotification(\n            notificationTitle,\n            notificationDetails\n          );\n        } else if (this.bgMessageHandler_) {\n          return this.bgMessageHandler_(msgPayload);\n        }\n      }\n    );\n\n    event.waitUntil(handleMsgPromise);\n  }\n\n  /**\n  * @private\n  */\n  onSubChange_(event) {\n    const promiseChain = this.getToken().then(token => {\n      if (!token) {\n        // We can't resubscribe if we don't have an FCM token for this scope.\n        throw this.errorFactory_.create(\n          Errors.codes.NO_FCM_TOKEN_FOR_RESUBSCRIBE\n        );\n      }\n\n      let tokenDetails = null;\n      const tokenManager = this.getTokenManager();\n      return tokenManager\n        .getTokenDetailsFromToken(token)\n        .then(details => {\n          tokenDetails = details;\n          if (!tokenDetails) {\n            throw this.errorFactory_.create(Errors.codes.INVALID_SAVED_TOKEN);\n          }\n\n          // Attempt to get a new subscription\n          return (self as any).registration.pushManager.subscribe(\n            FCMDetails.SUBSCRIPTION_OPTIONS\n          );\n        })\n        .then(newSubscription => {\n          // Send new subscription to FCM.\n          return tokenManager.subscribeToFCM(\n            tokenDetails.fcmSenderId,\n            newSubscription,\n            tokenDetails.fcmPushSet\n          );\n        })\n        .catch(err => {\n          // The best thing we can do is log this to the terminal so\n          // developers might notice the error.\n          return tokenManager.deleteToken(tokenDetails.fcmToken).then(() => {\n            throw this.errorFactory_.create(\n              Errors.codes.UNABLE_TO_RESUBSCRIBE,\n              {\n                message: err\n              }\n            );\n          });\n        });\n    });\n\n    event.waitUntil(promiseChain);\n  }\n\n  /**\n  * @private\n  */\n  onNotificationClick_(event) {\n    if (\n      !(\n        event.notification &&\n        event.notification.data &&\n        event.notification.data[FCM_MSG]\n      )\n    ) {\n      // Not an FCM notification, do nothing.\n      return;\n    }\n\n    // Prevent other listeners from receiving the event\n    event.stopImmediatePropagation();\n\n    event.notification.close();\n\n    const msgPayload = event.notification.data[FCM_MSG];\n    const clickAction = msgPayload['notification']['click_action'];\n    if (!clickAction) {\n      // Nothing to do.\n      return;\n    }\n\n    const promiseChain = this.getWindowClient_(clickAction)\n      .then(windowClient => {\n        if (!windowClient) {\n          // Unable to find window client so need to open one.\n          return (self as any).clients.openWindow(clickAction);\n        }\n        return windowClient;\n      })\n      .then(windowClient => {\n        if (!windowClient) {\n          // Window Client will not be returned if it's for a third party origin.\n          return;\n        }\n\n        // Delete notification data from payload before sending to the page.\n        const notificationData = msgPayload['notification'];\n        delete msgPayload['notification'];\n\n        const internalMsg = WorkerPageMessage.createNewMsg(\n          WorkerPageMessage.TYPES_OF_MSG.NOTIFICATION_CLICKED,\n          msgPayload\n        );\n        // Attempt to send a message to the client to handle the data\n        // Is affected by: https://github.com/slightlyoff/ServiceWorker/issues/728\n        return this.attemptToMessageClient_(windowClient, internalMsg);\n      });\n\n    event.waitUntil(promiseChain);\n  }\n\n  /**\n   * @private\n   * @param {Object} msgPayload\n   * @return {NotificationOptions|undefined}\n   */\n  getNotificationData_(msgPayload) {\n    if (!msgPayload) {\n      return;\n    }\n\n    if (typeof msgPayload.notification !== 'object') {\n      return;\n    }\n\n    const notificationInformation = Object.assign({}, msgPayload.notification);\n    // Put the message payload under FCM_MSG name so we can identify the\n    // notification as being an FCM notification vs a notification from\n    // somewhere else (i.e. normal web push or developer generated\n    // notification).\n    notificationInformation['data'] = {\n      [FCM_MSG]: msgPayload\n    };\n\n    return notificationInformation;\n  }\n\n  /**\n   * Calling setBackgroundMessageHandler will opt in to some specific\n   * behaviours.\n   * 1.) If a notification doesn't need to be shown due to a window already\n   * being visible, then push messages will be sent to the page.\n   * 2.) If a notification needs to be shown, and the message contains no\n   * notification data this method will be called\n   * and the promise it returns will be passed to event.waitUntil.\n   * If you do not set this callback then all push messages will let and the\n   * developer can handle them in a their own 'push' event callback\n   * @export\n   * @param {function(Object)} callback The callback to be called when a push\n   * message is received and a notification must be shown. The callback will\n   * be given the data from the push message.\n   */\n  setBackgroundMessageHandler(callback) {\n    if (callback && typeof callback !== 'function') {\n      throw this.errorFactory_.create(\n        Errors.codes.BG_HANDLER_FUNCTION_EXPECTED\n      );\n    }\n\n    this.bgMessageHandler_ = callback;\n  }\n\n  /**\n   * @private\n   * @param {string} url The URL to look for when focusing a client.\n   * @return {Object} Returns an existing window client or a newly opened\n   * WindowClient.\n   */\n  getWindowClient_(url) {\n    // Use URL to normalize the URL when comparing to windowClients.\n    // This at least handles whether to include trailing slashes or not\n    const parsedURL = new URL(url).href;\n\n    return (self as any).clients\n      .matchAll({\n        type: 'window',\n        includeUncontrolled: true\n      })\n      .then(clientList => {\n        let suitableClient = null;\n        for (let i = 0; i < clientList.length; i++) {\n          const parsedClientUrl = new URL(clientList[i].url).href;\n          if (parsedClientUrl === parsedURL) {\n            suitableClient = clientList[i];\n            break;\n          }\n        }\n\n        if (suitableClient) {\n          suitableClient.focus();\n          return suitableClient;\n        }\n      });\n  }\n\n  /**\n   * This message will attempt to send the message to a window client.\n   * @private\n   * @param {Object} client The WindowClient to send the message to.\n   * @param {Object} message The message to send to the client.\n   * @returns {Promise} Returns a promise that resolves after sending the\n   * message. This does not guarantee that the message was successfully\n   * received.\n   */\n  attemptToMessageClient_(client, message) {\n    return new Promise((resolve, reject) => {\n      if (!client) {\n        return reject(\n          this.errorFactory_.create(Errors.codes.NO_WINDOW_CLIENT_TO_MSG)\n        );\n      }\n\n      client.postMessage(message);\n      resolve();\n    });\n  }\n\n  /**\n   * @private\n   * @returns {Promise<boolean>} If there is currently a visible WindowClient,\n   * this method will resolve to true, otherwise false.\n   */\n  hasVisibleClients_() {\n    return (self as any).clients\n      .matchAll({\n        type: 'window',\n        includeUncontrolled: true\n      })\n      .then(clientList => {\n        return clientList.some(client => client.visibilityState === 'visible');\n      });\n  }\n\n  /**\n   * @private\n   * @param {Object} msgPayload The data from the push event that should be sent\n   * to all available pages.\n   * @returns {Promise} Returns a promise that resolves once the message\n   * has been sent to all WindowClients.\n   */\n  sendMessageToWindowClients_(msgPayload) {\n    return (self as any).clients\n      .matchAll({\n        type: 'window',\n        includeUncontrolled: true\n      })\n      .then(clientList => {\n        const internalMsg = WorkerPageMessage.createNewMsg(\n          WorkerPageMessage.TYPES_OF_MSG.PUSH_MSG_RECEIVED,\n          msgPayload\n        );\n\n        return Promise.all(\n          clientList.map(client => {\n            return this.attemptToMessageClient_(client, internalMsg);\n          })\n        );\n      });\n  }\n\n  /**\n   * This will register the default service worker and return the registration.\n   * @private\n   * @return {Promise<!ServiceWorkerRegistration>} The service worker\n   * registration to be used for the push service.\n   */\n  getSWRegistration_() {\n    return Promise.resolve((self as any).registration);\n  }\n}\n","/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n'use strict';\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport ControllerInterface from './controller-interface';\nimport Errors from '../models/errors';\nimport WorkerPageMessage from '../models/worker-page-message';\nimport FCMDetails from '../models/fcm-details';\nvar FCM_MSG = 'FCM_MSG';\nvar SWController = (function (_super) {\n    __extends(SWController, _super);\n    function SWController(app) {\n        var _this = _super.call(this, app) || this;\n        self.addEventListener('push', function (e) { return _this.onPush_(e); }, false);\n        self.addEventListener('pushsubscriptionchange', function (e) { return _this.onSubChange_(e); }, false);\n        self.addEventListener('notificationclick', function (e) { return _this.onNotificationClick_(e); }, false);\n        /**\n         * @private\n         * @type {function(Object)|null}\n         */\n        _this.bgMessageHandler_ = null;\n        return _this;\n    }\n    /**\n    * A handler for push events that shows notifications based on the content of\n    * the payload.\n    *\n    * The payload must be a JSON-encoded Object with a `notification` key. The\n    * value of the `notification` property will be used as the NotificationOptions\n    * object passed to showNotification. Additionally, the `title` property of the\n    * notification object will be used as the title.\n    *\n    * If there is no notification data in the payload then no notification will be\n    * shown.\n    * @private\n    */\n    SWController.prototype.onPush_ = function (event) {\n        var _this = this;\n        var msgPayload;\n        try {\n            msgPayload = event.data.json();\n        }\n        catch (err) {\n            // Not JSON so not an FCM message\n            return;\n        }\n        var handleMsgPromise = this.hasVisibleClients_().then(function (hasVisibleClients) {\n            if (hasVisibleClients) {\n                // Do not need to show a notification.\n                if (msgPayload.notification || _this.bgMessageHandler_) {\n                    // Send to page\n                    return _this.sendMessageToWindowClients_(msgPayload);\n                }\n                return;\n            }\n            var notificationDetails = _this.getNotificationData_(msgPayload);\n            if (notificationDetails) {\n                var notificationTitle = notificationDetails.title || '';\n                return self.registration.showNotification(notificationTitle, notificationDetails);\n            }\n            else if (_this.bgMessageHandler_) {\n                return _this.bgMessageHandler_(msgPayload);\n            }\n        });\n        event.waitUntil(handleMsgPromise);\n    };\n    /**\n    * @private\n    */\n    SWController.prototype.onSubChange_ = function (event) {\n        var _this = this;\n        var promiseChain = this.getToken().then(function (token) {\n            if (!token) {\n                // We can't resubscribe if we don't have an FCM token for this scope.\n                throw _this.errorFactory_.create(Errors.codes.NO_FCM_TOKEN_FOR_RESUBSCRIBE);\n            }\n            var tokenDetails = null;\n            var tokenManager = _this.getTokenManager();\n            return tokenManager\n                .getTokenDetailsFromToken(token)\n                .then(function (details) {\n                tokenDetails = details;\n                if (!tokenDetails) {\n                    throw _this.errorFactory_.create(Errors.codes.INVALID_SAVED_TOKEN);\n                }\n                // Attempt to get a new subscription\n                return self.registration.pushManager.subscribe(FCMDetails.SUBSCRIPTION_OPTIONS);\n            })\n                .then(function (newSubscription) {\n                // Send new subscription to FCM.\n                return tokenManager.subscribeToFCM(tokenDetails.fcmSenderId, newSubscription, tokenDetails.fcmPushSet);\n            })\n                .catch(function (err) {\n                // The best thing we can do is log this to the terminal so\n                // developers might notice the error.\n                return tokenManager.deleteToken(tokenDetails.fcmToken).then(function () {\n                    throw _this.errorFactory_.create(Errors.codes.UNABLE_TO_RESUBSCRIBE, {\n                        message: err\n                    });\n                });\n            });\n        });\n        event.waitUntil(promiseChain);\n    };\n    /**\n    * @private\n    */\n    SWController.prototype.onNotificationClick_ = function (event) {\n        var _this = this;\n        if (!(event.notification &&\n            event.notification.data &&\n            event.notification.data[FCM_MSG])) {\n            // Not an FCM notification, do nothing.\n            return;\n        }\n        // Prevent other listeners from receiving the event\n        event.stopImmediatePropagation();\n        event.notification.close();\n        var msgPayload = event.notification.data[FCM_MSG];\n        var clickAction = msgPayload['notification']['click_action'];\n        if (!clickAction) {\n            // Nothing to do.\n            return;\n        }\n        var promiseChain = this.getWindowClient_(clickAction)\n            .then(function (windowClient) {\n            if (!windowClient) {\n                // Unable to find window client so need to open one.\n                return self.clients.openWindow(clickAction);\n            }\n            return windowClient;\n        })\n            .then(function (windowClient) {\n            if (!windowClient) {\n                // Window Client will not be returned if it's for a third party origin.\n                return;\n            }\n            // Delete notification data from payload before sending to the page.\n            var notificationData = msgPayload['notification'];\n            delete msgPayload['notification'];\n            var internalMsg = WorkerPageMessage.createNewMsg(WorkerPageMessage.TYPES_OF_MSG.NOTIFICATION_CLICKED, msgPayload);\n            // Attempt to send a message to the client to handle the data\n            // Is affected by: https://github.com/slightlyoff/ServiceWorker/issues/728\n            return _this.attemptToMessageClient_(windowClient, internalMsg);\n        });\n        event.waitUntil(promiseChain);\n    };\n    /**\n     * @private\n     * @param {Object} msgPayload\n     * @return {NotificationOptions|undefined}\n     */\n    SWController.prototype.getNotificationData_ = function (msgPayload) {\n        if (!msgPayload) {\n            return;\n        }\n        if (typeof msgPayload.notification !== 'object') {\n            return;\n        }\n        var notificationInformation = Object.assign({}, msgPayload.notification);\n        // Put the message payload under FCM_MSG name so we can identify the\n        // notification as being an FCM notification vs a notification from\n        // somewhere else (i.e. normal web push or developer generated\n        // notification).\n        notificationInformation['data'] = (_a = {},\n            _a[FCM_MSG] = msgPayload,\n            _a);\n        return notificationInformation;\n        var _a;\n    };\n    /**\n     * Calling setBackgroundMessageHandler will opt in to some specific\n     * behaviours.\n     * 1.) If a notification doesn't need to be shown due to a window already\n     * being visible, then push messages will be sent to the page.\n     * 2.) If a notification needs to be shown, and the message contains no\n     * notification data this method will be called\n     * and the promise it returns will be passed to event.waitUntil.\n     * If you do not set this callback then all push messages will let and the\n     * developer can handle them in a their own 'push' event callback\n     * @export\n     * @param {function(Object)} callback The callback to be called when a push\n     * message is received and a notification must be shown. The callback will\n     * be given the data from the push message.\n     */\n    SWController.prototype.setBackgroundMessageHandler = function (callback) {\n        if (callback && typeof callback !== 'function') {\n            throw this.errorFactory_.create(Errors.codes.BG_HANDLER_FUNCTION_EXPECTED);\n        }\n        this.bgMessageHandler_ = callback;\n    };\n    /**\n     * @private\n     * @param {string} url The URL to look for when focusing a client.\n     * @return {Object} Returns an existing window client or a newly opened\n     * WindowClient.\n     */\n    SWController.prototype.getWindowClient_ = function (url) {\n        // Use URL to normalize the URL when comparing to windowClients.\n        // This at least handles whether to include trailing slashes or not\n        var parsedURL = new URL(url).href;\n        return self.clients\n            .matchAll({\n            type: 'window',\n            includeUncontrolled: true\n        })\n            .then(function (clientList) {\n            var suitableClient = null;\n            for (var i = 0; i < clientList.length; i++) {\n                var parsedClientUrl = new URL(clientList[i].url).href;\n                if (parsedClientUrl === parsedURL) {\n                    suitableClient = clientList[i];\n                    break;\n                }\n            }\n            if (suitableClient) {\n                suitableClient.focus();\n                return suitableClient;\n            }\n        });\n    };\n    /**\n     * This message will attempt to send the message to a window client.\n     * @private\n     * @param {Object} client The WindowClient to send the message to.\n     * @param {Object} message The message to send to the client.\n     * @returns {Promise} Returns a promise that resolves after sending the\n     * message. This does not guarantee that the message was successfully\n     * received.\n     */\n    SWController.prototype.attemptToMessageClient_ = function (client, message) {\n        var _this = this;\n        return new Promise(function (resolve, reject) {\n            if (!client) {\n                return reject(_this.errorFactory_.create(Errors.codes.NO_WINDOW_CLIENT_TO_MSG));\n            }\n            client.postMessage(message);\n            resolve();\n        });\n    };\n    /**\n     * @private\n     * @returns {Promise<boolean>} If there is currently a visible WindowClient,\n     * this method will resolve to true, otherwise false.\n     */\n    SWController.prototype.hasVisibleClients_ = function () {\n        return self.clients\n            .matchAll({\n            type: 'window',\n            includeUncontrolled: true\n        })\n            .then(function (clientList) {\n            return clientList.some(function (client) { return client.visibilityState === 'visible'; });\n        });\n    };\n    /**\n     * @private\n     * @param {Object} msgPayload The data from the push event that should be sent\n     * to all available pages.\n     * @returns {Promise} Returns a promise that resolves once the message\n     * has been sent to all WindowClients.\n     */\n    SWController.prototype.sendMessageToWindowClients_ = function (msgPayload) {\n        var _this = this;\n        return self.clients\n            .matchAll({\n            type: 'window',\n            includeUncontrolled: true\n        })\n            .then(function (clientList) {\n            var internalMsg = WorkerPageMessage.createNewMsg(WorkerPageMessage.TYPES_OF_MSG.PUSH_MSG_RECEIVED, msgPayload);\n            return Promise.all(clientList.map(function (client) {\n                return _this.attemptToMessageClient_(client, internalMsg);\n            }));\n        });\n    };\n    /**\n     * This will register the default service worker and return the registration.\n     * @private\n     * @return {Promise<!ServiceWorkerRegistration>} The service worker\n     * registration to be used for the push service.\n     */\n    SWController.prototype.getSWRegistration_ = function () {\n        return Promise.resolve(self.registration);\n    };\n    return SWController;\n}(ControllerInterface));\nexport default SWController;\n\n\n"]}