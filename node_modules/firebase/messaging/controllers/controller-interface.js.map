{"version":3,"sources":["src/messaging/controllers/controller-interface.ts","messaging/controllers/controller-interface.js"],"names":["SENDER_ID_OPTION_NAME","ControllerInterface","app","_this","errorFactory_","map","options","create","codes","BAD_SENDER_ID","messagingSenderId_","tokenManager_","INTERNAL","delete","prototype","getToken","currentPermission","getNotificationPermission_","granted","denied","Promise","reject","NOTIFICATIONS_BLOCKED","resolve","getSWRegistration_","then","registration","getSavedToken","token","createToken","deleteToken","pushManager","getSubscription","subscription","unsubscribe","SHOULD_BE_INHERITED","requestPermission","AVAILABLE_IN_WINDOW","useServiceWorker","onMessage","nextOrObserver","optError","optCompleted","onTokenRefresh","setBackgroundMessageHandler","callback","AVAILABLE_IN_SW","closeDatabase","Notification","permission","getTokenManager"],"mappings":"AAAA;;;;;;;;;;;;;;;AAeA;;;;;;AAEA;;AACA;;;;AACA;;;;AACA;;;;;;AAEA,IAAMA,wBAAwB,mBAA9B;AAEA,IAAAC,sBAAA,YAAA;AAOE;;;;AAIA,aAAAA,mBAAA,CAAYC,GAAZ,EAAe;AAAf,YAAAC,QAAA,IAAA;AACE,aAAKC,aAAL,GAAqB,yBAAiB,WAAjB,EAA8B,WAA9B,EAA2C,iBAAOC,GAAlD,CAArB;AAEA,YACE,CAACH,IAAII,OAAJ,CAAYN,qBAAZ,CAAD,IACA,OAAOE,IAAII,OAAJ,CAAYN,qBAAZ,CAAP,KAA8C,QAFhD,EAGE;AACA,kBAAM,KAAKI,aAAL,CAAmBG,MAAnB,CAA0B,iBAAOC,KAAP,CAAaC,aAAvC,CAAN;AACD;AAED,aAAKC,kBAAL,GAA0BR,IAAII,OAAJ,CAAYN,qBAAZ,CAA1B;AAEA,aAAKW,aAAL,GAAqB,4BAArB;AAEA,aAAKT,GAAL,GAAWA,GAAX;AACA,aAAKU,QAAL,GAAgB,EAAhB;AACA,aAAKA,QAAL,CAAcC,MAAd,GAAuB,YAAA;AAAM,mBAAAV,MAAKU,MAAL;AAAW,SAAxC;AACD;AAED;;;;;AAKAZ,wBAAAa,SAAA,CAAAC,QAAA,GAAA,YAAA;AAAA,YAAAZ,QAAA,IAAA;AACE;AACA,YAAMa,oBAAoB,KAAKC,0BAAL,EAA1B;AACA,YAAID,sBAAsB,iCAAwBE,OAAlD,EAA2D;AACzD,gBAAIF,sBAAsB,iCAAwBG,MAAlD,EAA0D;AACxD,uBAAOC,QAAQC,MAAR,CACL,KAAKjB,aAAL,CAAmBG,MAAnB,CAA0B,iBAAOC,KAAP,CAAac,qBAAvC,CADK,CAAP;AAGD;AAED;AACA,mBAAOF,QAAQG,OAAR,CAAgB,IAAhB,CAAP;AACD;AAED,eAAO,KAAKC,kBAAL,GAA0BC,IAA1B,CAA+B,UAAAC,YAAA,EAAY;AAChD,mBAAOvB,MAAKQ,aAAL,CACJgB,aADI,CACUxB,MAAKO,kBADf,EACmCgB,YADnC,EAEJD,IAFI,CAEC,UAAAG,KAAA,EAAK;AACT,oBAAIA,KAAJ,EAAW;AACT,2BAAOA,KAAP;AACD;AAED,uBAAOzB,MAAKQ,aAAL,CAAmBkB,WAAnB,CACL1B,MAAKO,kBADA,EAELgB,YAFK,CAAP;AAID,aAXI,CAAP;AAYD,SAbM,CAAP;AAcD,KA5BD;AA8BA;;;;;;;AAOAzB,wBAAAa,SAAA,CAAAgB,WAAA,GAAA,UAAYF,KAAZ,EAAiB;AAAjB,YAAAzB,QAAA,IAAA;AACE,eAAO,KAAKQ,aAAL,CAAmBmB,WAAnB,CAA+BF,KAA/B,EAAsCH,IAAtC,CAA2C,YAAA;AAChD,mBAAOtB,MAAKqB,kBAAL,GACJC,IADI,CACC,UAAAC,YAAA,EAAY;AAChB,oBAAIA,YAAJ,EAAkB;AAChB,2BAAOA,aAAaK,WAAb,CAAyBC,eAAzB,EAAP;AACD;AACF,aALI,EAMJP,IANI,CAMC,UAAAQ,YAAA,EAAY;AAChB,oBAAIA,YAAJ,EAAkB;AAChB,2BAAOA,aAAaC,WAAb,EAAP;AACD;AACF,aAVI,CAAP;AAWD,SAZM,CAAP;AAaD,KAdD;AAgBAjC,wBAAAa,SAAA,CAAAU,kBAAA,GAAA,YAAA;AACE,cAAM,KAAKpB,aAAL,CAAmBG,MAAnB,CAA0B,iBAAOC,KAAP,CAAa2B,mBAAvC,CAAN;AACD,KAFD;AAIA;AACA;AACA;AAEAlC,wBAAAa,SAAA,CAAAsB,iBAAA,GAAA,YAAA;AACE,cAAM,KAAKhC,aAAL,CAAmBG,MAAnB,CAA0B,iBAAOC,KAAP,CAAa6B,mBAAvC,CAAN;AACD,KAFD;AAIA;;;;AAIApC,wBAAAa,SAAA,CAAAwB,gBAAA,GAAA,UAAiBZ,YAAjB,EAA6B;AAC3B,cAAM,KAAKtB,aAAL,CAAmBG,MAAnB,CAA0B,iBAAOC,KAAP,CAAa6B,mBAAvC,CAAN;AACD,KAFD;AAIA;;;;;;;AAOApC,wBAAAa,SAAA,CAAAyB,SAAA,GAAA,UAAUC,cAAV,EAA0BC,QAA1B,EAAoCC,YAApC,EAAgD;AAC9C,cAAM,KAAKtC,aAAL,CAAmBG,MAAnB,CAA0B,iBAAOC,KAAP,CAAa6B,mBAAvC,CAAN;AACD,KAFD;AAIA;;;;;;;;;;AAUApC,wBAAAa,SAAA,CAAA6B,cAAA,GAAA,UAAeH,cAAf,EAA+BC,QAA/B,EAAyCC,YAAzC,EAAqD;AACnD,cAAM,KAAKtC,aAAL,CAAmBG,MAAnB,CAA0B,iBAAOC,KAAP,CAAa6B,mBAAvC,CAAN;AACD,KAFD;AAIA;AACA;AACA;AAEA;;;;AAIApC,wBAAAa,SAAA,CAAA8B,2BAAA,GAAA,UAA4BC,QAA5B,EAAoC;AAClC,cAAM,KAAKzC,aAAL,CAAmBG,MAAnB,CAA0B,iBAAOC,KAAP,CAAasC,eAAvC,CAAN;AACD,KAFD;AAIA;AACA;AACA;AACA;AAEA;;;;AAIA7C,wBAAAa,SAAA,CAAAD,MAAA,GAAA,YAAA;AACE,aAAKF,aAAL,CAAmBoC,aAAnB;AACD,KAFD;AAIA;;;;;AAKA9C,wBAAAa,SAAA,CAAAG,0BAAA,GAAA,YAAA;AACE,eAAQ+B,aAAqBC,UAA7B;AACD,KAFD;AAIA;;;;AAIAhD,wBAAAa,SAAA,CAAAoC,eAAA,GAAA,YAAA;AACE,eAAO,KAAKvC,aAAZ;AACD,KAFD;AAGF,WAAAV,mBAAA;AA9KA,CAAA,EAAA;kBC8IeA,mB","file":"controller-interface.js","sourcesContent":["/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n'use strict';\n\nimport { ErrorFactory } from '../../app/errors';\nimport Errors from '../models/errors';\nimport TokenManager from '../models/token-manager';\nimport NOTIFICATION_PERMISSION from '../models/notification-permission';\n\nconst SENDER_ID_OPTION_NAME = 'messagingSenderId';\n\nexport default class ControllerInterface {\n  public app;\n  public INTERNAL;\n  protected errorFactory_;\n  private messagingSenderId_: string;\n  private tokenManager_: TokenManager;\n\n  /**\n   * An interface of the Messaging Service API\n   * @param {!firebase.app.App} app\n   */\n  constructor(app) {\n    this.errorFactory_ = new ErrorFactory('messaging', 'Messaging', Errors.map);\n\n    if (\n      !app.options[SENDER_ID_OPTION_NAME] ||\n      typeof app.options[SENDER_ID_OPTION_NAME] !== 'string'\n    ) {\n      throw this.errorFactory_.create(Errors.codes.BAD_SENDER_ID);\n    }\n\n    this.messagingSenderId_ = app.options[SENDER_ID_OPTION_NAME];\n\n    this.tokenManager_ = new TokenManager();\n\n    this.app = app;\n    this.INTERNAL = {};\n    this.INTERNAL.delete = () => this.delete;\n  }\n\n  /**\n   * @export\n   * @return {Promise<string> | Promise<null>} Returns a promise that\n   * resolves to an FCM token.\n   */\n  getToken() {\n    // Check with permissions\n    const currentPermission = this.getNotificationPermission_();\n    if (currentPermission !== NOTIFICATION_PERMISSION.granted) {\n      if (currentPermission === NOTIFICATION_PERMISSION.denied) {\n        return Promise.reject(\n          this.errorFactory_.create(Errors.codes.NOTIFICATIONS_BLOCKED)\n        );\n      }\n\n      // We must wait for permission to be granted\n      return Promise.resolve(null);\n    }\n\n    return this.getSWRegistration_().then(registration => {\n      return this.tokenManager_\n        .getSavedToken(this.messagingSenderId_, registration)\n        .then(token => {\n          if (token) {\n            return token;\n          }\n\n          return this.tokenManager_.createToken(\n            this.messagingSenderId_,\n            registration\n          );\n        });\n    });\n  }\n\n  /**\n   * This method deletes tokens that the token manager looks after and then\n   * unregisters the push subscription if it exists.\n   * @export\n   * @param {string} token\n   * @return {Promise<void>}\n   */\n  deleteToken(token) {\n    return this.tokenManager_.deleteToken(token).then(() => {\n      return this.getSWRegistration_()\n        .then(registration => {\n          if (registration) {\n            return registration.pushManager.getSubscription();\n          }\n        })\n        .then(subscription => {\n          if (subscription) {\n            return subscription.unsubscribe();\n          }\n        });\n    });\n  }\n\n  getSWRegistration_(): Promise<ServiceWorkerRegistration> {\n    throw this.errorFactory_.create(Errors.codes.SHOULD_BE_INHERITED);\n  }\n\n  //\n  // The following methods should only be available in the window.\n  //\n\n  requestPermission() {\n    throw this.errorFactory_.create(Errors.codes.AVAILABLE_IN_WINDOW);\n  }\n\n  /**\n   * @export\n   * @param {!ServiceWorkerRegistration} registration\n   */\n  useServiceWorker(registration) {\n    throw this.errorFactory_.create(Errors.codes.AVAILABLE_IN_WINDOW);\n  }\n\n  /**\n   * @export\n   * @param {!firebase.Observer|function(*)} nextOrObserver\n   * @param {function(!Error)=} optError\n   * @param {function()=} optCompleted\n   * @return {!function()}\n   */\n  onMessage(nextOrObserver, optError, optCompleted) {\n    throw this.errorFactory_.create(Errors.codes.AVAILABLE_IN_WINDOW);\n  }\n\n  /**\n   * @export\n   * @param {!firebase.Observer|function()} nextOrObserver An observer object\n   * or a function triggered on token refresh.\n   * @param {function(!Error)=} optError Optional A function\n   * triggered on token refresh error.\n   * @param {function()=} optCompleted Optional function triggered when the\n   * observer is removed.\n   * @return {!function()} The unsubscribe function for the observer.\n   */\n  onTokenRefresh(nextOrObserver, optError, optCompleted) {\n    throw this.errorFactory_.create(Errors.codes.AVAILABLE_IN_WINDOW);\n  }\n\n  //\n  // The following methods are used by the service worker only.\n  //\n\n  /**\n   * @export\n   * @param {function(Object)} callback\n   */\n  setBackgroundMessageHandler(callback) {\n    throw this.errorFactory_.create(Errors.codes.AVAILABLE_IN_SW);\n  }\n\n  //\n  // The following methods are used by the service themselves and not exposed\n  // publicly or not expected to be used by developers.\n  //\n\n  /**\n   * This method is required to adhere to the Firebase interface.\n   * It closes any currently open indexdb database connections.\n   */\n  delete() {\n    this.tokenManager_.closeDatabase();\n  }\n\n  /**\n   * Returns the current Notification Permission state.\n   * @private\n   * @return {string} The currenct permission state.\n   */\n  getNotificationPermission_() {\n    return (Notification as any).permission;\n  }\n\n  /**\n   * @protected\n   * @returns {TokenManager}\n   */\n  getTokenManager() {\n    return this.tokenManager_;\n  }\n}\n","/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n'use strict';\nimport { ErrorFactory } from '../../app/errors';\nimport Errors from '../models/errors';\nimport TokenManager from '../models/token-manager';\nimport NOTIFICATION_PERMISSION from '../models/notification-permission';\nvar SENDER_ID_OPTION_NAME = 'messagingSenderId';\nvar ControllerInterface = (function () {\n    /**\n     * An interface of the Messaging Service API\n     * @param {!firebase.app.App} app\n     */\n    function ControllerInterface(app) {\n        var _this = this;\n        this.errorFactory_ = new ErrorFactory('messaging', 'Messaging', Errors.map);\n        if (!app.options[SENDER_ID_OPTION_NAME] ||\n            typeof app.options[SENDER_ID_OPTION_NAME] !== 'string') {\n            throw this.errorFactory_.create(Errors.codes.BAD_SENDER_ID);\n        }\n        this.messagingSenderId_ = app.options[SENDER_ID_OPTION_NAME];\n        this.tokenManager_ = new TokenManager();\n        this.app = app;\n        this.INTERNAL = {};\n        this.INTERNAL.delete = function () { return _this.delete; };\n    }\n    /**\n     * @export\n     * @return {Promise<string> | Promise<null>} Returns a promise that\n     * resolves to an FCM token.\n     */\n    ControllerInterface.prototype.getToken = function () {\n        var _this = this;\n        // Check with permissions\n        var currentPermission = this.getNotificationPermission_();\n        if (currentPermission !== NOTIFICATION_PERMISSION.granted) {\n            if (currentPermission === NOTIFICATION_PERMISSION.denied) {\n                return Promise.reject(this.errorFactory_.create(Errors.codes.NOTIFICATIONS_BLOCKED));\n            }\n            // We must wait for permission to be granted\n            return Promise.resolve(null);\n        }\n        return this.getSWRegistration_().then(function (registration) {\n            return _this.tokenManager_\n                .getSavedToken(_this.messagingSenderId_, registration)\n                .then(function (token) {\n                if (token) {\n                    return token;\n                }\n                return _this.tokenManager_.createToken(_this.messagingSenderId_, registration);\n            });\n        });\n    };\n    /**\n     * This method deletes tokens that the token manager looks after and then\n     * unregisters the push subscription if it exists.\n     * @export\n     * @param {string} token\n     * @return {Promise<void>}\n     */\n    ControllerInterface.prototype.deleteToken = function (token) {\n        var _this = this;\n        return this.tokenManager_.deleteToken(token).then(function () {\n            return _this.getSWRegistration_()\n                .then(function (registration) {\n                if (registration) {\n                    return registration.pushManager.getSubscription();\n                }\n            })\n                .then(function (subscription) {\n                if (subscription) {\n                    return subscription.unsubscribe();\n                }\n            });\n        });\n    };\n    ControllerInterface.prototype.getSWRegistration_ = function () {\n        throw this.errorFactory_.create(Errors.codes.SHOULD_BE_INHERITED);\n    };\n    //\n    // The following methods should only be available in the window.\n    //\n    ControllerInterface.prototype.requestPermission = function () {\n        throw this.errorFactory_.create(Errors.codes.AVAILABLE_IN_WINDOW);\n    };\n    /**\n     * @export\n     * @param {!ServiceWorkerRegistration} registration\n     */\n    ControllerInterface.prototype.useServiceWorker = function (registration) {\n        throw this.errorFactory_.create(Errors.codes.AVAILABLE_IN_WINDOW);\n    };\n    /**\n     * @export\n     * @param {!firebase.Observer|function(*)} nextOrObserver\n     * @param {function(!Error)=} optError\n     * @param {function()=} optCompleted\n     * @return {!function()}\n     */\n    ControllerInterface.prototype.onMessage = function (nextOrObserver, optError, optCompleted) {\n        throw this.errorFactory_.create(Errors.codes.AVAILABLE_IN_WINDOW);\n    };\n    /**\n     * @export\n     * @param {!firebase.Observer|function()} nextOrObserver An observer object\n     * or a function triggered on token refresh.\n     * @param {function(!Error)=} optError Optional A function\n     * triggered on token refresh error.\n     * @param {function()=} optCompleted Optional function triggered when the\n     * observer is removed.\n     * @return {!function()} The unsubscribe function for the observer.\n     */\n    ControllerInterface.prototype.onTokenRefresh = function (nextOrObserver, optError, optCompleted) {\n        throw this.errorFactory_.create(Errors.codes.AVAILABLE_IN_WINDOW);\n    };\n    //\n    // The following methods are used by the service worker only.\n    //\n    /**\n     * @export\n     * @param {function(Object)} callback\n     */\n    ControllerInterface.prototype.setBackgroundMessageHandler = function (callback) {\n        throw this.errorFactory_.create(Errors.codes.AVAILABLE_IN_SW);\n    };\n    //\n    // The following methods are used by the service themselves and not exposed\n    // publicly or not expected to be used by developers.\n    //\n    /**\n     * This method is required to adhere to the Firebase interface.\n     * It closes any currently open indexdb database connections.\n     */\n    ControllerInterface.prototype.delete = function () {\n        this.tokenManager_.closeDatabase();\n    };\n    /**\n     * Returns the current Notification Permission state.\n     * @private\n     * @return {string} The currenct permission state.\n     */\n    ControllerInterface.prototype.getNotificationPermission_ = function () {\n        return Notification.permission;\n    };\n    /**\n     * @protected\n     * @returns {TokenManager}\n     */\n    ControllerInterface.prototype.getTokenManager = function () {\n        return this.tokenManager_;\n    };\n    return ControllerInterface;\n}());\nexport default ControllerInterface;\n\n\n"]}