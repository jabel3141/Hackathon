{"version":3,"sources":["src/messaging/models/token-manager.ts","messaging/models/token-manager.js"],"names":["FCM_TOKEN_DETAILS_DB","FCM_TOKEN_OBJ_STORE","FCM_TOKEN_DETAILS_DB_VERSION","TokenManager","errorFactory_","map","openDbPromise_","prototype","openDatabase_","Promise","resolve","reject","request","indexedDB","open","onerror","event","target","error","onsuccess","result","onupgradeneeded","db","objectStore","createObjectStore","keyPath","createIndex","unique","closeDatabase","_this","then","close","getTokenDetailsFromToken","fcmToken","transaction","index","get","getTokenDetailsFromSWScope_","swScope","scopeRequest","getAllTokenDetailsForSenderId_","senderId","senderIdTokens","cursorRequest","openCursor","cursor","value","push","continue","subscribeToFCM","subscription","pushSet","p256dh","auth","fcmSubscribeBody","endpoint","headers","Headers","append","subscribeOptions","method","body","fetch","ENDPOINT","response","json","fcmTokenResponse","message","create","codes","TOKEN_SUBSCRIBE_FAILED","TOKEN_SUBSCRIBE_NO_TOKEN","TOKEN_SUBSCRIBE_NO_PUSH_SET","token","isSameSubscription_","masterTokenDetails","saveTokenDetails_","swRegistration","fcmPushSet","details","scope","fcmSenderId","put","getSavedToken","ServiceWorkerRegistration","SW_REGISTRATION_EXPECTED","length","BAD_SENDER_ID","allTokenDetails","findIndex","tokenDetails","pushManager","getSubscription","catch","err","GET_SUBSCRIPTION_FAILED","createToken","fcmTokenDetails","subscribe","SUBSCRIPTION_OPTIONS","sub","deleteToken","INVALID_DELETE_TOKEN","DELETE_TOKEN_NOT_FOUND","delete","FAILED_TO_DELETE_TOKEN"],"mappings":"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","file":"token-manager.js","sourcesContent":["/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n'use strict';\n\nimport { ErrorFactory } from '../../app/errors';\n\nimport Errors from './errors';\nimport arrayBufferToBase64 from '../helpers/array-buffer-to-base64';\nimport FCMDetails from './fcm-details';\n\nconst FCM_TOKEN_DETAILS_DB = 'fcm_token_details_db';\nconst FCM_TOKEN_OBJ_STORE = 'fcm_token_object_Store';\nconst FCM_TOKEN_DETAILS_DB_VERSION = 1;\n\nexport default class TokenManager {\n  private errorFactory_: ErrorFactory<string>;\n  private openDbPromise_: Promise<IDBDatabase>;\n\n  constructor() {\n    this.errorFactory_ = new ErrorFactory('messaging', 'Messaging', Errors.map);\n    this.openDbPromise_ = null;\n  }\n\n  /**\n   * Get the indexedDB as a promsie.\n   * @private\n   * @return {Promise<IDBDatabase>} The IndexedDB database\n   */\n  openDatabase_() {\n    if (this.openDbPromise_) {\n      return this.openDbPromise_;\n    }\n\n    this.openDbPromise_ = new Promise((resolve, reject) => {\n      const request = indexedDB.open(\n        FCM_TOKEN_DETAILS_DB,\n        FCM_TOKEN_DETAILS_DB_VERSION\n      );\n      request.onerror = event => {\n        reject((<IDBRequest>event.target).error);\n      };\n      request.onsuccess = event => {\n        resolve((<IDBRequest>event.target).result);\n      };\n      request.onupgradeneeded = event => {\n        var db = (<IDBRequest>event.target).result;\n\n        var objectStore = db.createObjectStore(FCM_TOKEN_OBJ_STORE, {\n          keyPath: 'swScope'\n        });\n\n        // Make sure the sender ID can be searched\n        objectStore.createIndex('fcmSenderId', 'fcmSenderId', {\n          unique: false\n        });\n\n        objectStore.createIndex('fcmToken', 'fcmToken', {\n          unique: true\n        });\n      };\n    });\n\n    return this.openDbPromise_;\n  }\n\n  /**\n   * Close the currently open database.\n   * @return {Promise<?>} Returns the result of the promise chain.\n   */\n  closeDatabase() {\n    if (this.openDbPromise_) {\n      return this.openDbPromise_.then(db => {\n        db.close();\n        this.openDbPromise_ = null;\n      });\n    }\n\n    return Promise.resolve();\n  }\n\n  /**\n   * Given a token, this method will look up the details in indexedDB.\n   * @public\n   * @param {string} fcmToken\n   * @return {Promise<Object>} The details associated with that token.\n   */\n  getTokenDetailsFromToken(fcmToken) {\n    return this.openDatabase_().then(db => {\n      return new Promise((resolve, reject) => {\n        const transaction = db.transaction([FCM_TOKEN_OBJ_STORE]);\n        const objectStore = transaction.objectStore(FCM_TOKEN_OBJ_STORE);\n        const index = objectStore.index('fcmToken');\n        const request = index.get(fcmToken);\n        request.onerror = function(event) {\n          reject((<IDBRequest>event.target).error);\n        };\n        request.onsuccess = function(event) {\n          resolve((<IDBRequest>event.target).result);\n        };\n      });\n    });\n  }\n\n  getTokenDetailsFromSWScope_(swScope) {\n    return this.openDatabase_().then(db => {\n      return new Promise((resolve, reject) => {\n        const transaction = db.transaction([FCM_TOKEN_OBJ_STORE]);\n        const objectStore = transaction.objectStore(FCM_TOKEN_OBJ_STORE);\n        const scopeRequest = objectStore.get(swScope);\n        scopeRequest.onerror = event => {\n          reject((<IDBRequest>event.target).error);\n        };\n\n        scopeRequest.onsuccess = event => {\n          resolve((<IDBRequest>event.target).result);\n        };\n      });\n    });\n  }\n\n  getAllTokenDetailsForSenderId_(senderId): Promise<Array<Object>> {\n    return this.openDatabase_().then(db => {\n      return new Promise<Array<Object>>((resolve, reject) => {\n        const transaction = db.transaction([FCM_TOKEN_OBJ_STORE]);\n        const objectStore = transaction.objectStore(FCM_TOKEN_OBJ_STORE);\n\n        const senderIdTokens = [];\n\n        const cursorRequest = objectStore.openCursor();\n        cursorRequest.onerror = event => {\n          reject((<IDBRequest>event.target).error);\n        };\n\n        cursorRequest.onsuccess = event => {\n          const cursor = (<IDBRequest>event.target).result;\n          if (cursor) {\n            if (cursor.value['fcmSenderId'] === senderId) {\n              senderIdTokens.push(cursor.value);\n            }\n            cursor.continue();\n          } else {\n            resolve(senderIdTokens);\n          }\n        };\n      });\n    });\n  }\n\n  /**\n   * Given a PushSubscription and messagingSenderId, get an FCM token.\n   * @public\n   * @param  {string} senderId The 'messagingSenderId' to tie the token to.\n   * @param  {PushSubscription} subscription The PushSusbcription to \"federate\".\n   * @param  {string=} pushSet If defined this will swap the subscription for\n   * matching FCM token.\n   * @return {Promise<!Object>} Returns the FCM token to be used in place\n   * of the PushSubscription.\n   */\n  subscribeToFCM(senderId, subscription, pushSet?): Promise<Object> {\n    const p256dh = arrayBufferToBase64(subscription['getKey']('p256dh'));\n    const auth = arrayBufferToBase64(subscription['getKey']('auth'));\n\n    let fcmSubscribeBody =\n      `authorized_entity=${senderId}&` +\n      `endpoint=${subscription.endpoint}&` +\n      `encryption_key=${p256dh}&` +\n      `encryption_auth=${auth}`;\n\n    if (pushSet) {\n      fcmSubscribeBody += `&pushSet=${pushSet}`;\n    }\n\n    const headers = new Headers();\n    headers.append('Content-Type', 'application/x-www-form-urlencoded');\n\n    const subscribeOptions = {\n      method: 'POST',\n      headers: headers,\n      body: fcmSubscribeBody\n    };\n\n    return fetch(\n      FCMDetails.ENDPOINT + '/fcm/connect/subscribe',\n      subscribeOptions\n    )\n      .then(response => response.json())\n      .then(response => {\n        const fcmTokenResponse = response;\n        if (fcmTokenResponse['error']) {\n          const message = fcmTokenResponse['error']['message'];\n          throw this.errorFactory_.create(Errors.codes.TOKEN_SUBSCRIBE_FAILED, {\n            message: message\n          });\n        }\n\n        if (!fcmTokenResponse['token']) {\n          throw this.errorFactory_.create(\n            Errors.codes.TOKEN_SUBSCRIBE_NO_TOKEN\n          );\n        }\n\n        if (!fcmTokenResponse['pushSet']) {\n          throw this.errorFactory_.create(\n            Errors.codes.TOKEN_SUBSCRIBE_NO_PUSH_SET\n          );\n        }\n\n        return {\n          token: fcmTokenResponse['token'],\n          pushSet: fcmTokenResponse['pushSet']\n        };\n      });\n  }\n\n  /**\n   * Checks the that fields in the PushSubscription are equivalent to the\n   * details stores in the masterTokenDetails.\n   * @private\n   * @param  {PushSubscription} subscription The push subscription we expect\n   * the master token to match.\n   * @param  {Object}  masterTokenDetails The saved details we wish to compare\n   * with the PushSubscription\n   * @return {boolean} true if the subscription and token details are\n   * equivalent.\n   */\n  isSameSubscription_(subscription, masterTokenDetails) {\n    // getKey() isn't defined in the PushSubscription externs file, hence\n    // subscription['getKey']('<key name>').\n    return (\n      subscription.endpoint === masterTokenDetails['endpoint'] &&\n      arrayBufferToBase64(subscription['getKey']('auth')) ===\n        masterTokenDetails['auth'] &&\n      arrayBufferToBase64(subscription['getKey']('p256dh')) ===\n        masterTokenDetails['p256dh']\n    );\n  }\n\n  /**\n   * Save the details for the fcm token for re-use at a later date.\n   * @private\n   * @param  {string} senderId The 'messagingSenderId' used for this project\n   * @param  {ServiceWorkerRegistration} swRegistration The service worker\n   * used to subscribe the user for web push\n   * @param  {PushSubscription} subscription The push subscription passed to\n   * FCM for the current token.\n   * @param  {string} fcmToken The FCM token currently used on this\n   * device.\n   * @param  {string} fcmPushSet The FCM push tied to the fcm token.\n   * @return {Promise<void>}\n   */\n  saveTokenDetails_(\n    senderId,\n    swRegistration,\n    subscription,\n    fcmToken,\n    fcmPushSet\n  ) {\n    const details = {\n      swScope: swRegistration.scope,\n      endpoint: subscription.endpoint,\n      auth: arrayBufferToBase64(subscription['getKey']('auth')),\n      p256dh: arrayBufferToBase64(subscription['getKey']('p256dh')),\n      fcmToken: fcmToken,\n      fcmPushSet: fcmPushSet,\n      fcmSenderId: senderId\n    };\n\n    return this.openDatabase_().then(db => {\n      return new Promise((resolve, reject) => {\n        const transaction = db.transaction([FCM_TOKEN_OBJ_STORE], 'readwrite');\n        const objectStore = transaction.objectStore(FCM_TOKEN_OBJ_STORE);\n        const request = objectStore.put(details);\n        request.onerror = event => {\n          reject((<IDBRequest>event.target).error);\n        };\n        request.onsuccess = event => {\n          resolve();\n        };\n      });\n    });\n  }\n\n  /**\n   * Returns the saved FCM Token if one is available and still valid,\n   * otherwise `null` is returned.\n   * @param {string} senderId This should be the sender ID associated with the\n   * FCM Token being retrieved.\n   * @param {ServiceWorkerRegistration} swRegistration Registration to be used\n   * to subscribe the user to push.\n   * @return {Promise<string> | Promise} Returns the saved FCM Token if\n   * avilable and valid.\n   * @export\n   */\n  getSavedToken(senderId, swRegistration) {\n    if (!(swRegistration instanceof ServiceWorkerRegistration)) {\n      return Promise.reject(\n        this.errorFactory_.create(Errors.codes.SW_REGISTRATION_EXPECTED)\n      );\n    }\n\n    if (typeof senderId !== 'string' || senderId.length === 0) {\n      return Promise.reject(\n        this.errorFactory_.create(Errors.codes.BAD_SENDER_ID)\n      );\n    }\n\n    return this.getAllTokenDetailsForSenderId_(senderId)\n      .then(allTokenDetails => {\n        if (allTokenDetails.length === 0) {\n          return;\n        }\n\n        const index = allTokenDetails.findIndex(tokenDetails => {\n          return (\n            swRegistration.scope === tokenDetails['swScope'] &&\n            senderId === tokenDetails['fcmSenderId']\n          );\n        });\n\n        if (index === -1) {\n          return;\n        }\n\n        return allTokenDetails[index];\n      })\n      .then(tokenDetails => {\n        if (!tokenDetails) {\n          return;\n        }\n\n        return swRegistration.pushManager\n          .getSubscription()\n          .catch(err => {\n            throw this.errorFactory_.create(\n              Errors.codes.GET_SUBSCRIPTION_FAILED\n            );\n          })\n          .then(subscription => {\n            if (\n              subscription &&\n              this.isSameSubscription_(subscription, tokenDetails)\n            ) {\n              return tokenDetails['fcmToken'];\n            }\n          });\n      });\n  }\n\n  /**\n   * Creates a new FCM token.\n   */\n  createToken(senderId, swRegistration): Promise<String> {\n    if (typeof senderId !== 'string' || senderId.length === 0) {\n      return Promise.reject(\n        this.errorFactory_.create(Errors.codes.BAD_SENDER_ID)\n      );\n    }\n\n    if (!(swRegistration instanceof ServiceWorkerRegistration)) {\n      return Promise.reject(\n        this.errorFactory_.create(Errors.codes.SW_REGISTRATION_EXPECTED)\n      );\n    }\n\n    // Check for existing subscription first\n    let subscription;\n    let fcmTokenDetails;\n    return swRegistration.pushManager\n      .getSubscription()\n      .then(subscription => {\n        if (subscription) {\n          return subscription;\n        }\n\n        return swRegistration.pushManager.subscribe(\n          FCMDetails.SUBSCRIPTION_OPTIONS\n        );\n      })\n      .then(sub => {\n        subscription = sub;\n        return this.subscribeToFCM(senderId, subscription);\n      })\n      .then(tokenDetails => {\n        fcmTokenDetails = tokenDetails;\n        return this.saveTokenDetails_(\n          senderId,\n          swRegistration,\n          subscription,\n          fcmTokenDetails['token'],\n          fcmTokenDetails['pushSet']\n        );\n      })\n      .then(() => fcmTokenDetails['token']);\n  }\n\n  /**\n   * This method deletes details of the current FCM token.\n   * It's returning a promise in case we need to move to an async\n   * method for deleting at a later date.\n   * @param {string} token Token to be deleted\n   * @return {Promise<Object>} Resolves once the FCM token details have been\n   * deleted and returns the deleted details.\n   */\n  deleteToken(token) {\n    if (typeof token !== 'string' || token.length === 0) {\n      return Promise.reject(\n        this.errorFactory_.create(Errors.codes.INVALID_DELETE_TOKEN)\n      );\n    }\n\n    return this.getTokenDetailsFromToken(token).then(details => {\n      if (!details) {\n        throw this.errorFactory_.create(Errors.codes.DELETE_TOKEN_NOT_FOUND);\n      }\n\n      return this.openDatabase_().then(db => {\n        return new Promise((resolve, reject) => {\n          const transaction = db.transaction(\n            [FCM_TOKEN_OBJ_STORE],\n            'readwrite'\n          );\n          const objectStore = transaction.objectStore(FCM_TOKEN_OBJ_STORE);\n          const request = objectStore.delete(details['swScope']);\n          request.onerror = event => {\n            reject((<IDBRequest>event.target).error);\n          };\n          request.onsuccess = event => {\n            if ((<IDBRequest>event.target).result === 0) {\n              reject(\n                this.errorFactory_.create(Errors.codes.FAILED_TO_DELETE_TOKEN)\n              );\n              return;\n            }\n\n            resolve(details);\n          };\n        });\n      });\n    });\n  }\n}\n","/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n'use strict';\nimport { ErrorFactory } from '../../app/errors';\nimport Errors from './errors';\nimport arrayBufferToBase64 from '../helpers/array-buffer-to-base64';\nimport FCMDetails from './fcm-details';\nvar FCM_TOKEN_DETAILS_DB = 'fcm_token_details_db';\nvar FCM_TOKEN_OBJ_STORE = 'fcm_token_object_Store';\nvar FCM_TOKEN_DETAILS_DB_VERSION = 1;\nvar TokenManager = (function () {\n    function TokenManager() {\n        this.errorFactory_ = new ErrorFactory('messaging', 'Messaging', Errors.map);\n        this.openDbPromise_ = null;\n    }\n    /**\n     * Get the indexedDB as a promsie.\n     * @private\n     * @return {Promise<IDBDatabase>} The IndexedDB database\n     */\n    TokenManager.prototype.openDatabase_ = function () {\n        if (this.openDbPromise_) {\n            return this.openDbPromise_;\n        }\n        this.openDbPromise_ = new Promise(function (resolve, reject) {\n            var request = indexedDB.open(FCM_TOKEN_DETAILS_DB, FCM_TOKEN_DETAILS_DB_VERSION);\n            request.onerror = function (event) {\n                reject(event.target.error);\n            };\n            request.onsuccess = function (event) {\n                resolve(event.target.result);\n            };\n            request.onupgradeneeded = function (event) {\n                var db = event.target.result;\n                var objectStore = db.createObjectStore(FCM_TOKEN_OBJ_STORE, {\n                    keyPath: 'swScope'\n                });\n                // Make sure the sender ID can be searched\n                objectStore.createIndex('fcmSenderId', 'fcmSenderId', {\n                    unique: false\n                });\n                objectStore.createIndex('fcmToken', 'fcmToken', {\n                    unique: true\n                });\n            };\n        });\n        return this.openDbPromise_;\n    };\n    /**\n     * Close the currently open database.\n     * @return {Promise<?>} Returns the result of the promise chain.\n     */\n    TokenManager.prototype.closeDatabase = function () {\n        var _this = this;\n        if (this.openDbPromise_) {\n            return this.openDbPromise_.then(function (db) {\n                db.close();\n                _this.openDbPromise_ = null;\n            });\n        }\n        return Promise.resolve();\n    };\n    /**\n     * Given a token, this method will look up the details in indexedDB.\n     * @public\n     * @param {string} fcmToken\n     * @return {Promise<Object>} The details associated with that token.\n     */\n    TokenManager.prototype.getTokenDetailsFromToken = function (fcmToken) {\n        return this.openDatabase_().then(function (db) {\n            return new Promise(function (resolve, reject) {\n                var transaction = db.transaction([FCM_TOKEN_OBJ_STORE]);\n                var objectStore = transaction.objectStore(FCM_TOKEN_OBJ_STORE);\n                var index = objectStore.index('fcmToken');\n                var request = index.get(fcmToken);\n                request.onerror = function (event) {\n                    reject(event.target.error);\n                };\n                request.onsuccess = function (event) {\n                    resolve(event.target.result);\n                };\n            });\n        });\n    };\n    TokenManager.prototype.getTokenDetailsFromSWScope_ = function (swScope) {\n        return this.openDatabase_().then(function (db) {\n            return new Promise(function (resolve, reject) {\n                var transaction = db.transaction([FCM_TOKEN_OBJ_STORE]);\n                var objectStore = transaction.objectStore(FCM_TOKEN_OBJ_STORE);\n                var scopeRequest = objectStore.get(swScope);\n                scopeRequest.onerror = function (event) {\n                    reject(event.target.error);\n                };\n                scopeRequest.onsuccess = function (event) {\n                    resolve(event.target.result);\n                };\n            });\n        });\n    };\n    TokenManager.prototype.getAllTokenDetailsForSenderId_ = function (senderId) {\n        return this.openDatabase_().then(function (db) {\n            return new Promise(function (resolve, reject) {\n                var transaction = db.transaction([FCM_TOKEN_OBJ_STORE]);\n                var objectStore = transaction.objectStore(FCM_TOKEN_OBJ_STORE);\n                var senderIdTokens = [];\n                var cursorRequest = objectStore.openCursor();\n                cursorRequest.onerror = function (event) {\n                    reject(event.target.error);\n                };\n                cursorRequest.onsuccess = function (event) {\n                    var cursor = event.target.result;\n                    if (cursor) {\n                        if (cursor.value['fcmSenderId'] === senderId) {\n                            senderIdTokens.push(cursor.value);\n                        }\n                        cursor.continue();\n                    }\n                    else {\n                        resolve(senderIdTokens);\n                    }\n                };\n            });\n        });\n    };\n    /**\n     * Given a PushSubscription and messagingSenderId, get an FCM token.\n     * @public\n     * @param  {string} senderId The 'messagingSenderId' to tie the token to.\n     * @param  {PushSubscription} subscription The PushSusbcription to \"federate\".\n     * @param  {string=} pushSet If defined this will swap the subscription for\n     * matching FCM token.\n     * @return {Promise<!Object>} Returns the FCM token to be used in place\n     * of the PushSubscription.\n     */\n    TokenManager.prototype.subscribeToFCM = function (senderId, subscription, pushSet) {\n        var _this = this;\n        var p256dh = arrayBufferToBase64(subscription['getKey']('p256dh'));\n        var auth = arrayBufferToBase64(subscription['getKey']('auth'));\n        var fcmSubscribeBody = \"authorized_entity=\" + senderId + \"&\" +\n            (\"endpoint=\" + subscription.endpoint + \"&\") +\n            (\"encryption_key=\" + p256dh + \"&\") +\n            (\"encryption_auth=\" + auth);\n        if (pushSet) {\n            fcmSubscribeBody += \"&pushSet=\" + pushSet;\n        }\n        var headers = new Headers();\n        headers.append('Content-Type', 'application/x-www-form-urlencoded');\n        var subscribeOptions = {\n            method: 'POST',\n            headers: headers,\n            body: fcmSubscribeBody\n        };\n        return fetch(FCMDetails.ENDPOINT + '/fcm/connect/subscribe', subscribeOptions)\n            .then(function (response) { return response.json(); })\n            .then(function (response) {\n            var fcmTokenResponse = response;\n            if (fcmTokenResponse['error']) {\n                var message = fcmTokenResponse['error']['message'];\n                throw _this.errorFactory_.create(Errors.codes.TOKEN_SUBSCRIBE_FAILED, {\n                    message: message\n                });\n            }\n            if (!fcmTokenResponse['token']) {\n                throw _this.errorFactory_.create(Errors.codes.TOKEN_SUBSCRIBE_NO_TOKEN);\n            }\n            if (!fcmTokenResponse['pushSet']) {\n                throw _this.errorFactory_.create(Errors.codes.TOKEN_SUBSCRIBE_NO_PUSH_SET);\n            }\n            return {\n                token: fcmTokenResponse['token'],\n                pushSet: fcmTokenResponse['pushSet']\n            };\n        });\n    };\n    /**\n     * Checks the that fields in the PushSubscription are equivalent to the\n     * details stores in the masterTokenDetails.\n     * @private\n     * @param  {PushSubscription} subscription The push subscription we expect\n     * the master token to match.\n     * @param  {Object}  masterTokenDetails The saved details we wish to compare\n     * with the PushSubscription\n     * @return {boolean} true if the subscription and token details are\n     * equivalent.\n     */\n    TokenManager.prototype.isSameSubscription_ = function (subscription, masterTokenDetails) {\n        // getKey() isn't defined in the PushSubscription externs file, hence\n        // subscription['getKey']('<key name>').\n        return (subscription.endpoint === masterTokenDetails['endpoint'] &&\n            arrayBufferToBase64(subscription['getKey']('auth')) ===\n                masterTokenDetails['auth'] &&\n            arrayBufferToBase64(subscription['getKey']('p256dh')) ===\n                masterTokenDetails['p256dh']);\n    };\n    /**\n     * Save the details for the fcm token for re-use at a later date.\n     * @private\n     * @param  {string} senderId The 'messagingSenderId' used for this project\n     * @param  {ServiceWorkerRegistration} swRegistration The service worker\n     * used to subscribe the user for web push\n     * @param  {PushSubscription} subscription The push subscription passed to\n     * FCM for the current token.\n     * @param  {string} fcmToken The FCM token currently used on this\n     * device.\n     * @param  {string} fcmPushSet The FCM push tied to the fcm token.\n     * @return {Promise<void>}\n     */\n    TokenManager.prototype.saveTokenDetails_ = function (senderId, swRegistration, subscription, fcmToken, fcmPushSet) {\n        var details = {\n            swScope: swRegistration.scope,\n            endpoint: subscription.endpoint,\n            auth: arrayBufferToBase64(subscription['getKey']('auth')),\n            p256dh: arrayBufferToBase64(subscription['getKey']('p256dh')),\n            fcmToken: fcmToken,\n            fcmPushSet: fcmPushSet,\n            fcmSenderId: senderId\n        };\n        return this.openDatabase_().then(function (db) {\n            return new Promise(function (resolve, reject) {\n                var transaction = db.transaction([FCM_TOKEN_OBJ_STORE], 'readwrite');\n                var objectStore = transaction.objectStore(FCM_TOKEN_OBJ_STORE);\n                var request = objectStore.put(details);\n                request.onerror = function (event) {\n                    reject(event.target.error);\n                };\n                request.onsuccess = function (event) {\n                    resolve();\n                };\n            });\n        });\n    };\n    /**\n     * Returns the saved FCM Token if one is available and still valid,\n     * otherwise `null` is returned.\n     * @param {string} senderId This should be the sender ID associated with the\n     * FCM Token being retrieved.\n     * @param {ServiceWorkerRegistration} swRegistration Registration to be used\n     * to subscribe the user to push.\n     * @return {Promise<string> | Promise} Returns the saved FCM Token if\n     * avilable and valid.\n     * @export\n     */\n    TokenManager.prototype.getSavedToken = function (senderId, swRegistration) {\n        var _this = this;\n        if (!(swRegistration instanceof ServiceWorkerRegistration)) {\n            return Promise.reject(this.errorFactory_.create(Errors.codes.SW_REGISTRATION_EXPECTED));\n        }\n        if (typeof senderId !== 'string' || senderId.length === 0) {\n            return Promise.reject(this.errorFactory_.create(Errors.codes.BAD_SENDER_ID));\n        }\n        return this.getAllTokenDetailsForSenderId_(senderId)\n            .then(function (allTokenDetails) {\n            if (allTokenDetails.length === 0) {\n                return;\n            }\n            var index = allTokenDetails.findIndex(function (tokenDetails) {\n                return (swRegistration.scope === tokenDetails['swScope'] &&\n                    senderId === tokenDetails['fcmSenderId']);\n            });\n            if (index === -1) {\n                return;\n            }\n            return allTokenDetails[index];\n        })\n            .then(function (tokenDetails) {\n            if (!tokenDetails) {\n                return;\n            }\n            return swRegistration.pushManager\n                .getSubscription()\n                .catch(function (err) {\n                throw _this.errorFactory_.create(Errors.codes.GET_SUBSCRIPTION_FAILED);\n            })\n                .then(function (subscription) {\n                if (subscription &&\n                    _this.isSameSubscription_(subscription, tokenDetails)) {\n                    return tokenDetails['fcmToken'];\n                }\n            });\n        });\n    };\n    /**\n     * Creates a new FCM token.\n     */\n    TokenManager.prototype.createToken = function (senderId, swRegistration) {\n        var _this = this;\n        if (typeof senderId !== 'string' || senderId.length === 0) {\n            return Promise.reject(this.errorFactory_.create(Errors.codes.BAD_SENDER_ID));\n        }\n        if (!(swRegistration instanceof ServiceWorkerRegistration)) {\n            return Promise.reject(this.errorFactory_.create(Errors.codes.SW_REGISTRATION_EXPECTED));\n        }\n        // Check for existing subscription first\n        var subscription;\n        var fcmTokenDetails;\n        return swRegistration.pushManager\n            .getSubscription()\n            .then(function (subscription) {\n            if (subscription) {\n                return subscription;\n            }\n            return swRegistration.pushManager.subscribe(FCMDetails.SUBSCRIPTION_OPTIONS);\n        })\n            .then(function (sub) {\n            subscription = sub;\n            return _this.subscribeToFCM(senderId, subscription);\n        })\n            .then(function (tokenDetails) {\n            fcmTokenDetails = tokenDetails;\n            return _this.saveTokenDetails_(senderId, swRegistration, subscription, fcmTokenDetails['token'], fcmTokenDetails['pushSet']);\n        })\n            .then(function () { return fcmTokenDetails['token']; });\n    };\n    /**\n     * This method deletes details of the current FCM token.\n     * It's returning a promise in case we need to move to an async\n     * method for deleting at a later date.\n     * @param {string} token Token to be deleted\n     * @return {Promise<Object>} Resolves once the FCM token details have been\n     * deleted and returns the deleted details.\n     */\n    TokenManager.prototype.deleteToken = function (token) {\n        var _this = this;\n        if (typeof token !== 'string' || token.length === 0) {\n            return Promise.reject(this.errorFactory_.create(Errors.codes.INVALID_DELETE_TOKEN));\n        }\n        return this.getTokenDetailsFromToken(token).then(function (details) {\n            if (!details) {\n                throw _this.errorFactory_.create(Errors.codes.DELETE_TOKEN_NOT_FOUND);\n            }\n            return _this.openDatabase_().then(function (db) {\n                return new Promise(function (resolve, reject) {\n                    var transaction = db.transaction([FCM_TOKEN_OBJ_STORE], 'readwrite');\n                    var objectStore = transaction.objectStore(FCM_TOKEN_OBJ_STORE);\n                    var request = objectStore.delete(details['swScope']);\n                    request.onerror = function (event) {\n                        reject(event.target.error);\n                    };\n                    request.onsuccess = function (event) {\n                        if (event.target.result === 0) {\n                            reject(_this.errorFactory_.create(Errors.codes.FAILED_TO_DELETE_TOKEN));\n                            return;\n                        }\n                        resolve(details);\n                    };\n                });\n            });\n        });\n    };\n    return TokenManager;\n}());\nexport default TokenManager;\n\n\n"]}