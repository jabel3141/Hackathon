{"version":3,"sources":["src/database/core/PersistentConnection.ts","database/core/PersistentConnection.js"],"names":["__extends","extendStatics","Object","setPrototypeOf","__proto__","Array","d","b","p","hasOwnProperty","__","constructor","prototype","create","RECONNECT_MIN_DELAY","RECONNECT_MAX_DELAY_DEFAULT","RECONNECT_MAX_DELAY_FOR_ADMINS","RECONNECT_DELAY_MULTIPLIER","RECONNECT_DELAY_RESET_TIMEOUT","SERVER_KILL_INTERRUPT_REASON","INVALID_AUTH_TOKEN_THRESHOLD","PersistentConnection","_super","repoInfo_","onDataUpdate_","onConnectStatus_","onServerInfoUpdate_","authTokenProvider_","authOverride_","_this","call","id","nextPersistentConnectionId_","log_","interruptReasons_","listens_","outstandingPuts_","outstandingPutCount_","onDisconnectRequestQueue_","connected_","reconnectDelay_","maxReconnectDelay_","securityDebugCallback_","lastSessionId","establishConnectionTimer_","visible_","requestCBHash_","requestNumber_","realtime_","authToken_","forceTokenRefresh_","invalidAuthTokenCount_","firstConnection_","lastConnectionAttemptTime_","lastConnectionEstablishedTime_","Error","scheduleConnect_","getInstance","on","onVisible_","host","indexOf","onOnline_","sendRequest","action","body","onResponse","curReqNum","msg","r","a","listen","query","currentHashFn","tag","onComplete","queryId","queryIdentifier","pathString","path","toString","getQueryParams","isDefault","loadsAllData","listenSpec","hashFn","sendListen_","req","queryObject","message","payload","status","warnOnListenWarnings_","currentListenSpec","removeListen_","warnings","isArray","indexSpec","getIndex","indexPath","refreshAuthToken","token","tryAuth","reduceReconnectDelayIfAdminCredential_","credential","isFirebaseSecret","length","token_1","authMethod","requestData","cred","res","data","onAuthRevoked_","unlisten","sendUnlisten_","queryObj","onDisconnectPut","sendOnDisconnect_","push","onDisconnectMerge","onDisconnectCancel","request","response","setTimeout","Math","floor","put","hash","putInternal","merge","undefined","index","sendPut_","queued","reportStats","stats","c","result","errorReason","onDataMessage_","reqNum","onDataPush_","onListenRevoked_","onSecurityDebugPacket_","onReady_","timestamp","sessionId","Date","getTime","handleTimestamp_","sendConnectStats_","restoreState_","timeout","clearTimeout","establishConnection_","visible","online","close","onRealtimeDisconnect_","cancelSentTransactions_","shouldReconnect_","timeSinceLastConnectSucceeded","timeSinceLastConnectAttempt","reconnectDelay","max","random","min","onDataMessage_1","bind","onReady_1","onDisconnect_1","connId_1","nextConnectionId_","self_1","lastSessionId_1","canceled_1","connection_1","closeFn_1","sendRequestFn","forceRefresh","getToken","then","accessToken","reason","interrupt","error","NODE_ADMIN","resume","delta","serverTimeOffset","i","map","q","join","normalizedPathString","statusCode","explanation","notifyForInvalidToken","console","log","replace","queries","key","shift","clientName","NODE_CLIENT","SDK_VERSION","currentlyOnline"],"mappings":"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","file":"PersistentConnection.js","sourcesContent":["/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\nimport firebase from '../../app';\nimport { forEach, contains, isEmpty, getCount, safeGet } from '../../utils/obj';\nimport { stringify } from '../../utils/json';\nimport { assert } from '../../utils/assert';\nimport { error, log, logWrapper, warn, ObjectToUniqueKey } from './util/util';\nimport { Path } from './util/Path';\nimport { VisibilityMonitor } from './util/VisibilityMonitor';\nimport { OnlineMonitor } from './util/OnlineMonitor';\nimport { isAdmin, isValidFormat } from '../../utils/jwt';\nimport { Connection } from '../realtime/Connection';\nimport { CONSTANTS } from '../../utils/constants';\nimport {\n  isMobileCordova,\n  isReactNative,\n  isNodeSdk\n} from '../../utils/environment';\nimport { ServerActions } from './ServerActions';\nimport { AuthTokenProvider } from './AuthTokenProvider';\nimport { RepoInfo } from './RepoInfo';\nimport { Query } from '../api/Query';\n\nconst RECONNECT_MIN_DELAY = 1000;\nconst RECONNECT_MAX_DELAY_DEFAULT = 60 * 5 * 1000; // 5 minutes in milliseconds (Case: 1858)\nconst RECONNECT_MAX_DELAY_FOR_ADMINS = 30 * 1000; // 30 seconds for admin clients (likely to be a backend server)\nconst RECONNECT_DELAY_MULTIPLIER = 1.3;\nconst RECONNECT_DELAY_RESET_TIMEOUT = 30000; // Reset delay back to MIN_DELAY after being connected for 30sec.\nconst SERVER_KILL_INTERRUPT_REASON = 'server_kill';\n\n// If auth fails repeatedly, we'll assume something is wrong and log a warning / back off.\nconst INVALID_AUTH_TOKEN_THRESHOLD = 3;\n\ninterface ListenSpec {\n  onComplete(s: string, p?: any): void;\n\n  hashFn(): string;\n\n  query: Query;\n  tag: number | null;\n}\n\ninterface OnDisconnectRequest {\n  pathString: string;\n  action: string;\n  data: any;\n  onComplete?: (a: string, b: string) => void;\n}\n\ninterface OutstandingPut {\n  action: string;\n  request: Object;\n  queued?: boolean;\n  onComplete: (a: string, b?: string) => void;\n}\n\n/**\n * Firebase connection.  Abstracts wire protocol and handles reconnecting.\n *\n * NOTE: All JSON objects sent to the realtime connection must have property names enclosed\n * in quotes to make sure the closure compiler does not minify them.\n */\nexport class PersistentConnection extends ServerActions {\n  // Used for diagnostic logging.\n  id = PersistentConnection.nextPersistentConnectionId_++;\n  private log_ = logWrapper('p:' + this.id + ':');\n\n  /** @private {Object} */\n  private interruptReasons_: { [reason: string]: boolean } = {};\n  private listens_: { [path: string]: { [queryId: string]: ListenSpec } } = {};\n  private outstandingPuts_: OutstandingPut[] = [];\n  private outstandingPutCount_ = 0;\n  private onDisconnectRequestQueue_: OnDisconnectRequest[] = [];\n  private connected_ = false;\n  private reconnectDelay_ = RECONNECT_MIN_DELAY;\n  private maxReconnectDelay_ = RECONNECT_MAX_DELAY_DEFAULT;\n  private securityDebugCallback_: ((a: Object) => void) | null = null;\n  lastSessionId: string | null = null;\n\n  /** @private {number|null} */\n  private establishConnectionTimer_: number | null = null;\n\n  /** @private {boolean} */\n  private visible_: boolean = false;\n\n  // Before we get connected, we keep a queue of pending messages to send.\n  private requestCBHash_: { [k: number]: (a: any) => void } = {};\n  private requestNumber_ = 0;\n\n  /** @private {?{\n   *   sendRequest(Object),\n   *   close()\n   * }} */\n  private realtime_: {\n    sendRequest(a: Object): void;\n    close(): void;\n  } | null = null;\n\n  /** @private {string|null} */\n  private authToken_: string | null = null;\n  private forceTokenRefresh_ = false;\n  private invalidAuthTokenCount_ = 0;\n\n  private firstConnection_ = true;\n  private lastConnectionAttemptTime_: number | null = null;\n  private lastConnectionEstablishedTime_: number | null = null;\n\n  /**\n   * @private\n   */\n  private static nextPersistentConnectionId_ = 0;\n\n  /**\n   * Counter for number of connections created. Mainly used for tagging in the logs\n   * @type {number}\n   * @private\n   */\n  private static nextConnectionId_ = 0;\n\n  /**\n   * @implements {ServerActions}\n   * @param {!RepoInfo} repoInfo_ Data about the namespace we are connecting to\n   * @param {function(string, *, boolean, ?number)} onDataUpdate_ A callback for new data from the server\n   * @param onConnectStatus_\n   * @param onServerInfoUpdate_\n   * @param authTokenProvider_\n   * @param authOverride_\n   */\n  constructor(\n    private repoInfo_: RepoInfo,\n    private onDataUpdate_: (\n      a: string,\n      b: any,\n      c: boolean,\n      d: number | null\n    ) => void,\n    private onConnectStatus_: (a: boolean) => void,\n    private onServerInfoUpdate_: (a: any) => void,\n    private authTokenProvider_: AuthTokenProvider,\n    private authOverride_?: Object | null\n  ) {\n    super();\n\n    if (authOverride_ && !isNodeSdk()) {\n      throw new Error(\n        'Auth override specified in options, but not supported on non Node.js platforms'\n      );\n    }\n    this.scheduleConnect_(0);\n\n    VisibilityMonitor.getInstance().on('visible', this.onVisible_, this);\n\n    if (repoInfo_.host.indexOf('fblocal') === -1) {\n      OnlineMonitor.getInstance().on('online', this.onOnline_, this);\n    }\n  }\n\n  /**\n   * @param {!string} action\n   * @param {*} body\n   * @param {function(*)=} onResponse\n   * @protected\n   */\n  protected sendRequest(\n    action: string,\n    body: any,\n    onResponse?: (a: any) => void\n  ) {\n    const curReqNum = ++this.requestNumber_;\n\n    const msg = { r: curReqNum, a: action, b: body };\n    this.log_(stringify(msg));\n    assert(\n      this.connected_,\n      \"sendRequest call when we're not connected not allowed.\"\n    );\n    this.realtime_.sendRequest(msg);\n    if (onResponse) {\n      this.requestCBHash_[curReqNum] = onResponse;\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  listen(\n    query: Query,\n    currentHashFn: () => string,\n    tag: number | null,\n    onComplete: (a: string, b: any) => void\n  ) {\n    const queryId = query.queryIdentifier();\n    const pathString = query.path.toString();\n    this.log_('Listen called for ' + pathString + ' ' + queryId);\n    this.listens_[pathString] = this.listens_[pathString] || {};\n    assert(\n      query.getQueryParams().isDefault() ||\n        !query.getQueryParams().loadsAllData(),\n      'listen() called for non-default but complete query'\n    );\n    assert(\n      !this.listens_[pathString][queryId],\n      'listen() called twice for same path/queryId.'\n    );\n    const listenSpec: ListenSpec = {\n      onComplete: onComplete,\n      hashFn: currentHashFn,\n      query: query,\n      tag: tag\n    };\n    this.listens_[pathString][queryId] = listenSpec;\n\n    if (this.connected_) {\n      this.sendListen_(listenSpec);\n    }\n  }\n\n  /**\n   * @param {!{onComplete(),\n   *           hashFn():!string,\n   *           query: !Query,\n   *           tag: ?number}} listenSpec\n   * @private\n   */\n  private sendListen_(listenSpec: ListenSpec) {\n    const query = listenSpec.query;\n    const pathString = query.path.toString();\n    const queryId = query.queryIdentifier();\n    this.log_('Listen on ' + pathString + ' for ' + queryId);\n    const req: { [k: string]: any } = { /*path*/ p: pathString };\n\n    const action = 'q';\n\n    // Only bother to send query if it's non-default.\n    if (listenSpec.tag) {\n      req['q'] = query.queryObject();\n      req['t'] = listenSpec.tag;\n    }\n\n    req[/*hash*/ 'h'] = listenSpec.hashFn();\n\n    this.sendRequest(action, req, (message: { [k: string]: any }) => {\n      const payload: any = message[/*data*/ 'd'];\n      const status: string = message[/*status*/ 's'];\n\n      // print warnings in any case...\n      PersistentConnection.warnOnListenWarnings_(payload, query);\n\n      const currentListenSpec =\n        this.listens_[pathString] && this.listens_[pathString][queryId];\n      // only trigger actions if the listen hasn't been removed and readded\n      if (currentListenSpec === listenSpec) {\n        this.log_('listen response', message);\n\n        if (status !== 'ok') {\n          this.removeListen_(pathString, queryId);\n        }\n\n        if (listenSpec.onComplete) {\n          listenSpec.onComplete(status, payload);\n        }\n      }\n    });\n  }\n\n  /**\n   * @param {*} payload\n   * @param {!Query} query\n   * @private\n   */\n  private static warnOnListenWarnings_(payload: any, query: Query) {\n    if (payload && typeof payload === 'object' && contains(payload, 'w')) {\n      const warnings = safeGet(payload, 'w');\n      if (Array.isArray(warnings) && ~warnings.indexOf('no_index')) {\n        const indexSpec =\n          '\".indexOn\": \"' + query.getQueryParams().getIndex().toString() + '\"';\n        const indexPath = query.path.toString();\n        warn(\n          `Using an unspecified index. Your data will be downloaded and ` +\n            `filtered on the client. Consider adding ${indexSpec} at ` +\n            `${indexPath} to your security rules for better performance.`\n        );\n      }\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  refreshAuthToken(token: string) {\n    this.authToken_ = token;\n    this.log_('Auth token refreshed');\n    if (this.authToken_) {\n      this.tryAuth();\n    } else {\n      //If we're connected we want to let the server know to unauthenticate us. If we're not connected, simply delete\n      //the credential so we dont become authenticated next time we connect.\n      if (this.connected_) {\n        this.sendRequest('unauth', {}, () => {});\n      }\n    }\n\n    this.reduceReconnectDelayIfAdminCredential_(token);\n  }\n\n  /**\n   * @param {!string} credential\n   * @private\n   */\n  private reduceReconnectDelayIfAdminCredential_(credential: string) {\n    // NOTE: This isn't intended to be bulletproof (a malicious developer can always just modify the client).\n    // Additionally, we don't bother resetting the max delay back to the default if auth fails / expires.\n    const isFirebaseSecret = credential && credential.length === 40;\n    if (isFirebaseSecret || isAdmin(credential)) {\n      this.log_(\n        'Admin auth credential detected.  Reducing max reconnect time.'\n      );\n      this.maxReconnectDelay_ = RECONNECT_MAX_DELAY_FOR_ADMINS;\n    }\n  }\n\n  /**\n   * Attempts to authenticate with the given credentials. If the authentication attempt fails, it's triggered like\n   * a auth revoked (the connection is closed).\n   */\n  tryAuth() {\n    if (this.connected_ && this.authToken_) {\n      const token = this.authToken_;\n      const authMethod = isValidFormat(token) ? 'auth' : 'gauth';\n      const requestData: { [k: string]: any } = { cred: token };\n      if (this.authOverride_ === null) {\n        requestData['noauth'] = true;\n      } else if (typeof this.authOverride_ === 'object') {\n        requestData['authvar'] = this.authOverride_;\n      }\n      this.sendRequest(authMethod, requestData, (res: { [k: string]: any }) => {\n        const status: string = res[/*status*/ 's'];\n        const data: string = res[/*data*/ 'd'] || 'error';\n\n        if (this.authToken_ === token) {\n          if (status === 'ok') {\n            this.invalidAuthTokenCount_ = 0;\n          } else {\n            // Triggers reconnect and force refresh for auth token\n            this.onAuthRevoked_(status, data);\n          }\n        }\n      });\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  unlisten(query: Query, tag: number | null) {\n    const pathString = query.path.toString();\n    const queryId = query.queryIdentifier();\n\n    this.log_('Unlisten called for ' + pathString + ' ' + queryId);\n\n    assert(\n      query.getQueryParams().isDefault() ||\n        !query.getQueryParams().loadsAllData(),\n      'unlisten() called for non-default but complete query'\n    );\n    const listen = this.removeListen_(pathString, queryId);\n    if (listen && this.connected_) {\n      this.sendUnlisten_(pathString, queryId, query.queryObject(), tag);\n    }\n  }\n\n  private sendUnlisten_(\n    pathString: string,\n    queryId: string,\n    queryObj: Object,\n    tag: number | null\n  ) {\n    this.log_('Unlisten on ' + pathString + ' for ' + queryId);\n\n    const req: { [k: string]: any } = { /*path*/ p: pathString };\n    const action = 'n';\n    // Only bother sending queryId if it's non-default.\n    if (tag) {\n      req['q'] = queryObj;\n      req['t'] = tag;\n    }\n\n    this.sendRequest(action, req);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  onDisconnectPut(\n    pathString: string,\n    data: any,\n    onComplete?: (a: string, b: string) => void\n  ) {\n    if (this.connected_) {\n      this.sendOnDisconnect_('o', pathString, data, onComplete);\n    } else {\n      this.onDisconnectRequestQueue_.push({\n        pathString,\n        action: 'o',\n        data,\n        onComplete\n      });\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  onDisconnectMerge(\n    pathString: string,\n    data: any,\n    onComplete?: (a: string, b: string) => void\n  ) {\n    if (this.connected_) {\n      this.sendOnDisconnect_('om', pathString, data, onComplete);\n    } else {\n      this.onDisconnectRequestQueue_.push({\n        pathString,\n        action: 'om',\n        data,\n        onComplete\n      });\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  onDisconnectCancel(\n    pathString: string,\n    onComplete?: (a: string, b: string) => void\n  ) {\n    if (this.connected_) {\n      this.sendOnDisconnect_('oc', pathString, null, onComplete);\n    } else {\n      this.onDisconnectRequestQueue_.push({\n        pathString,\n        action: 'oc',\n        data: null,\n        onComplete\n      });\n    }\n  }\n\n  private sendOnDisconnect_(\n    action: string,\n    pathString: string,\n    data: any,\n    onComplete: (a: string, b: string) => void\n  ) {\n    const request = { /*path*/ p: pathString, /*data*/ d: data };\n    this.log_('onDisconnect ' + action, request);\n    this.sendRequest(action, request, (response: { [k: string]: any }) => {\n      if (onComplete) {\n        setTimeout(function() {\n          onComplete(response[/*status*/ 's'], response[/* data */ 'd']);\n        }, Math.floor(0));\n      }\n    });\n  }\n\n  /**\n   * @inheritDoc\n   */\n  put(\n    pathString: string,\n    data: any,\n    onComplete?: (a: string, b: string) => void,\n    hash?: string\n  ) {\n    this.putInternal('p', pathString, data, onComplete, hash);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  merge(\n    pathString: string,\n    data: any,\n    onComplete: (a: string, b: string | null) => void,\n    hash?: string\n  ) {\n    this.putInternal('m', pathString, data, onComplete, hash);\n  }\n\n  putInternal(\n    action: string,\n    pathString: string,\n    data: any,\n    onComplete: (a: string, b: string | null) => void,\n    hash?: string\n  ) {\n    const request: { [k: string]: any } = {\n      /*path*/ p: pathString,\n      /*data*/ d: data\n    };\n\n    if (hash !== undefined) request[/*hash*/ 'h'] = hash;\n\n    // TODO: Only keep track of the most recent put for a given path?\n    this.outstandingPuts_.push({\n      action,\n      request,\n      onComplete\n    });\n\n    this.outstandingPutCount_++;\n    const index = this.outstandingPuts_.length - 1;\n\n    if (this.connected_) {\n      this.sendPut_(index);\n    } else {\n      this.log_('Buffering put: ' + pathString);\n    }\n  }\n\n  private sendPut_(index: number) {\n    const action = this.outstandingPuts_[index].action;\n    const request = this.outstandingPuts_[index].request;\n    const onComplete = this.outstandingPuts_[index].onComplete;\n    this.outstandingPuts_[index].queued = this.connected_;\n\n    this.sendRequest(action, request, (message: { [k: string]: any }) => {\n      this.log_(action + ' response', message);\n\n      delete this.outstandingPuts_[index];\n      this.outstandingPutCount_--;\n\n      // Clean up array occasionally.\n      if (this.outstandingPutCount_ === 0) {\n        this.outstandingPuts_ = [];\n      }\n\n      if (onComplete)\n        onComplete(message[/*status*/ 's'], message[/* data */ 'd']);\n    });\n  }\n\n  /**\n   * @inheritDoc\n   */\n  reportStats(stats: { [k: string]: any }) {\n    // If we're not connected, we just drop the stats.\n    if (this.connected_) {\n      const request = { /*counters*/ c: stats };\n      this.log_('reportStats', request);\n\n      this.sendRequest(/*stats*/ 's', request, result => {\n        const status = result[/*status*/ 's'];\n        if (status !== 'ok') {\n          const errorReason = result[/* data */ 'd'];\n          this.log_('reportStats', 'Error sending stats: ' + errorReason);\n        }\n      });\n    }\n  }\n\n  /**\n   * @param {*} message\n   * @private\n   */\n  private onDataMessage_(message: { [k: string]: any }) {\n    if ('r' in message) {\n      // this is a response\n      this.log_('from server: ' + stringify(message));\n      const reqNum = message['r'];\n      const onResponse = this.requestCBHash_[reqNum];\n      if (onResponse) {\n        delete this.requestCBHash_[reqNum];\n        onResponse(message[/*body*/ 'b']);\n      }\n    } else if ('error' in message) {\n      throw 'A server-side error has occurred: ' + message['error'];\n    } else if ('a' in message) {\n      // a and b are action and body, respectively\n      this.onDataPush_(message['a'], message['b']);\n    }\n  }\n\n  private onDataPush_(action: string, body: { [k: string]: any }) {\n    this.log_('handleServerMessage', action, body);\n    if (action === 'd')\n      this.onDataUpdate_(\n        body[/*path*/ 'p'],\n        body[/*data*/ 'd'],\n        /*isMerge*/ false,\n        body['t']\n      );\n    else if (action === 'm')\n      this.onDataUpdate_(\n        body[/*path*/ 'p'],\n        body[/*data*/ 'd'],\n        /*isMerge=*/ true,\n        body['t']\n      );\n    else if (action === 'c')\n      this.onListenRevoked_(body[/*path*/ 'p'], body[/*query*/ 'q']);\n    else if (action === 'ac')\n      this.onAuthRevoked_(\n        body[/*status code*/ 's'],\n        body[/* explanation */ 'd']\n      );\n    else if (action === 'sd') this.onSecurityDebugPacket_(body);\n    else\n      error(\n        'Unrecognized action received from server: ' +\n          stringify(action) +\n          '\\nAre you using the latest client?'\n      );\n  }\n\n  private onReady_(timestamp: number, sessionId: string) {\n    this.log_('connection ready');\n    this.connected_ = true;\n    this.lastConnectionEstablishedTime_ = new Date().getTime();\n    this.handleTimestamp_(timestamp);\n    this.lastSessionId = sessionId;\n    if (this.firstConnection_) {\n      this.sendConnectStats_();\n    }\n    this.restoreState_();\n    this.firstConnection_ = false;\n    this.onConnectStatus_(true);\n  }\n\n  private scheduleConnect_(timeout: number) {\n    assert(\n      !this.realtime_,\n      \"Scheduling a connect when we're already connected/ing?\"\n    );\n\n    if (this.establishConnectionTimer_) {\n      clearTimeout(this.establishConnectionTimer_);\n    }\n\n    // NOTE: Even when timeout is 0, it's important to do a setTimeout to work around an infuriating \"Security Error\" in\n    // Firefox when trying to write to our long-polling iframe in some scenarios (e.g. Forge or our unit tests).\n\n    this.establishConnectionTimer_ = setTimeout(() => {\n      this.establishConnectionTimer_ = null;\n      this.establishConnection_();\n    }, Math.floor(timeout)) as any;\n  }\n\n  /**\n   * @param {boolean} visible\n   * @private\n   */\n  private onVisible_(visible: boolean) {\n    // NOTE: Tabbing away and back to a window will defeat our reconnect backoff, but I think that's fine.\n    if (\n      visible &&\n      !this.visible_ &&\n      this.reconnectDelay_ === this.maxReconnectDelay_\n    ) {\n      this.log_('Window became visible.  Reducing delay.');\n      this.reconnectDelay_ = RECONNECT_MIN_DELAY;\n\n      if (!this.realtime_) {\n        this.scheduleConnect_(0);\n      }\n    }\n    this.visible_ = visible;\n  }\n\n  private onOnline_(online: boolean) {\n    if (online) {\n      this.log_('Browser went online.');\n      this.reconnectDelay_ = RECONNECT_MIN_DELAY;\n      if (!this.realtime_) {\n        this.scheduleConnect_(0);\n      }\n    } else {\n      this.log_('Browser went offline.  Killing connection.');\n      if (this.realtime_) {\n        this.realtime_.close();\n      }\n    }\n  }\n\n  private onRealtimeDisconnect_() {\n    this.log_('data client disconnected');\n    this.connected_ = false;\n    this.realtime_ = null;\n\n    // Since we don't know if our sent transactions succeeded or not, we need to cancel them.\n    this.cancelSentTransactions_();\n\n    // Clear out the pending requests.\n    this.requestCBHash_ = {};\n\n    if (this.shouldReconnect_()) {\n      if (!this.visible_) {\n        this.log_(\"Window isn't visible.  Delaying reconnect.\");\n        this.reconnectDelay_ = this.maxReconnectDelay_;\n        this.lastConnectionAttemptTime_ = new Date().getTime();\n      } else if (this.lastConnectionEstablishedTime_) {\n        // If we've been connected long enough, reset reconnect delay to minimum.\n        const timeSinceLastConnectSucceeded =\n          new Date().getTime() - this.lastConnectionEstablishedTime_;\n        if (timeSinceLastConnectSucceeded > RECONNECT_DELAY_RESET_TIMEOUT)\n          this.reconnectDelay_ = RECONNECT_MIN_DELAY;\n        this.lastConnectionEstablishedTime_ = null;\n      }\n\n      const timeSinceLastConnectAttempt =\n        new Date().getTime() - this.lastConnectionAttemptTime_;\n      let reconnectDelay = Math.max(\n        0,\n        this.reconnectDelay_ - timeSinceLastConnectAttempt\n      );\n      reconnectDelay = Math.random() * reconnectDelay;\n\n      this.log_('Trying to reconnect in ' + reconnectDelay + 'ms');\n      this.scheduleConnect_(reconnectDelay);\n\n      // Adjust reconnect delay for next time.\n      this.reconnectDelay_ = Math.min(\n        this.maxReconnectDelay_,\n        this.reconnectDelay_ * RECONNECT_DELAY_MULTIPLIER\n      );\n    }\n    this.onConnectStatus_(false);\n  }\n\n  private establishConnection_() {\n    if (this.shouldReconnect_()) {\n      this.log_('Making a connection attempt');\n      this.lastConnectionAttemptTime_ = new Date().getTime();\n      this.lastConnectionEstablishedTime_ = null;\n      const onDataMessage = this.onDataMessage_.bind(this);\n      const onReady = this.onReady_.bind(this);\n      const onDisconnect = this.onRealtimeDisconnect_.bind(this);\n      const connId = this.id + ':' + PersistentConnection.nextConnectionId_++;\n      const self = this;\n      const lastSessionId = this.lastSessionId;\n      let canceled = false;\n      let connection: Connection | null = null;\n      const closeFn = function() {\n        if (connection) {\n          connection.close();\n        } else {\n          canceled = true;\n          onDisconnect();\n        }\n      };\n      const sendRequestFn = function(msg: Object) {\n        assert(\n          connection,\n          \"sendRequest call when we're not connected not allowed.\"\n        );\n        connection.sendRequest(msg);\n      };\n\n      this.realtime_ = {\n        close: closeFn,\n        sendRequest: sendRequestFn\n      };\n\n      const forceRefresh = this.forceTokenRefresh_;\n      this.forceTokenRefresh_ = false;\n\n      // First fetch auth token, and establish connection after fetching the token was successful\n      this.authTokenProvider_\n        .getToken(forceRefresh)\n        .then(function(result) {\n          if (!canceled) {\n            log('getToken() completed. Creating connection.');\n            self.authToken_ = result && result.accessToken;\n            connection = new Connection(\n              connId,\n              self.repoInfo_,\n              onDataMessage,\n              onReady,\n              onDisconnect,\n              /* onKill= */ function(reason) {\n                warn(reason + ' (' + self.repoInfo_.toString() + ')');\n                self.interrupt(SERVER_KILL_INTERRUPT_REASON);\n              },\n              lastSessionId\n            );\n          } else {\n            log('getToken() completed but was canceled');\n          }\n        })\n        .then(null, function(error) {\n          self.log_('Failed to get token: ' + error);\n          if (!canceled) {\n            if (CONSTANTS.NODE_ADMIN) {\n              // This may be a critical error for the Admin Node.js SDK, so log a warning.\n              // But getToken() may also just have temporarily failed, so we still want to\n              // continue retrying.\n              warn(error);\n            }\n            closeFn();\n          }\n        });\n    }\n  }\n\n  /**\n   * @param {string} reason\n   */\n  interrupt(reason: string) {\n    log('Interrupting connection for reason: ' + reason);\n    this.interruptReasons_[reason] = true;\n    if (this.realtime_) {\n      this.realtime_.close();\n    } else {\n      if (this.establishConnectionTimer_) {\n        clearTimeout(this.establishConnectionTimer_);\n        this.establishConnectionTimer_ = null;\n      }\n      if (this.connected_) {\n        this.onRealtimeDisconnect_();\n      }\n    }\n  }\n\n  /**\n   * @param {string} reason\n   */\n  resume(reason: string) {\n    log('Resuming connection for reason: ' + reason);\n    delete this.interruptReasons_[reason];\n    if (isEmpty(this.interruptReasons_)) {\n      this.reconnectDelay_ = RECONNECT_MIN_DELAY;\n      if (!this.realtime_) {\n        this.scheduleConnect_(0);\n      }\n    }\n  }\n\n  private handleTimestamp_(timestamp: number) {\n    const delta = timestamp - new Date().getTime();\n    this.onServerInfoUpdate_({ serverTimeOffset: delta });\n  }\n\n  private cancelSentTransactions_() {\n    for (let i = 0; i < this.outstandingPuts_.length; i++) {\n      const put = this.outstandingPuts_[i];\n      if (put && /*hash*/ 'h' in put.request && put.queued) {\n        if (put.onComplete) put.onComplete('disconnect');\n\n        delete this.outstandingPuts_[i];\n        this.outstandingPutCount_--;\n      }\n    }\n\n    // Clean up array occasionally.\n    if (this.outstandingPutCount_ === 0) this.outstandingPuts_ = [];\n  }\n\n  /**\n   * @param {!string} pathString\n   * @param {Array.<*>=} query\n   * @private\n   */\n  private onListenRevoked_(pathString: string, query?: any[]) {\n    // Remove the listen and manufacture a \"permission_denied\" error for the failed listen.\n    let queryId;\n    if (!query) {\n      queryId = 'default';\n    } else {\n      queryId = query.map(q => ObjectToUniqueKey(q)).join('$');\n    }\n    const listen = this.removeListen_(pathString, queryId);\n    if (listen && listen.onComplete) listen.onComplete('permission_denied');\n  }\n\n  /**\n   * @param {!string} pathString\n   * @param {!string} queryId\n   * @return {{queries:Array.<Query>, onComplete:function(string)}}\n   * @private\n   */\n  private removeListen_(pathString: string, queryId: string): ListenSpec {\n    const normalizedPathString = new Path(pathString).toString(); // normalize path.\n    let listen;\n    if (this.listens_[normalizedPathString] !== undefined) {\n      listen = this.listens_[normalizedPathString][queryId];\n      delete this.listens_[normalizedPathString][queryId];\n      if (getCount(this.listens_[normalizedPathString]) === 0) {\n        delete this.listens_[normalizedPathString];\n      }\n    } else {\n      // all listens for this path has already been removed\n      listen = undefined;\n    }\n    return listen;\n  }\n\n  private onAuthRevoked_(statusCode: string, explanation: string) {\n    log('Auth token revoked: ' + statusCode + '/' + explanation);\n    this.authToken_ = null;\n    this.forceTokenRefresh_ = true;\n    this.realtime_.close();\n    if (statusCode === 'invalid_token' || statusCode === 'permission_denied') {\n      // We'll wait a couple times before logging the warning / increasing the\n      // retry period since oauth tokens will report as \"invalid\" if they're\n      // just expired. Plus there may be transient issues that resolve themselves.\n      this.invalidAuthTokenCount_++;\n      if (this.invalidAuthTokenCount_ >= INVALID_AUTH_TOKEN_THRESHOLD) {\n        // Set a long reconnect delay because recovery is unlikely\n        this.reconnectDelay_ = RECONNECT_MAX_DELAY_FOR_ADMINS;\n\n        // Notify the auth token provider that the token is invalid, which will log\n        // a warning\n        this.authTokenProvider_.notifyForInvalidToken();\n      }\n    }\n  }\n\n  private onSecurityDebugPacket_(body: { [k: string]: any }) {\n    if (this.securityDebugCallback_) {\n      this.securityDebugCallback_(body);\n    } else {\n      if ('msg' in body && typeof console !== 'undefined') {\n        console.log('FIREBASE: ' + body['msg'].replace('\\n', '\\nFIREBASE: '));\n      }\n    }\n  }\n\n  private restoreState_() {\n    //Re-authenticate ourselves if we have a credential stored.\n    this.tryAuth();\n\n    // Puts depend on having received the corresponding data update from the server before they complete, so we must\n    // make sure to send listens before puts.\n    forEach(this.listens_, (pathString: string, queries: Object) => {\n      forEach(queries, (key: string, listenSpec: ListenSpec) => {\n        this.sendListen_(listenSpec);\n      });\n    });\n\n    for (let i = 0; i < this.outstandingPuts_.length; i++) {\n      if (this.outstandingPuts_[i]) this.sendPut_(i);\n    }\n\n    while (this.onDisconnectRequestQueue_.length) {\n      const request = this.onDisconnectRequestQueue_.shift();\n      this.sendOnDisconnect_(\n        request.action,\n        request.pathString,\n        request.data,\n        request.onComplete\n      );\n    }\n  }\n\n  /**\n   * Sends client stats for first connection\n   * @private\n   */\n  private sendConnectStats_() {\n    const stats: { [k: string]: number } = {};\n\n    let clientName = 'js';\n    if (CONSTANTS.NODE_ADMIN) {\n      clientName = 'admin_node';\n    } else if (CONSTANTS.NODE_CLIENT) {\n      clientName = 'node';\n    }\n\n    stats[\n      'sdk.' + clientName + '.' + firebase.SDK_VERSION.replace(/\\./g, '-')\n    ] = 1;\n\n    if (isMobileCordova()) {\n      stats['framework.cordova'] = 1;\n    } else if (isReactNative()) {\n      stats['framework.reactnative'] = 1;\n    }\n    this.reportStats(stats);\n  }\n\n  /**\n   * @return {boolean}\n   * @private\n   */\n  private shouldReconnect_(): boolean {\n    const online = OnlineMonitor.getInstance().currentlyOnline();\n    return isEmpty(this.interruptReasons_) && online;\n  }\n}\n","/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport firebase from '../../app';\nimport { forEach, contains, isEmpty, getCount, safeGet } from '../../utils/obj';\nimport { stringify } from '../../utils/json';\nimport { assert } from '../../utils/assert';\nimport { error, log, logWrapper, warn, ObjectToUniqueKey } from './util/util';\nimport { Path } from './util/Path';\nimport { VisibilityMonitor } from './util/VisibilityMonitor';\nimport { OnlineMonitor } from './util/OnlineMonitor';\nimport { isAdmin, isValidFormat } from '../../utils/jwt';\nimport { Connection } from '../realtime/Connection';\nimport { CONSTANTS } from '../../utils/constants';\nimport { isMobileCordova, isReactNative, isNodeSdk } from '../../utils/environment';\nimport { ServerActions } from './ServerActions';\nvar RECONNECT_MIN_DELAY = 1000;\nvar RECONNECT_MAX_DELAY_DEFAULT = 60 * 5 * 1000; // 5 minutes in milliseconds (Case: 1858)\nvar RECONNECT_MAX_DELAY_FOR_ADMINS = 30 * 1000; // 30 seconds for admin clients (likely to be a backend server)\nvar RECONNECT_DELAY_MULTIPLIER = 1.3;\nvar RECONNECT_DELAY_RESET_TIMEOUT = 30000; // Reset delay back to MIN_DELAY after being connected for 30sec.\nvar SERVER_KILL_INTERRUPT_REASON = 'server_kill';\n// If auth fails repeatedly, we'll assume something is wrong and log a warning / back off.\nvar INVALID_AUTH_TOKEN_THRESHOLD = 3;\n/**\n * Firebase connection.  Abstracts wire protocol and handles reconnecting.\n *\n * NOTE: All JSON objects sent to the realtime connection must have property names enclosed\n * in quotes to make sure the closure compiler does not minify them.\n */\nvar PersistentConnection = (function (_super) {\n    __extends(PersistentConnection, _super);\n    /**\n     * @implements {ServerActions}\n     * @param {!RepoInfo} repoInfo_ Data about the namespace we are connecting to\n     * @param {function(string, *, boolean, ?number)} onDataUpdate_ A callback for new data from the server\n     * @param onConnectStatus_\n     * @param onServerInfoUpdate_\n     * @param authTokenProvider_\n     * @param authOverride_\n     */\n    function PersistentConnection(repoInfo_, onDataUpdate_, onConnectStatus_, onServerInfoUpdate_, authTokenProvider_, authOverride_) {\n        var _this = _super.call(this) || this;\n        _this.repoInfo_ = repoInfo_;\n        _this.onDataUpdate_ = onDataUpdate_;\n        _this.onConnectStatus_ = onConnectStatus_;\n        _this.onServerInfoUpdate_ = onServerInfoUpdate_;\n        _this.authTokenProvider_ = authTokenProvider_;\n        _this.authOverride_ = authOverride_;\n        // Used for diagnostic logging.\n        _this.id = PersistentConnection.nextPersistentConnectionId_++;\n        _this.log_ = logWrapper('p:' + _this.id + ':');\n        /** @private {Object} */\n        _this.interruptReasons_ = {};\n        _this.listens_ = {};\n        _this.outstandingPuts_ = [];\n        _this.outstandingPutCount_ = 0;\n        _this.onDisconnectRequestQueue_ = [];\n        _this.connected_ = false;\n        _this.reconnectDelay_ = RECONNECT_MIN_DELAY;\n        _this.maxReconnectDelay_ = RECONNECT_MAX_DELAY_DEFAULT;\n        _this.securityDebugCallback_ = null;\n        _this.lastSessionId = null;\n        /** @private {number|null} */\n        _this.establishConnectionTimer_ = null;\n        /** @private {boolean} */\n        _this.visible_ = false;\n        // Before we get connected, we keep a queue of pending messages to send.\n        _this.requestCBHash_ = {};\n        _this.requestNumber_ = 0;\n        /** @private {?{\n         *   sendRequest(Object),\n         *   close()\n         * }} */\n        _this.realtime_ = null;\n        /** @private {string|null} */\n        _this.authToken_ = null;\n        _this.forceTokenRefresh_ = false;\n        _this.invalidAuthTokenCount_ = 0;\n        _this.firstConnection_ = true;\n        _this.lastConnectionAttemptTime_ = null;\n        _this.lastConnectionEstablishedTime_ = null;\n        if (authOverride_ && !isNodeSdk()) {\n            throw new Error('Auth override specified in options, but not supported on non Node.js platforms');\n        }\n        _this.scheduleConnect_(0);\n        VisibilityMonitor.getInstance().on('visible', _this.onVisible_, _this);\n        if (repoInfo_.host.indexOf('fblocal') === -1) {\n            OnlineMonitor.getInstance().on('online', _this.onOnline_, _this);\n        }\n        return _this;\n    }\n    /**\n     * @param {!string} action\n     * @param {*} body\n     * @param {function(*)=} onResponse\n     * @protected\n     */\n    PersistentConnection.prototype.sendRequest = function (action, body, onResponse) {\n        var curReqNum = ++this.requestNumber_;\n        var msg = { r: curReqNum, a: action, b: body };\n        this.log_(stringify(msg));\n        assert(this.connected_, \"sendRequest call when we're not connected not allowed.\");\n        this.realtime_.sendRequest(msg);\n        if (onResponse) {\n            this.requestCBHash_[curReqNum] = onResponse;\n        }\n    };\n    /**\n     * @inheritDoc\n     */\n    PersistentConnection.prototype.listen = function (query, currentHashFn, tag, onComplete) {\n        var queryId = query.queryIdentifier();\n        var pathString = query.path.toString();\n        this.log_('Listen called for ' + pathString + ' ' + queryId);\n        this.listens_[pathString] = this.listens_[pathString] || {};\n        assert(query.getQueryParams().isDefault() ||\n            !query.getQueryParams().loadsAllData(), 'listen() called for non-default but complete query');\n        assert(!this.listens_[pathString][queryId], 'listen() called twice for same path/queryId.');\n        var listenSpec = {\n            onComplete: onComplete,\n            hashFn: currentHashFn,\n            query: query,\n            tag: tag\n        };\n        this.listens_[pathString][queryId] = listenSpec;\n        if (this.connected_) {\n            this.sendListen_(listenSpec);\n        }\n    };\n    /**\n     * @param {!{onComplete(),\n     *           hashFn():!string,\n     *           query: !Query,\n     *           tag: ?number}} listenSpec\n     * @private\n     */\n    PersistentConnection.prototype.sendListen_ = function (listenSpec) {\n        var _this = this;\n        var query = listenSpec.query;\n        var pathString = query.path.toString();\n        var queryId = query.queryIdentifier();\n        this.log_('Listen on ' + pathString + ' for ' + queryId);\n        var req = { /*path*/ p: pathString };\n        var action = 'q';\n        // Only bother to send query if it's non-default.\n        if (listenSpec.tag) {\n            req['q'] = query.queryObject();\n            req['t'] = listenSpec.tag;\n        }\n        req['h'] = listenSpec.hashFn();\n        this.sendRequest(action, req, function (message) {\n            var payload = message['d'];\n            var status = message['s'];\n            // print warnings in any case...\n            PersistentConnection.warnOnListenWarnings_(payload, query);\n            var currentListenSpec = _this.listens_[pathString] && _this.listens_[pathString][queryId];\n            // only trigger actions if the listen hasn't been removed and readded\n            if (currentListenSpec === listenSpec) {\n                _this.log_('listen response', message);\n                if (status !== 'ok') {\n                    _this.removeListen_(pathString, queryId);\n                }\n                if (listenSpec.onComplete) {\n                    listenSpec.onComplete(status, payload);\n                }\n            }\n        });\n    };\n    /**\n     * @param {*} payload\n     * @param {!Query} query\n     * @private\n     */\n    PersistentConnection.warnOnListenWarnings_ = function (payload, query) {\n        if (payload && typeof payload === 'object' && contains(payload, 'w')) {\n            var warnings = safeGet(payload, 'w');\n            if (Array.isArray(warnings) && ~warnings.indexOf('no_index')) {\n                var indexSpec = '\".indexOn\": \"' + query.getQueryParams().getIndex().toString() + '\"';\n                var indexPath = query.path.toString();\n                warn(\"Using an unspecified index. Your data will be downloaded and \" +\n                    (\"filtered on the client. Consider adding \" + indexSpec + \" at \") +\n                    (indexPath + \" to your security rules for better performance.\"));\n            }\n        }\n    };\n    /**\n     * @inheritDoc\n     */\n    PersistentConnection.prototype.refreshAuthToken = function (token) {\n        this.authToken_ = token;\n        this.log_('Auth token refreshed');\n        if (this.authToken_) {\n            this.tryAuth();\n        }\n        else {\n            //If we're connected we want to let the server know to unauthenticate us. If we're not connected, simply delete\n            //the credential so we dont become authenticated next time we connect.\n            if (this.connected_) {\n                this.sendRequest('unauth', {}, function () { });\n            }\n        }\n        this.reduceReconnectDelayIfAdminCredential_(token);\n    };\n    /**\n     * @param {!string} credential\n     * @private\n     */\n    PersistentConnection.prototype.reduceReconnectDelayIfAdminCredential_ = function (credential) {\n        // NOTE: This isn't intended to be bulletproof (a malicious developer can always just modify the client).\n        // Additionally, we don't bother resetting the max delay back to the default if auth fails / expires.\n        var isFirebaseSecret = credential && credential.length === 40;\n        if (isFirebaseSecret || isAdmin(credential)) {\n            this.log_('Admin auth credential detected.  Reducing max reconnect time.');\n            this.maxReconnectDelay_ = RECONNECT_MAX_DELAY_FOR_ADMINS;\n        }\n    };\n    /**\n     * Attempts to authenticate with the given credentials. If the authentication attempt fails, it's triggered like\n     * a auth revoked (the connection is closed).\n     */\n    PersistentConnection.prototype.tryAuth = function () {\n        var _this = this;\n        if (this.connected_ && this.authToken_) {\n            var token_1 = this.authToken_;\n            var authMethod = isValidFormat(token_1) ? 'auth' : 'gauth';\n            var requestData = { cred: token_1 };\n            if (this.authOverride_ === null) {\n                requestData['noauth'] = true;\n            }\n            else if (typeof this.authOverride_ === 'object') {\n                requestData['authvar'] = this.authOverride_;\n            }\n            this.sendRequest(authMethod, requestData, function (res) {\n                var status = res['s'];\n                var data = res['d'] || 'error';\n                if (_this.authToken_ === token_1) {\n                    if (status === 'ok') {\n                        _this.invalidAuthTokenCount_ = 0;\n                    }\n                    else {\n                        // Triggers reconnect and force refresh for auth token\n                        _this.onAuthRevoked_(status, data);\n                    }\n                }\n            });\n        }\n    };\n    /**\n     * @inheritDoc\n     */\n    PersistentConnection.prototype.unlisten = function (query, tag) {\n        var pathString = query.path.toString();\n        var queryId = query.queryIdentifier();\n        this.log_('Unlisten called for ' + pathString + ' ' + queryId);\n        assert(query.getQueryParams().isDefault() ||\n            !query.getQueryParams().loadsAllData(), 'unlisten() called for non-default but complete query');\n        var listen = this.removeListen_(pathString, queryId);\n        if (listen && this.connected_) {\n            this.sendUnlisten_(pathString, queryId, query.queryObject(), tag);\n        }\n    };\n    PersistentConnection.prototype.sendUnlisten_ = function (pathString, queryId, queryObj, tag) {\n        this.log_('Unlisten on ' + pathString + ' for ' + queryId);\n        var req = { /*path*/ p: pathString };\n        var action = 'n';\n        // Only bother sending queryId if it's non-default.\n        if (tag) {\n            req['q'] = queryObj;\n            req['t'] = tag;\n        }\n        this.sendRequest(action, req);\n    };\n    /**\n     * @inheritDoc\n     */\n    PersistentConnection.prototype.onDisconnectPut = function (pathString, data, onComplete) {\n        if (this.connected_) {\n            this.sendOnDisconnect_('o', pathString, data, onComplete);\n        }\n        else {\n            this.onDisconnectRequestQueue_.push({\n                pathString: pathString,\n                action: 'o',\n                data: data,\n                onComplete: onComplete\n            });\n        }\n    };\n    /**\n     * @inheritDoc\n     */\n    PersistentConnection.prototype.onDisconnectMerge = function (pathString, data, onComplete) {\n        if (this.connected_) {\n            this.sendOnDisconnect_('om', pathString, data, onComplete);\n        }\n        else {\n            this.onDisconnectRequestQueue_.push({\n                pathString: pathString,\n                action: 'om',\n                data: data,\n                onComplete: onComplete\n            });\n        }\n    };\n    /**\n     * @inheritDoc\n     */\n    PersistentConnection.prototype.onDisconnectCancel = function (pathString, onComplete) {\n        if (this.connected_) {\n            this.sendOnDisconnect_('oc', pathString, null, onComplete);\n        }\n        else {\n            this.onDisconnectRequestQueue_.push({\n                pathString: pathString,\n                action: 'oc',\n                data: null,\n                onComplete: onComplete\n            });\n        }\n    };\n    PersistentConnection.prototype.sendOnDisconnect_ = function (action, pathString, data, onComplete) {\n        var request = { /*path*/ p: pathString, /*data*/ d: data };\n        this.log_('onDisconnect ' + action, request);\n        this.sendRequest(action, request, function (response) {\n            if (onComplete) {\n                setTimeout(function () {\n                    onComplete(response['s'], response['d']);\n                }, Math.floor(0));\n            }\n        });\n    };\n    /**\n     * @inheritDoc\n     */\n    PersistentConnection.prototype.put = function (pathString, data, onComplete, hash) {\n        this.putInternal('p', pathString, data, onComplete, hash);\n    };\n    /**\n     * @inheritDoc\n     */\n    PersistentConnection.prototype.merge = function (pathString, data, onComplete, hash) {\n        this.putInternal('m', pathString, data, onComplete, hash);\n    };\n    PersistentConnection.prototype.putInternal = function (action, pathString, data, onComplete, hash) {\n        var request = {\n            /*path*/ p: pathString,\n            /*data*/ d: data\n        };\n        if (hash !== undefined)\n            request['h'] = hash;\n        // TODO: Only keep track of the most recent put for a given path?\n        this.outstandingPuts_.push({\n            action: action,\n            request: request,\n            onComplete: onComplete\n        });\n        this.outstandingPutCount_++;\n        var index = this.outstandingPuts_.length - 1;\n        if (this.connected_) {\n            this.sendPut_(index);\n        }\n        else {\n            this.log_('Buffering put: ' + pathString);\n        }\n    };\n    PersistentConnection.prototype.sendPut_ = function (index) {\n        var _this = this;\n        var action = this.outstandingPuts_[index].action;\n        var request = this.outstandingPuts_[index].request;\n        var onComplete = this.outstandingPuts_[index].onComplete;\n        this.outstandingPuts_[index].queued = this.connected_;\n        this.sendRequest(action, request, function (message) {\n            _this.log_(action + ' response', message);\n            delete _this.outstandingPuts_[index];\n            _this.outstandingPutCount_--;\n            // Clean up array occasionally.\n            if (_this.outstandingPutCount_ === 0) {\n                _this.outstandingPuts_ = [];\n            }\n            if (onComplete)\n                onComplete(message['s'], message['d']);\n        });\n    };\n    /**\n     * @inheritDoc\n     */\n    PersistentConnection.prototype.reportStats = function (stats) {\n        var _this = this;\n        // If we're not connected, we just drop the stats.\n        if (this.connected_) {\n            var request = { /*counters*/ c: stats };\n            this.log_('reportStats', request);\n            this.sendRequest(/*stats*/ 's', request, function (result) {\n                var status = result['s'];\n                if (status !== 'ok') {\n                    var errorReason = result['d'];\n                    _this.log_('reportStats', 'Error sending stats: ' + errorReason);\n                }\n            });\n        }\n    };\n    /**\n     * @param {*} message\n     * @private\n     */\n    PersistentConnection.prototype.onDataMessage_ = function (message) {\n        if ('r' in message) {\n            // this is a response\n            this.log_('from server: ' + stringify(message));\n            var reqNum = message['r'];\n            var onResponse = this.requestCBHash_[reqNum];\n            if (onResponse) {\n                delete this.requestCBHash_[reqNum];\n                onResponse(message['b']);\n            }\n        }\n        else if ('error' in message) {\n            throw 'A server-side error has occurred: ' + message['error'];\n        }\n        else if ('a' in message) {\n            // a and b are action and body, respectively\n            this.onDataPush_(message['a'], message['b']);\n        }\n    };\n    PersistentConnection.prototype.onDataPush_ = function (action, body) {\n        this.log_('handleServerMessage', action, body);\n        if (action === 'd')\n            this.onDataUpdate_(body['p'], body['d'], \n            /*isMerge*/ false, body['t']);\n        else if (action === 'm')\n            this.onDataUpdate_(body['p'], body['d'], \n            /*isMerge=*/ true, body['t']);\n        else if (action === 'c')\n            this.onListenRevoked_(body['p'], body['q']);\n        else if (action === 'ac')\n            this.onAuthRevoked_(body['s'], body['d']);\n        else if (action === 'sd')\n            this.onSecurityDebugPacket_(body);\n        else\n            error('Unrecognized action received from server: ' +\n                stringify(action) +\n                '\\nAre you using the latest client?');\n    };\n    PersistentConnection.prototype.onReady_ = function (timestamp, sessionId) {\n        this.log_('connection ready');\n        this.connected_ = true;\n        this.lastConnectionEstablishedTime_ = new Date().getTime();\n        this.handleTimestamp_(timestamp);\n        this.lastSessionId = sessionId;\n        if (this.firstConnection_) {\n            this.sendConnectStats_();\n        }\n        this.restoreState_();\n        this.firstConnection_ = false;\n        this.onConnectStatus_(true);\n    };\n    PersistentConnection.prototype.scheduleConnect_ = function (timeout) {\n        var _this = this;\n        assert(!this.realtime_, \"Scheduling a connect when we're already connected/ing?\");\n        if (this.establishConnectionTimer_) {\n            clearTimeout(this.establishConnectionTimer_);\n        }\n        // NOTE: Even when timeout is 0, it's important to do a setTimeout to work around an infuriating \"Security Error\" in\n        // Firefox when trying to write to our long-polling iframe in some scenarios (e.g. Forge or our unit tests).\n        this.establishConnectionTimer_ = setTimeout(function () {\n            _this.establishConnectionTimer_ = null;\n            _this.establishConnection_();\n        }, Math.floor(timeout));\n    };\n    /**\n     * @param {boolean} visible\n     * @private\n     */\n    PersistentConnection.prototype.onVisible_ = function (visible) {\n        // NOTE: Tabbing away and back to a window will defeat our reconnect backoff, but I think that's fine.\n        if (visible &&\n            !this.visible_ &&\n            this.reconnectDelay_ === this.maxReconnectDelay_) {\n            this.log_('Window became visible.  Reducing delay.');\n            this.reconnectDelay_ = RECONNECT_MIN_DELAY;\n            if (!this.realtime_) {\n                this.scheduleConnect_(0);\n            }\n        }\n        this.visible_ = visible;\n    };\n    PersistentConnection.prototype.onOnline_ = function (online) {\n        if (online) {\n            this.log_('Browser went online.');\n            this.reconnectDelay_ = RECONNECT_MIN_DELAY;\n            if (!this.realtime_) {\n                this.scheduleConnect_(0);\n            }\n        }\n        else {\n            this.log_('Browser went offline.  Killing connection.');\n            if (this.realtime_) {\n                this.realtime_.close();\n            }\n        }\n    };\n    PersistentConnection.prototype.onRealtimeDisconnect_ = function () {\n        this.log_('data client disconnected');\n        this.connected_ = false;\n        this.realtime_ = null;\n        // Since we don't know if our sent transactions succeeded or not, we need to cancel them.\n        this.cancelSentTransactions_();\n        // Clear out the pending requests.\n        this.requestCBHash_ = {};\n        if (this.shouldReconnect_()) {\n            if (!this.visible_) {\n                this.log_(\"Window isn't visible.  Delaying reconnect.\");\n                this.reconnectDelay_ = this.maxReconnectDelay_;\n                this.lastConnectionAttemptTime_ = new Date().getTime();\n            }\n            else if (this.lastConnectionEstablishedTime_) {\n                // If we've been connected long enough, reset reconnect delay to minimum.\n                var timeSinceLastConnectSucceeded = new Date().getTime() - this.lastConnectionEstablishedTime_;\n                if (timeSinceLastConnectSucceeded > RECONNECT_DELAY_RESET_TIMEOUT)\n                    this.reconnectDelay_ = RECONNECT_MIN_DELAY;\n                this.lastConnectionEstablishedTime_ = null;\n            }\n            var timeSinceLastConnectAttempt = new Date().getTime() - this.lastConnectionAttemptTime_;\n            var reconnectDelay = Math.max(0, this.reconnectDelay_ - timeSinceLastConnectAttempt);\n            reconnectDelay = Math.random() * reconnectDelay;\n            this.log_('Trying to reconnect in ' + reconnectDelay + 'ms');\n            this.scheduleConnect_(reconnectDelay);\n            // Adjust reconnect delay for next time.\n            this.reconnectDelay_ = Math.min(this.maxReconnectDelay_, this.reconnectDelay_ * RECONNECT_DELAY_MULTIPLIER);\n        }\n        this.onConnectStatus_(false);\n    };\n    PersistentConnection.prototype.establishConnection_ = function () {\n        if (this.shouldReconnect_()) {\n            this.log_('Making a connection attempt');\n            this.lastConnectionAttemptTime_ = new Date().getTime();\n            this.lastConnectionEstablishedTime_ = null;\n            var onDataMessage_1 = this.onDataMessage_.bind(this);\n            var onReady_1 = this.onReady_.bind(this);\n            var onDisconnect_1 = this.onRealtimeDisconnect_.bind(this);\n            var connId_1 = this.id + ':' + PersistentConnection.nextConnectionId_++;\n            var self_1 = this;\n            var lastSessionId_1 = this.lastSessionId;\n            var canceled_1 = false;\n            var connection_1 = null;\n            var closeFn_1 = function () {\n                if (connection_1) {\n                    connection_1.close();\n                }\n                else {\n                    canceled_1 = true;\n                    onDisconnect_1();\n                }\n            };\n            var sendRequestFn = function (msg) {\n                assert(connection_1, \"sendRequest call when we're not connected not allowed.\");\n                connection_1.sendRequest(msg);\n            };\n            this.realtime_ = {\n                close: closeFn_1,\n                sendRequest: sendRequestFn\n            };\n            var forceRefresh = this.forceTokenRefresh_;\n            this.forceTokenRefresh_ = false;\n            // First fetch auth token, and establish connection after fetching the token was successful\n            this.authTokenProvider_\n                .getToken(forceRefresh)\n                .then(function (result) {\n                if (!canceled_1) {\n                    log('getToken() completed. Creating connection.');\n                    self_1.authToken_ = result && result.accessToken;\n                    connection_1 = new Connection(connId_1, self_1.repoInfo_, onDataMessage_1, onReady_1, onDisconnect_1, \n                    /* onKill= */ function (reason) {\n                        warn(reason + ' (' + self_1.repoInfo_.toString() + ')');\n                        self_1.interrupt(SERVER_KILL_INTERRUPT_REASON);\n                    }, lastSessionId_1);\n                }\n                else {\n                    log('getToken() completed but was canceled');\n                }\n            })\n                .then(null, function (error) {\n                self_1.log_('Failed to get token: ' + error);\n                if (!canceled_1) {\n                    if (CONSTANTS.NODE_ADMIN) {\n                        // This may be a critical error for the Admin Node.js SDK, so log a warning.\n                        // But getToken() may also just have temporarily failed, so we still want to\n                        // continue retrying.\n                        warn(error);\n                    }\n                    closeFn_1();\n                }\n            });\n        }\n    };\n    /**\n     * @param {string} reason\n     */\n    PersistentConnection.prototype.interrupt = function (reason) {\n        log('Interrupting connection for reason: ' + reason);\n        this.interruptReasons_[reason] = true;\n        if (this.realtime_) {\n            this.realtime_.close();\n        }\n        else {\n            if (this.establishConnectionTimer_) {\n                clearTimeout(this.establishConnectionTimer_);\n                this.establishConnectionTimer_ = null;\n            }\n            if (this.connected_) {\n                this.onRealtimeDisconnect_();\n            }\n        }\n    };\n    /**\n     * @param {string} reason\n     */\n    PersistentConnection.prototype.resume = function (reason) {\n        log('Resuming connection for reason: ' + reason);\n        delete this.interruptReasons_[reason];\n        if (isEmpty(this.interruptReasons_)) {\n            this.reconnectDelay_ = RECONNECT_MIN_DELAY;\n            if (!this.realtime_) {\n                this.scheduleConnect_(0);\n            }\n        }\n    };\n    PersistentConnection.prototype.handleTimestamp_ = function (timestamp) {\n        var delta = timestamp - new Date().getTime();\n        this.onServerInfoUpdate_({ serverTimeOffset: delta });\n    };\n    PersistentConnection.prototype.cancelSentTransactions_ = function () {\n        for (var i = 0; i < this.outstandingPuts_.length; i++) {\n            var put = this.outstandingPuts_[i];\n            if (put && 'h' in put.request && put.queued) {\n                if (put.onComplete)\n                    put.onComplete('disconnect');\n                delete this.outstandingPuts_[i];\n                this.outstandingPutCount_--;\n            }\n        }\n        // Clean up array occasionally.\n        if (this.outstandingPutCount_ === 0)\n            this.outstandingPuts_ = [];\n    };\n    /**\n     * @param {!string} pathString\n     * @param {Array.<*>=} query\n     * @private\n     */\n    PersistentConnection.prototype.onListenRevoked_ = function (pathString, query) {\n        // Remove the listen and manufacture a \"permission_denied\" error for the failed listen.\n        var queryId;\n        if (!query) {\n            queryId = 'default';\n        }\n        else {\n            queryId = query.map(function (q) { return ObjectToUniqueKey(q); }).join('$');\n        }\n        var listen = this.removeListen_(pathString, queryId);\n        if (listen && listen.onComplete)\n            listen.onComplete('permission_denied');\n    };\n    /**\n     * @param {!string} pathString\n     * @param {!string} queryId\n     * @return {{queries:Array.<Query>, onComplete:function(string)}}\n     * @private\n     */\n    PersistentConnection.prototype.removeListen_ = function (pathString, queryId) {\n        var normalizedPathString = new Path(pathString).toString(); // normalize path.\n        var listen;\n        if (this.listens_[normalizedPathString] !== undefined) {\n            listen = this.listens_[normalizedPathString][queryId];\n            delete this.listens_[normalizedPathString][queryId];\n            if (getCount(this.listens_[normalizedPathString]) === 0) {\n                delete this.listens_[normalizedPathString];\n            }\n        }\n        else {\n            // all listens for this path has already been removed\n            listen = undefined;\n        }\n        return listen;\n    };\n    PersistentConnection.prototype.onAuthRevoked_ = function (statusCode, explanation) {\n        log('Auth token revoked: ' + statusCode + '/' + explanation);\n        this.authToken_ = null;\n        this.forceTokenRefresh_ = true;\n        this.realtime_.close();\n        if (statusCode === 'invalid_token' || statusCode === 'permission_denied') {\n            // We'll wait a couple times before logging the warning / increasing the\n            // retry period since oauth tokens will report as \"invalid\" if they're\n            // just expired. Plus there may be transient issues that resolve themselves.\n            this.invalidAuthTokenCount_++;\n            if (this.invalidAuthTokenCount_ >= INVALID_AUTH_TOKEN_THRESHOLD) {\n                // Set a long reconnect delay because recovery is unlikely\n                this.reconnectDelay_ = RECONNECT_MAX_DELAY_FOR_ADMINS;\n                // Notify the auth token provider that the token is invalid, which will log\n                // a warning\n                this.authTokenProvider_.notifyForInvalidToken();\n            }\n        }\n    };\n    PersistentConnection.prototype.onSecurityDebugPacket_ = function (body) {\n        if (this.securityDebugCallback_) {\n            this.securityDebugCallback_(body);\n        }\n        else {\n            if ('msg' in body && typeof console !== 'undefined') {\n                console.log('FIREBASE: ' + body['msg'].replace('\\n', '\\nFIREBASE: '));\n            }\n        }\n    };\n    PersistentConnection.prototype.restoreState_ = function () {\n        var _this = this;\n        //Re-authenticate ourselves if we have a credential stored.\n        this.tryAuth();\n        // Puts depend on having received the corresponding data update from the server before they complete, so we must\n        // make sure to send listens before puts.\n        forEach(this.listens_, function (pathString, queries) {\n            forEach(queries, function (key, listenSpec) {\n                _this.sendListen_(listenSpec);\n            });\n        });\n        for (var i = 0; i < this.outstandingPuts_.length; i++) {\n            if (this.outstandingPuts_[i])\n                this.sendPut_(i);\n        }\n        while (this.onDisconnectRequestQueue_.length) {\n            var request = this.onDisconnectRequestQueue_.shift();\n            this.sendOnDisconnect_(request.action, request.pathString, request.data, request.onComplete);\n        }\n    };\n    /**\n     * Sends client stats for first connection\n     * @private\n     */\n    PersistentConnection.prototype.sendConnectStats_ = function () {\n        var stats = {};\n        var clientName = 'js';\n        if (CONSTANTS.NODE_ADMIN) {\n            clientName = 'admin_node';\n        }\n        else if (CONSTANTS.NODE_CLIENT) {\n            clientName = 'node';\n        }\n        stats['sdk.' + clientName + '.' + firebase.SDK_VERSION.replace(/\\./g, '-')] = 1;\n        if (isMobileCordova()) {\n            stats['framework.cordova'] = 1;\n        }\n        else if (isReactNative()) {\n            stats['framework.reactnative'] = 1;\n        }\n        this.reportStats(stats);\n    };\n    /**\n     * @return {boolean}\n     * @private\n     */\n    PersistentConnection.prototype.shouldReconnect_ = function () {\n        var online = OnlineMonitor.getInstance().currentlyOnline();\n        return isEmpty(this.interruptReasons_) && online;\n    };\n    /**\n     * @private\n     */\n    PersistentConnection.nextPersistentConnectionId_ = 0;\n    /**\n     * Counter for number of connections created. Mainly used for tagging in the logs\n     * @type {number}\n     * @private\n     */\n    PersistentConnection.nextConnectionId_ = 0;\n    return PersistentConnection;\n}(ServerActions));\nexport { PersistentConnection };\n\n\n"]}