{"version":3,"sources":["database/src/database/core/snap/nodeFromJSON.ts"],"names":["nodeFromJSON","USE_HINZE","json","priority","EMPTY_NODE","jsonLeaf","Array","children_1","childrenHavePriority_1","hinzeJsonObj_1","key","child","substring","childNode","isEmpty","getPriority","push","length","childSet","namedNode","name","sortedChildSet","getCompare","Default","node_1","jsonObj_1","childData","isLeafNode","updateImmediateChild","updatePriority"],"mappings":";;;;;;8QAAA;;;;;;;;;;;;;;;;;QAoCMA,Y,GAAAA,Y;;AApBN;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AAGA,IAAMC,YAAY,IAAlB;AAEA;;;;;;;AAOM,SAAAD,YAAA,CACJE,IADI,EAEJC,QAFI,EAEmC;AAAvC,QAAAA,aAAA,KAAA,CAAA,EAAA;AAAAA,mBAAA,IAAA;AAAuC;AAEvC,QAAID,SAAS,IAAb,EAAmB;AACjB,eAAO,2BAAaE,UAApB;AACD;AAED,QAAI,QAAOF,IAAP,yCAAOA,IAAP,OAAgB,QAAhB,IAA4B,eAAeA,IAA/C,EAAqD;AACnDC,mBAAWD,KAAK,WAAL,CAAX;AACD;AAED,wBACEC,aAAa,IAAb,IACE,OAAOA,QAAP,KAAoB,QADtB,IAEE,OAAOA,QAAP,KAAoB,QAFtB,IAGG,QAAOA,QAAP,yCAAOA,QAAP,OAAoB,QAApB,IAAgC,SAAUA,QAJ/C,EAKE,0CAAyCA,QAAzC,yCAAyCA,QAAzC,EALF;AAQA,QAAI,QAAOD,IAAP,yCAAOA,IAAP,OAAgB,QAAhB,IAA4B,YAAYA,IAAxC,IAAgDA,KAAK,QAAL,MAAmB,IAAvE,EAA6E;AAC3EA,eAAOA,KAAK,QAAL,CAAP;AACD;AAED;AACA,QAAI,QAAOA,IAAP,yCAAOA,IAAP,OAAgB,QAAhB,IAA4B,SAASA,IAAzC,EAA+C;AAC7C,YAAMG,WAAWH,IAAjB;AACA,eAAO,uBAAaG,QAAb,EAAuBL,aAAaG,QAAb,CAAvB,CAAP;AACD;AAED,QAAI,EAAED,gBAAgBI,KAAlB,KAA4BL,SAAhC,EAA2C;AACzC,YAAMM,aAAwB,EAA9B;AACA,YAAIC,yBAAuB,KAA3B;AACA,YAAMC,iBAAqCP,IAA3C;AACA,0BAAQO,cAAR,EAAsB,UAACC,GAAD,EAAcC,KAAd,EAAwB;AAC5C,gBAAI,OAAOD,GAAP,KAAe,QAAf,IAA2BA,IAAIE,SAAJ,CAAc,CAAd,EAAiB,CAAjB,MAAwB,GAAvD,EAA4D;AAC1D;AACA,oBAAMC,YAAYb,aAAaS,eAAaC,GAAb,CAAb,CAAlB;AACA,oBAAI,CAACG,UAAUC,OAAV,EAAL,EAA0B;AACxBN,6CACEA,0BAAwB,CAACK,UAAUE,WAAV,GAAwBD,OAAxB,EAD3B;AAEAP,+BAASS,IAAT,CAAc,oBAAcN,GAAd,EAAmBG,SAAnB,CAAd;AACD;AACF;AACF,SAVD;AAYA,YAAIN,WAASU,MAAT,IAAmB,CAAvB,EAA0B;AACxB,mBAAO,2BAAab,UAApB;AACD;AAED,YAAMc,WAAW,6BACfX,UADe,qCAGf,UAAAY,SAAA,EAAS;AAAI,mBAAAA,UAAUC,IAAV;AAAc,SAHZ,+BAAjB;AAMA,YAAIZ,sBAAJ,EAA0B;AACxB,gBAAMa,iBAAiB,6BACrBd,UADqB,EAErB,8BAAee,UAAf,EAFqB,CAAvB;AAIA,mBAAO,+BACLJ,QADK,EAELlB,aAAaG,QAAb,CAFK,EAGL,uBACE,EAAE,aAAakB,cAAf,EADF,EAEE,EAAE,0CAAF,EAFF,CAHK,CAAP;AAQD,SAbD,MAaO;AACL,mBAAO,+BACLH,QADK,EAELlB,aAAaG,QAAb,CAFK,EAGL,mBAASoB,OAHJ,CAAP;AAKD;AACF,KA9CD,MA8CO;AACL,YAAIC,SAAa,2BAAapB,UAA9B;AACA,YAAMqB,YAAUvB,IAAhB;AACA,0BAAQuB,SAAR,EAAiB,UAACf,GAAD,EAAcgB,SAAd,EAA4B;AAC3C,gBAAI,mBAASD,SAAT,EAAkBf,GAAlB,CAAJ,EAA4B;AAC1B,oBAAIA,IAAIE,SAAJ,CAAc,CAAd,EAAiB,CAAjB,MAAwB,GAA5B,EAAiC;AAC/B;AACA,wBAAMC,YAAYb,aAAa0B,SAAb,CAAlB;AACA,wBAAIb,UAAUc,UAAV,MAA0B,CAACd,UAAUC,OAAV,EAA/B,EACEU,SAAOA,OAAKI,oBAAL,CAA0BlB,GAA1B,EAA+BG,SAA/B,CAAP;AACH;AACF;AACF,SATD;AAWA,eAAOW,OAAKK,cAAL,CAAoB7B,aAAaG,QAAb,CAApB,CAAP;AACD;AACF;AAED,oCAAgBH,YAAhB","file":"nodeFromJSON.js","sourcesContent":["/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\nimport { ChildrenNode } from './ChildrenNode';\nimport { LeafNode } from './LeafNode';\nimport { NamedNode, Node } from './Node';\nimport { forEach, contains } from '../../../utils/obj';\nimport { assert } from '../../../utils/assert';\nimport { buildChildSet } from './childSet';\nimport { NAME_COMPARATOR, NAME_ONLY_COMPARATOR } from './comparators';\nimport { IndexMap } from './IndexMap';\nimport { PRIORITY_INDEX, setNodeFromJSON } from './indexes/PriorityIndex';\nimport { SortedMap } from '../util/SortedMap';\n\nconst USE_HINZE = true;\n\n/**\n * Constructs a snapshot node representing the passed JSON and returns it.\n * @param {*} json JSON to create a node for.\n * @param {?string|?number=} priority Optional priority to use.  This will be ignored if the\n * passed JSON contains a .priority property.\n * @return {!Node}\n */\nexport function nodeFromJSON(\n  json: any | null,\n  priority: string | number | null = null\n): Node {\n  if (json === null) {\n    return ChildrenNode.EMPTY_NODE;\n  }\n\n  if (typeof json === 'object' && '.priority' in json) {\n    priority = json['.priority'];\n  }\n\n  assert(\n    priority === null ||\n      typeof priority === 'string' ||\n      typeof priority === 'number' ||\n      (typeof priority === 'object' && '.sv' in (priority as object)),\n    'Invalid priority type found: ' + typeof priority\n  );\n\n  if (typeof json === 'object' && '.value' in json && json['.value'] !== null) {\n    json = json['.value'];\n  }\n\n  // Valid leaf nodes include non-objects or server-value wrapper objects\n  if (typeof json !== 'object' || '.sv' in json) {\n    const jsonLeaf = json as string | number | boolean | object;\n    return new LeafNode(jsonLeaf, nodeFromJSON(priority));\n  }\n\n  if (!(json instanceof Array) && USE_HINZE) {\n    const children: NamedNode[] = [];\n    let childrenHavePriority = false;\n    const hinzeJsonObj: { [k: string]: any } = json as object;\n    forEach(hinzeJsonObj, (key: string, child: any) => {\n      if (typeof key !== 'string' || key.substring(0, 1) !== '.') {\n        // Ignore metadata nodes\n        const childNode = nodeFromJSON(hinzeJsonObj[key]);\n        if (!childNode.isEmpty()) {\n          childrenHavePriority =\n            childrenHavePriority || !childNode.getPriority().isEmpty();\n          children.push(new NamedNode(key, childNode));\n        }\n      }\n    });\n\n    if (children.length == 0) {\n      return ChildrenNode.EMPTY_NODE;\n    }\n\n    const childSet = buildChildSet(\n      children,\n      NAME_ONLY_COMPARATOR,\n      namedNode => namedNode.name,\n      NAME_COMPARATOR\n    ) as SortedMap<string, Node>;\n    if (childrenHavePriority) {\n      const sortedChildSet = buildChildSet(\n        children,\n        PRIORITY_INDEX.getCompare()\n      );\n      return new ChildrenNode(\n        childSet,\n        nodeFromJSON(priority),\n        new IndexMap(\n          { '.priority': sortedChildSet },\n          { '.priority': PRIORITY_INDEX }\n        )\n      );\n    } else {\n      return new ChildrenNode(\n        childSet,\n        nodeFromJSON(priority),\n        IndexMap.Default\n      );\n    }\n  } else {\n    let node: Node = ChildrenNode.EMPTY_NODE;\n    const jsonObj = json as object;\n    forEach(jsonObj, (key: string, childData: any) => {\n      if (contains(jsonObj, key)) {\n        if (key.substring(0, 1) !== '.') {\n          // ignore metadata nodes.\n          const childNode = nodeFromJSON(childData);\n          if (childNode.isLeafNode() || !childNode.isEmpty())\n            node = node.updateImmediateChild(key, childNode);\n        }\n      }\n    });\n\n    return node.updatePriority(nodeFromJSON(priority));\n  }\n}\n\nsetNodeFromJSON(nodeFromJSON);\n"]}