{"version":3,"sources":["database/core/src/database/core/snap/indexes/KeyIndex.ts","database/core/snap/indexes/KeyIndex.js"],"names":["__extends","extendStatics","Object","setPrototypeOf","__proto__","Array","d","b","p","hasOwnProperty","__","constructor","prototype","create","__EMPTY_NODE","KeyIndex","_super","apply","arguments","defineProperty","get","set","val","enumerable","configurable","compare","a","name","isDefinedOn","node","indexedValueChanged","oldNode","newNode","minPost","MIN","maxPost","makePost","indexValue","toString","KEY_INDEX"],"mappings":";;;;;;;AAgBA;;AACA;;AACA;;AACA;;AAnBA;;;;;;;;;;;;;;;ACeA,IAAIA,YAAa,aAAQ,UAAKA,SAAd,IAA6B,YAAY;AACrD,QAAIC,gBAAgBC,OAAOC,cAAP,IACf,EAAEC,WAAW,EAAb,cAA6BC,KAA7B,IAAsC,UAAUC,CAAV,EAAaC,CAAb,EAAgB;AAAED,UAAEF,SAAF,GAAcG,CAAd;AAAkB,KAD3D,IAEhB,UAAUD,CAAV,EAAaC,CAAb,EAAgB;AAAE,aAAK,IAAIC,CAAT,IAAcD,CAAd;AAAiB,gBAAIA,EAAEE,cAAF,CAAiBD,CAAjB,CAAJ,EAAyBF,EAAEE,CAAF,IAAOD,EAAEC,CAAF,CAAP;AAA1C;AAAwD,KAF9E;AAGA,WAAO,UAAUF,CAAV,EAAaC,CAAb,EAAgB;AACnBN,sBAAcK,CAAd,EAAiBC,CAAjB;AACA,iBAASG,EAAT,GAAc;AAAE,iBAAKC,WAAL,GAAmBL,CAAnB;AAAuB;AACvCA,UAAEM,SAAF,GAAcL,MAAM,IAAN,GAAaL,OAAOW,MAAP,CAAcN,CAAd,CAAb,IAAiCG,GAAGE,SAAH,GAAeL,EAAEK,SAAjB,EAA4B,IAAIF,EAAJ,EAA7D,CAAd;AACH,KAJD;AAKH,CAT2C,EAA5C;;ADOA,IAAII,YAAJ;AAEA,IAAAC,WAAA,UAAAC,MAAA,EAAA;AAA8BhB,cAAAe,QAAA,EAAAC,MAAA;AAA9B,aAAAD,QAAA,GAAA;ACSQ,eAAOC,WAAW,IAAX,IAAmBA,OAAOC,KAAP,CAAa,IAAb,EAAmBC,SAAnB,CAAnB,IAAoD,IAA3D;AD2DP;AAnEChB,WAAAiB,cAAA,CAAWJ,QAAX,EAAW,cAAX,EAAuB;ACWjBK,aDXN,eAAA;AACE,mBAAON,YAAP;AACD,SAFsB;ACcjBO,aDVN,aAAwBC,GAAxB,EAA2B;AACzBR,2BAAeQ,GAAf;AACD,SANsB;ACiBjBC,oBAAY,IDjBK;ACkBjBC,sBAAc;ADlBG,KAAvB;AAQA;;;AAGAT,aAAAH,SAAA,CAAAa,OAAA,GAAA,UAAQC,CAAR,EAAsBnB,CAAtB,EAAkC;AAChC,eAAO,uBAAYmB,EAAEC,IAAd,EAAoBpB,EAAEoB,IAAtB,CAAP;AACD,KAFD;AAIA;;;AAGAZ,aAAAH,SAAA,CAAAgB,WAAA,GAAA,UAAYC,IAAZ,EAAsB;AACpB;AACA;AACA,cAAM,4BAAe,iDAAf,CAAN;AACD,KAJD;AAMA;;;AAGAd,aAAAH,SAAA,CAAAkB,mBAAA,GAAA,UAAoBC,OAApB,EAAmCC,OAAnC,EAAgD;AAC9C,eAAO,KAAP,CAD8C,CAChC;AACf,KAFD;AAIA;;;AAGAjB,aAAAH,SAAA,CAAAqB,OAAA,GAAA,YAAA;AACE,eAAQ,gBAAkBC,GAA1B;AACD,KAFD;AAIA;;;AAGAnB,aAAAH,SAAA,CAAAuB,OAAA,GAAA,YAAA;AACE;AACA;AACA,eAAO,oCAAwBrB,YAAxB,CAAP;AACD,KAJD;AAMA;;;;;AAKAC,aAAAH,SAAA,CAAAwB,QAAA,GAAA,UAASC,UAAT,EAA6BV,IAA7B,EAAyC;AACvC,4BACE,OAAOU,UAAP,KAAsB,QADxB,EAEE,8CAFF;AAIA;AACA,eAAO,oBAAcA,UAAd,EAA0BvB,YAA1B,CAAP;AACD,KAPD;AASA;;;AAGAC,aAAAH,SAAA,CAAA0B,QAAA,GAAA,YAAA;AACE,eAAO,MAAP;AACD,KAFD;AAGF,WAAAvB,QAAA;AApEA,CAAA,cAAA;QCyESA,Q,GAAAA,Q;ADHF,IAAMwB,gCAAY,IAAIxB,QAAJ,EAAlB","file":"KeyIndex.js","sourcesContent":["/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\nimport { Index } from './Index';\nimport { Node, NamedNode } from '../Node';\nimport { nameCompare, MAX_NAME } from '../../util/util';\nimport { assert, assertionError } from '../../../../utils/assert';\nimport { ChildrenNode } from '../ChildrenNode';\n\nlet __EMPTY_NODE: ChildrenNode;\n\nexport class KeyIndex extends Index {\n  static get __EMPTY_NODE() {\n    return __EMPTY_NODE;\n  }\n\n  static set __EMPTY_NODE(val) {\n    __EMPTY_NODE = val;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  compare(a: NamedNode, b: NamedNode): number {\n    return nameCompare(a.name, b.name);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  isDefinedOn(node: Node): boolean {\n    // We could probably return true here (since every node has a key), but it's never called\n    // so just leaving unimplemented for now.\n    throw assertionError('KeyIndex.isDefinedOn not expected to be called.');\n  }\n\n  /**\n   * @inheritDoc\n   */\n  indexedValueChanged(oldNode: Node, newNode: Node): boolean {\n    return false; // The key for a node never changes.\n  }\n\n  /**\n   * @inheritDoc\n   */\n  minPost() {\n    return (NamedNode as any).MIN;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  maxPost(): NamedNode {\n    // TODO: This should really be created once and cached in a static property, but\n    // NamedNode isn't defined yet, so I can't use it in a static.  Bleh.\n    return new NamedNode(MAX_NAME, __EMPTY_NODE);\n  }\n\n  /**\n   * @param {*} indexValue\n   * @param {string} name\n   * @return {!NamedNode}\n   */\n  makePost(indexValue: string, name: string): NamedNode {\n    assert(\n      typeof indexValue === 'string',\n      'KeyIndex indexValue must always be a string.'\n    );\n    // We just use empty node, but it'll never be compared, since our comparator only looks at name.\n    return new NamedNode(indexValue, __EMPTY_NODE);\n  }\n\n  /**\n   * @return {!string} String representation for inclusion in a query spec\n   */\n  toString(): string {\n    return '.key';\n  }\n}\n\nexport const KEY_INDEX = new KeyIndex();\n","/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { Index } from './Index';\nimport { NamedNode } from '../Node';\nimport { nameCompare, MAX_NAME } from '../../util/util';\nimport { assert, assertionError } from '../../../../utils/assert';\nvar __EMPTY_NODE;\nvar KeyIndex = (function (_super) {\n    __extends(KeyIndex, _super);\n    function KeyIndex() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(KeyIndex, \"__EMPTY_NODE\", {\n        get: function () {\n            return __EMPTY_NODE;\n        },\n        set: function (val) {\n            __EMPTY_NODE = val;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    KeyIndex.prototype.compare = function (a, b) {\n        return nameCompare(a.name, b.name);\n    };\n    /**\n     * @inheritDoc\n     */\n    KeyIndex.prototype.isDefinedOn = function (node) {\n        // We could probably return true here (since every node has a key), but it's never called\n        // so just leaving unimplemented for now.\n        throw assertionError('KeyIndex.isDefinedOn not expected to be called.');\n    };\n    /**\n     * @inheritDoc\n     */\n    KeyIndex.prototype.indexedValueChanged = function (oldNode, newNode) {\n        return false; // The key for a node never changes.\n    };\n    /**\n     * @inheritDoc\n     */\n    KeyIndex.prototype.minPost = function () {\n        return NamedNode.MIN;\n    };\n    /**\n     * @inheritDoc\n     */\n    KeyIndex.prototype.maxPost = function () {\n        // TODO: This should really be created once and cached in a static property, but\n        // NamedNode isn't defined yet, so I can't use it in a static.  Bleh.\n        return new NamedNode(MAX_NAME, __EMPTY_NODE);\n    };\n    /**\n     * @param {*} indexValue\n     * @param {string} name\n     * @return {!NamedNode}\n     */\n    KeyIndex.prototype.makePost = function (indexValue, name) {\n        assert(typeof indexValue === 'string', 'KeyIndex indexValue must always be a string.');\n        // We just use empty node, but it'll never be compared, since our comparator only looks at name.\n        return new NamedNode(indexValue, __EMPTY_NODE);\n    };\n    /**\n     * @return {!string} String representation for inclusion in a query spec\n     */\n    KeyIndex.prototype.toString = function () {\n        return '.key';\n    };\n    return KeyIndex;\n}(Index));\nexport { KeyIndex };\nexport var KEY_INDEX = new KeyIndex();\n\n\n"]}