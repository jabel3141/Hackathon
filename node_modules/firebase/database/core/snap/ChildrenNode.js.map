{"version":3,"sources":["database/src/database/core/snap/ChildrenNode.ts","database/core/snap/ChildrenNode.js"],"names":["__extends","extendStatics","Object","setPrototypeOf","__proto__","Array","d","b","p","hasOwnProperty","__","constructor","prototype","create","EMPTY_NODE","ChildrenNode","children_","priorityNode_","indexMap_","lazyHash_","isEmpty","defineProperty","get","Default","enumerable","configurable","isLeafNode","getPriority","updatePriority","newPriorityNode","getImmediateChild","childName","child","getChild","path","front","getFront","popFront","hasChild","updateImmediateChild","newChildNode","namedNode","newChildren","newIndexMap","newPriority","remove","removeFromIndexes","insert","addToIndexes","updateChild","getLength","newImmediateChild","numChildren","count","val","exportFormat","obj","numKeys","maxKey","allIntegerKeys","forEachChild","key","childNode","INTEGER_REGEXP_","test","Math","max","Number","array","hash","toHash_1","childHash","getPredecessorChildName","index","idx","resolveIndex_","predecessor","getPredecessorKey","name","getFirstChildName","indexDefinition","minKey","getFirstChild","getLastChildName","getLastChild","action","inorderTraversal","wrappedNode","node","getIterator","getIteratorFrom","minPost","startPost","iterator","Wrap","next","peek","compare","getNext","getReverseIterator","getReverseIteratorFrom","maxPost","endPost","compareTo","other","MAX_NODE","withIndex","hasIndex","addIndex","isIndexed","equals","otherChildrenNode","thisIter","otherIter","thisCurrent","otherCurrent","toString","MaxNode","_super","call","defineProperties","MIN","value","MAX","__EMPTY_NODE","__childrenNodeConstructor"],"mappings":"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","file":"ChildrenNode.js","sourcesContent":["/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\nimport { assert } from '../../../utils/assert';\nimport { sha1, MAX_NAME, MIN_NAME } from '../util/util';\nimport { SortedMap, SortedMapIterator } from '../util/SortedMap';\nimport { Node, NamedNode } from './Node';\nimport { validatePriorityNode, priorityHashText, setMaxNode } from './snap';\nimport {\n  PRIORITY_INDEX,\n  setMaxNode as setPriorityMaxNode\n} from './indexes/PriorityIndex';\nimport { KEY_INDEX, KeyIndex } from './indexes/KeyIndex';\nimport { IndexMap } from './IndexMap';\nimport { LeafNode } from './LeafNode';\nimport { NAME_COMPARATOR } from './comparators';\nimport { Index } from './indexes/Index';\nimport { Path } from '../util/Path';\n\nexport interface ChildrenNodeConstructor {\n  new (\n    children_: SortedMap<string, Node>,\n    priorityNode_: Node | null,\n    indexMap_: IndexMap\n  ): ChildrenNode;\n  EMPTY_NODE: ChildrenNode;\n}\n\n// TODO: For memory savings, don't store priorityNode_ if it's empty.\n\nlet EMPTY_NODE: ChildrenNode;\n\n/**\n * ChildrenNode is a class for storing internal nodes in a DataSnapshot\n * (i.e. nodes with children).  It implements Node and stores the\n * list of children in the children property, sorted by child name.\n *\n * @constructor\n * @implements {Node}\n */\nexport class ChildrenNode implements Node {\n  private lazyHash_: string | null = null;\n\n  static get EMPTY_NODE(): ChildrenNode {\n    return (\n      EMPTY_NODE ||\n      (EMPTY_NODE = new ChildrenNode(\n        new SortedMap<string, Node>(NAME_COMPARATOR),\n        null,\n        IndexMap.Default\n      ))\n    );\n  }\n\n  /**\n   *\n   * @param {!SortedMap.<string, !Node>} children_ List of children\n   * of this node..\n   * @param {?Node} priorityNode_ The priority of this node (as a snapshot node).\n   * @param {!IndexMap} indexMap_\n   */\n  constructor(\n    private readonly children_: SortedMap<string, Node>,\n    private readonly priorityNode_: Node | null,\n    private indexMap_: IndexMap\n  ) {\n    /**\n     * Note: The only reason we allow null priority is for EMPTY_NODE, since we can't use\n     * EMPTY_NODE as the priority of EMPTY_NODE.  We might want to consider making EMPTY_NODE its own\n     * class instead of an empty ChildrenNode.\n     */\n    if (this.priorityNode_) {\n      validatePriorityNode(this.priorityNode_);\n    }\n\n    if (this.children_.isEmpty()) {\n      assert(\n        !this.priorityNode_ || this.priorityNode_.isEmpty(),\n        'An empty node cannot have a priority'\n      );\n    }\n  }\n\n  /** @inheritDoc */\n  isLeafNode(): boolean {\n    return false;\n  }\n\n  /** @inheritDoc */\n  getPriority(): Node {\n    return this.priorityNode_ || EMPTY_NODE;\n  }\n\n  /** @inheritDoc */\n  updatePriority(newPriorityNode: Node): Node {\n    if (this.children_.isEmpty()) {\n      // Don't allow priorities on empty nodes\n      return this;\n    } else {\n      return new ChildrenNode(this.children_, newPriorityNode, this.indexMap_);\n    }\n  }\n\n  /** @inheritDoc */\n  getImmediateChild(childName: string): Node {\n    // Hack to treat priority as a regular child\n    if (childName === '.priority') {\n      return this.getPriority();\n    } else {\n      const child = this.children_.get(childName);\n      return child === null ? EMPTY_NODE : child;\n    }\n  }\n\n  /** @inheritDoc */\n  getChild(path: Path): Node {\n    const front = path.getFront();\n    if (front === null) return this;\n\n    return this.getImmediateChild(front).getChild(path.popFront());\n  }\n\n  /** @inheritDoc */\n  hasChild(childName: string): boolean {\n    return this.children_.get(childName) !== null;\n  }\n\n  /** @inheritDoc */\n  updateImmediateChild(childName: string, newChildNode: Node): Node {\n    assert(newChildNode, 'We should always be passing snapshot nodes');\n    if (childName === '.priority') {\n      return this.updatePriority(newChildNode);\n    } else {\n      const namedNode = new NamedNode(childName, newChildNode);\n      let newChildren, newIndexMap, newPriority;\n      if (newChildNode.isEmpty()) {\n        newChildren = this.children_.remove(childName);\n        newIndexMap = this.indexMap_.removeFromIndexes(\n          namedNode,\n          this.children_\n        );\n      } else {\n        newChildren = this.children_.insert(childName, newChildNode);\n        newIndexMap = this.indexMap_.addToIndexes(namedNode, this.children_);\n      }\n\n      newPriority = newChildren.isEmpty() ? EMPTY_NODE : this.priorityNode_;\n      return new ChildrenNode(newChildren, newPriority, newIndexMap);\n    }\n  }\n\n  /** @inheritDoc */\n  updateChild(path: Path, newChildNode: Node): Node {\n    const front = path.getFront();\n    if (front === null) {\n      return newChildNode;\n    } else {\n      assert(\n        path.getFront() !== '.priority' || path.getLength() === 1,\n        '.priority must be the last token in a path'\n      );\n      const newImmediateChild = this.getImmediateChild(front).updateChild(\n        path.popFront(),\n        newChildNode\n      );\n      return this.updateImmediateChild(front, newImmediateChild);\n    }\n  }\n\n  /** @inheritDoc */\n  isEmpty(): boolean {\n    return this.children_.isEmpty();\n  }\n\n  /** @inheritDoc */\n  numChildren(): number {\n    return this.children_.count();\n  }\n\n  /**\n   * @private\n   * @type {RegExp}\n   */\n  private static INTEGER_REGEXP_ = /^(0|[1-9]\\d*)$/;\n\n  /** @inheritDoc */\n  val(exportFormat?: boolean): object {\n    if (this.isEmpty()) return null;\n\n    const obj: { [k: string]: Object } = {};\n    let numKeys = 0,\n      maxKey = 0,\n      allIntegerKeys = true;\n    this.forEachChild(PRIORITY_INDEX, function(key: string, childNode: Node) {\n      obj[key] = childNode.val(exportFormat);\n\n      numKeys++;\n      if (allIntegerKeys && ChildrenNode.INTEGER_REGEXP_.test(key)) {\n        maxKey = Math.max(maxKey, Number(key));\n      } else {\n        allIntegerKeys = false;\n      }\n    });\n\n    if (!exportFormat && allIntegerKeys && maxKey < 2 * numKeys) {\n      // convert to array.\n      const array: Object[] = [];\n      for (let key in obj) array[(key as any) as number] = obj[key];\n\n      return array;\n    } else {\n      if (exportFormat && !this.getPriority().isEmpty()) {\n        obj['.priority'] = this.getPriority().val();\n      }\n      return obj;\n    }\n  }\n\n  /** @inheritDoc */\n  hash(): string {\n    if (this.lazyHash_ === null) {\n      let toHash = '';\n      if (!this.getPriority().isEmpty())\n        toHash +=\n          'priority:' +\n          priorityHashText(this.getPriority().val() as string | number) +\n          ':';\n\n      this.forEachChild(PRIORITY_INDEX, function(key, childNode) {\n        const childHash = childNode.hash();\n        if (childHash !== '') toHash += ':' + key + ':' + childHash;\n      });\n\n      this.lazyHash_ = toHash === '' ? '' : sha1(toHash);\n    }\n    return this.lazyHash_;\n  }\n\n  /** @inheritDoc */\n  getPredecessorChildName(\n    childName: string,\n    childNode: Node,\n    index: Index\n  ): string {\n    const idx = this.resolveIndex_(index);\n    if (idx) {\n      const predecessor = idx.getPredecessorKey(\n        new NamedNode(childName, childNode)\n      );\n      return predecessor ? predecessor.name : null;\n    } else {\n      return this.children_.getPredecessorKey(childName);\n    }\n  }\n\n  /**\n   * @param {!Index} indexDefinition\n   * @return {?string}\n   */\n  getFirstChildName(indexDefinition: Index): string | null {\n    const idx = this.resolveIndex_(indexDefinition);\n    if (idx) {\n      const minKey = idx.minKey();\n      return minKey && minKey.name;\n    } else {\n      return this.children_.minKey();\n    }\n  }\n\n  /**\n   * @param {!Index} indexDefinition\n   * @return {?NamedNode}\n   */\n  getFirstChild(indexDefinition: Index): NamedNode | null {\n    const minKey = this.getFirstChildName(indexDefinition);\n    if (minKey) {\n      return new NamedNode(minKey, this.children_.get(minKey));\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * Given an index, return the key name of the largest value we have, according to that index\n   * @param {!Index} indexDefinition\n   * @return {?string}\n   */\n  getLastChildName(indexDefinition: Index): string | null {\n    const idx = this.resolveIndex_(indexDefinition);\n    if (idx) {\n      const maxKey = idx.maxKey();\n      return maxKey && maxKey.name;\n    } else {\n      return this.children_.maxKey();\n    }\n  }\n\n  /**\n   * @param {!Index} indexDefinition\n   * @return {?NamedNode}\n   */\n  getLastChild(indexDefinition: Index): NamedNode | null {\n    const maxKey = this.getLastChildName(indexDefinition);\n    if (maxKey) {\n      return new NamedNode(maxKey, this.children_.get(maxKey));\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  forEachChild(index: Index, action: (key: string, node: Node) => void): any {\n    const idx = this.resolveIndex_(index);\n    if (idx) {\n      return idx.inorderTraversal(function(wrappedNode) {\n        return action(wrappedNode.name, wrappedNode.node);\n      });\n    } else {\n      return this.children_.inorderTraversal(action);\n    }\n  }\n\n  /**\n   * @param {!Index} indexDefinition\n   * @return {SortedMapIterator}\n   */\n  getIterator(\n    indexDefinition: Index\n  ): SortedMapIterator<string | NamedNode, Node, NamedNode> {\n    return this.getIteratorFrom(indexDefinition.minPost(), indexDefinition);\n  }\n\n  /**\n   *\n   * @param {!NamedNode} startPost\n   * @param {!Index} indexDefinition\n   * @return {!SortedMapIterator}\n   */\n  getIteratorFrom(\n    startPost: NamedNode,\n    indexDefinition: Index\n  ): SortedMapIterator<string | NamedNode, Node, NamedNode> {\n    const idx = this.resolveIndex_(indexDefinition);\n    if (idx) {\n      return idx.getIteratorFrom(startPost, key => key);\n    } else {\n      const iterator = this.children_.getIteratorFrom(\n        startPost.name,\n        NamedNode.Wrap\n      );\n      let next = iterator.peek();\n      while (next != null && indexDefinition.compare(next, startPost) < 0) {\n        iterator.getNext();\n        next = iterator.peek();\n      }\n      return iterator;\n    }\n  }\n\n  /**\n   * @param {!Index} indexDefinition\n   * @return {!SortedMapIterator}\n   */\n  getReverseIterator(\n    indexDefinition: Index\n  ): SortedMapIterator<string | NamedNode, Node, NamedNode> {\n    return this.getReverseIteratorFrom(\n      indexDefinition.maxPost(),\n      indexDefinition\n    );\n  }\n\n  /**\n   * @param {!NamedNode} endPost\n   * @param {!Index} indexDefinition\n   * @return {!SortedMapIterator}\n   */\n  getReverseIteratorFrom(\n    endPost: NamedNode,\n    indexDefinition: Index\n  ): SortedMapIterator<string | NamedNode, Node, NamedNode> {\n    const idx = this.resolveIndex_(indexDefinition);\n    if (idx) {\n      return idx.getReverseIteratorFrom(endPost, function(key) {\n        return key;\n      });\n    } else {\n      const iterator = this.children_.getReverseIteratorFrom(\n        endPost.name,\n        NamedNode.Wrap\n      );\n      let next = iterator.peek();\n      while (next != null && indexDefinition.compare(next, endPost) > 0) {\n        iterator.getNext();\n        next = iterator.peek();\n      }\n      return iterator;\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  compareTo(other: ChildrenNode): number {\n    if (this.isEmpty()) {\n      if (other.isEmpty()) {\n        return 0;\n      } else {\n        return -1;\n      }\n    } else if (other.isLeafNode() || other.isEmpty()) {\n      return 1;\n    } else if (other === MAX_NODE) {\n      return -1;\n    } else {\n      // Must be another node with children.\n      return 0;\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  withIndex(indexDefinition: Index): Node {\n    if (\n      indexDefinition === KEY_INDEX ||\n      this.indexMap_.hasIndex(indexDefinition)\n    ) {\n      return this;\n    } else {\n      const newIndexMap = this.indexMap_.addIndex(\n        indexDefinition,\n        this.children_\n      );\n      return new ChildrenNode(this.children_, this.priorityNode_, newIndexMap);\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  isIndexed(index: Index): boolean {\n    return index === KEY_INDEX || this.indexMap_.hasIndex(index);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  equals(other: Node): boolean {\n    if (other === this) {\n      return true;\n    } else if (other.isLeafNode()) {\n      return false;\n    } else {\n      const otherChildrenNode = other as ChildrenNode;\n      if (!this.getPriority().equals(otherChildrenNode.getPriority())) {\n        return false;\n      } else if (\n        this.children_.count() === otherChildrenNode.children_.count()\n      ) {\n        const thisIter = this.getIterator(PRIORITY_INDEX);\n        const otherIter = otherChildrenNode.getIterator(PRIORITY_INDEX);\n        let thisCurrent = thisIter.getNext();\n        let otherCurrent = otherIter.getNext();\n        while (thisCurrent && otherCurrent) {\n          if (\n            thisCurrent.name !== otherCurrent.name ||\n            !thisCurrent.node.equals(otherCurrent.node)\n          ) {\n            return false;\n          }\n          thisCurrent = thisIter.getNext();\n          otherCurrent = otherIter.getNext();\n        }\n        return thisCurrent === null && otherCurrent === null;\n      } else {\n        return false;\n      }\n    }\n  }\n\n  /**\n   * Returns a SortedMap ordered by index, or null if the default (by-key) ordering can be used\n   * instead.\n   *\n   * @private\n   * @param {!Index} indexDefinition\n   * @return {?SortedMap.<NamedNode, Node>}\n   */\n  private resolveIndex_(\n    indexDefinition: Index\n  ): SortedMap<NamedNode, Node> | null {\n    if (indexDefinition === KEY_INDEX) {\n      return null;\n    } else {\n      return this.indexMap_.get(indexDefinition.toString());\n    }\n  }\n}\n\n/**\n * @constructor\n * @extends {ChildrenNode}\n * @private\n */\nexport class MaxNode extends ChildrenNode {\n  constructor() {\n    super(\n      new SortedMap<string, Node>(NAME_COMPARATOR),\n      ChildrenNode.EMPTY_NODE,\n      IndexMap.Default\n    );\n  }\n\n  compareTo(other: Node): number {\n    if (other === this) {\n      return 0;\n    } else {\n      return 1;\n    }\n  }\n\n  equals(other: Node): boolean {\n    // Not that we every compare it, but MAX_NODE is only ever equal to itself\n    return other === this;\n  }\n\n  getPriority(): MaxNode {\n    return this;\n  }\n\n  getImmediateChild(childName: string): ChildrenNode {\n    return ChildrenNode.EMPTY_NODE;\n  }\n\n  isEmpty(): boolean {\n    return false;\n  }\n}\n\n/**\n * Marker that will sort higher than any other snapshot.\n * @type {!MAX_NODE}\n * @const\n */\nexport const MAX_NODE = new MaxNode();\n\n/**\n * Document NamedNode extensions\n */\ndeclare module './Node' {\n  interface NamedNode {\n    MIN: NamedNode;\n    MAX: NamedNode;\n  }\n}\n\nObject.defineProperties(NamedNode, {\n  MIN: {\n    value: new NamedNode(MIN_NAME, ChildrenNode.EMPTY_NODE)\n  },\n  MAX: {\n    value: new NamedNode(MAX_NAME, MAX_NODE)\n  }\n});\n\n/**\n * Reference Extensions\n */\nKeyIndex.__EMPTY_NODE = ChildrenNode.EMPTY_NODE;\nLeafNode.__childrenNodeConstructor = ChildrenNode;\nsetMaxNode(MAX_NODE);\nsetPriorityMaxNode(MAX_NODE);\n","/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { assert } from '../../../utils/assert';\nimport { sha1, MAX_NAME, MIN_NAME } from '../util/util';\nimport { SortedMap } from '../util/SortedMap';\nimport { NamedNode } from './Node';\nimport { validatePriorityNode, priorityHashText, setMaxNode } from './snap';\nimport { PRIORITY_INDEX, setMaxNode as setPriorityMaxNode } from './indexes/PriorityIndex';\nimport { KEY_INDEX, KeyIndex } from './indexes/KeyIndex';\nimport { IndexMap } from './IndexMap';\nimport { LeafNode } from './LeafNode';\nimport { NAME_COMPARATOR } from './comparators';\n// TODO: For memory savings, don't store priorityNode_ if it's empty.\nvar EMPTY_NODE;\n/**\n * ChildrenNode is a class for storing internal nodes in a DataSnapshot\n * (i.e. nodes with children).  It implements Node and stores the\n * list of children in the children property, sorted by child name.\n *\n * @constructor\n * @implements {Node}\n */\nvar ChildrenNode = (function () {\n    /**\n     *\n     * @param {!SortedMap.<string, !Node>} children_ List of children\n     * of this node..\n     * @param {?Node} priorityNode_ The priority of this node (as a snapshot node).\n     * @param {!IndexMap} indexMap_\n     */\n    function ChildrenNode(children_, priorityNode_, indexMap_) {\n        this.children_ = children_;\n        this.priorityNode_ = priorityNode_;\n        this.indexMap_ = indexMap_;\n        this.lazyHash_ = null;\n        /**\n         * Note: The only reason we allow null priority is for EMPTY_NODE, since we can't use\n         * EMPTY_NODE as the priority of EMPTY_NODE.  We might want to consider making EMPTY_NODE its own\n         * class instead of an empty ChildrenNode.\n         */\n        if (this.priorityNode_) {\n            validatePriorityNode(this.priorityNode_);\n        }\n        if (this.children_.isEmpty()) {\n            assert(!this.priorityNode_ || this.priorityNode_.isEmpty(), 'An empty node cannot have a priority');\n        }\n    }\n    Object.defineProperty(ChildrenNode, \"EMPTY_NODE\", {\n        get: function () {\n            return (EMPTY_NODE ||\n                (EMPTY_NODE = new ChildrenNode(new SortedMap(NAME_COMPARATOR), null, IndexMap.Default)));\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /** @inheritDoc */\n    ChildrenNode.prototype.isLeafNode = function () {\n        return false;\n    };\n    /** @inheritDoc */\n    ChildrenNode.prototype.getPriority = function () {\n        return this.priorityNode_ || EMPTY_NODE;\n    };\n    /** @inheritDoc */\n    ChildrenNode.prototype.updatePriority = function (newPriorityNode) {\n        if (this.children_.isEmpty()) {\n            // Don't allow priorities on empty nodes\n            return this;\n        }\n        else {\n            return new ChildrenNode(this.children_, newPriorityNode, this.indexMap_);\n        }\n    };\n    /** @inheritDoc */\n    ChildrenNode.prototype.getImmediateChild = function (childName) {\n        // Hack to treat priority as a regular child\n        if (childName === '.priority') {\n            return this.getPriority();\n        }\n        else {\n            var child = this.children_.get(childName);\n            return child === null ? EMPTY_NODE : child;\n        }\n    };\n    /** @inheritDoc */\n    ChildrenNode.prototype.getChild = function (path) {\n        var front = path.getFront();\n        if (front === null)\n            return this;\n        return this.getImmediateChild(front).getChild(path.popFront());\n    };\n    /** @inheritDoc */\n    ChildrenNode.prototype.hasChild = function (childName) {\n        return this.children_.get(childName) !== null;\n    };\n    /** @inheritDoc */\n    ChildrenNode.prototype.updateImmediateChild = function (childName, newChildNode) {\n        assert(newChildNode, 'We should always be passing snapshot nodes');\n        if (childName === '.priority') {\n            return this.updatePriority(newChildNode);\n        }\n        else {\n            var namedNode = new NamedNode(childName, newChildNode);\n            var newChildren = void 0, newIndexMap = void 0, newPriority = void 0;\n            if (newChildNode.isEmpty()) {\n                newChildren = this.children_.remove(childName);\n                newIndexMap = this.indexMap_.removeFromIndexes(namedNode, this.children_);\n            }\n            else {\n                newChildren = this.children_.insert(childName, newChildNode);\n                newIndexMap = this.indexMap_.addToIndexes(namedNode, this.children_);\n            }\n            newPriority = newChildren.isEmpty() ? EMPTY_NODE : this.priorityNode_;\n            return new ChildrenNode(newChildren, newPriority, newIndexMap);\n        }\n    };\n    /** @inheritDoc */\n    ChildrenNode.prototype.updateChild = function (path, newChildNode) {\n        var front = path.getFront();\n        if (front === null) {\n            return newChildNode;\n        }\n        else {\n            assert(path.getFront() !== '.priority' || path.getLength() === 1, '.priority must be the last token in a path');\n            var newImmediateChild = this.getImmediateChild(front).updateChild(path.popFront(), newChildNode);\n            return this.updateImmediateChild(front, newImmediateChild);\n        }\n    };\n    /** @inheritDoc */\n    ChildrenNode.prototype.isEmpty = function () {\n        return this.children_.isEmpty();\n    };\n    /** @inheritDoc */\n    ChildrenNode.prototype.numChildren = function () {\n        return this.children_.count();\n    };\n    /** @inheritDoc */\n    ChildrenNode.prototype.val = function (exportFormat) {\n        if (this.isEmpty())\n            return null;\n        var obj = {};\n        var numKeys = 0, maxKey = 0, allIntegerKeys = true;\n        this.forEachChild(PRIORITY_INDEX, function (key, childNode) {\n            obj[key] = childNode.val(exportFormat);\n            numKeys++;\n            if (allIntegerKeys && ChildrenNode.INTEGER_REGEXP_.test(key)) {\n                maxKey = Math.max(maxKey, Number(key));\n            }\n            else {\n                allIntegerKeys = false;\n            }\n        });\n        if (!exportFormat && allIntegerKeys && maxKey < 2 * numKeys) {\n            // convert to array.\n            var array = [];\n            for (var key in obj)\n                array[key] = obj[key];\n            return array;\n        }\n        else {\n            if (exportFormat && !this.getPriority().isEmpty()) {\n                obj['.priority'] = this.getPriority().val();\n            }\n            return obj;\n        }\n    };\n    /** @inheritDoc */\n    ChildrenNode.prototype.hash = function () {\n        if (this.lazyHash_ === null) {\n            var toHash_1 = '';\n            if (!this.getPriority().isEmpty())\n                toHash_1 +=\n                    'priority:' +\n                        priorityHashText(this.getPriority().val()) +\n                        ':';\n            this.forEachChild(PRIORITY_INDEX, function (key, childNode) {\n                var childHash = childNode.hash();\n                if (childHash !== '')\n                    toHash_1 += ':' + key + ':' + childHash;\n            });\n            this.lazyHash_ = toHash_1 === '' ? '' : sha1(toHash_1);\n        }\n        return this.lazyHash_;\n    };\n    /** @inheritDoc */\n    ChildrenNode.prototype.getPredecessorChildName = function (childName, childNode, index) {\n        var idx = this.resolveIndex_(index);\n        if (idx) {\n            var predecessor = idx.getPredecessorKey(new NamedNode(childName, childNode));\n            return predecessor ? predecessor.name : null;\n        }\n        else {\n            return this.children_.getPredecessorKey(childName);\n        }\n    };\n    /**\n     * @param {!Index} indexDefinition\n     * @return {?string}\n     */\n    ChildrenNode.prototype.getFirstChildName = function (indexDefinition) {\n        var idx = this.resolveIndex_(indexDefinition);\n        if (idx) {\n            var minKey = idx.minKey();\n            return minKey && minKey.name;\n        }\n        else {\n            return this.children_.minKey();\n        }\n    };\n    /**\n     * @param {!Index} indexDefinition\n     * @return {?NamedNode}\n     */\n    ChildrenNode.prototype.getFirstChild = function (indexDefinition) {\n        var minKey = this.getFirstChildName(indexDefinition);\n        if (minKey) {\n            return new NamedNode(minKey, this.children_.get(minKey));\n        }\n        else {\n            return null;\n        }\n    };\n    /**\n     * Given an index, return the key name of the largest value we have, according to that index\n     * @param {!Index} indexDefinition\n     * @return {?string}\n     */\n    ChildrenNode.prototype.getLastChildName = function (indexDefinition) {\n        var idx = this.resolveIndex_(indexDefinition);\n        if (idx) {\n            var maxKey = idx.maxKey();\n            return maxKey && maxKey.name;\n        }\n        else {\n            return this.children_.maxKey();\n        }\n    };\n    /**\n     * @param {!Index} indexDefinition\n     * @return {?NamedNode}\n     */\n    ChildrenNode.prototype.getLastChild = function (indexDefinition) {\n        var maxKey = this.getLastChildName(indexDefinition);\n        if (maxKey) {\n            return new NamedNode(maxKey, this.children_.get(maxKey));\n        }\n        else {\n            return null;\n        }\n    };\n    /**\n     * @inheritDoc\n     */\n    ChildrenNode.prototype.forEachChild = function (index, action) {\n        var idx = this.resolveIndex_(index);\n        if (idx) {\n            return idx.inorderTraversal(function (wrappedNode) {\n                return action(wrappedNode.name, wrappedNode.node);\n            });\n        }\n        else {\n            return this.children_.inorderTraversal(action);\n        }\n    };\n    /**\n     * @param {!Index} indexDefinition\n     * @return {SortedMapIterator}\n     */\n    ChildrenNode.prototype.getIterator = function (indexDefinition) {\n        return this.getIteratorFrom(indexDefinition.minPost(), indexDefinition);\n    };\n    /**\n     *\n     * @param {!NamedNode} startPost\n     * @param {!Index} indexDefinition\n     * @return {!SortedMapIterator}\n     */\n    ChildrenNode.prototype.getIteratorFrom = function (startPost, indexDefinition) {\n        var idx = this.resolveIndex_(indexDefinition);\n        if (idx) {\n            return idx.getIteratorFrom(startPost, function (key) { return key; });\n        }\n        else {\n            var iterator = this.children_.getIteratorFrom(startPost.name, NamedNode.Wrap);\n            var next = iterator.peek();\n            while (next != null && indexDefinition.compare(next, startPost) < 0) {\n                iterator.getNext();\n                next = iterator.peek();\n            }\n            return iterator;\n        }\n    };\n    /**\n     * @param {!Index} indexDefinition\n     * @return {!SortedMapIterator}\n     */\n    ChildrenNode.prototype.getReverseIterator = function (indexDefinition) {\n        return this.getReverseIteratorFrom(indexDefinition.maxPost(), indexDefinition);\n    };\n    /**\n     * @param {!NamedNode} endPost\n     * @param {!Index} indexDefinition\n     * @return {!SortedMapIterator}\n     */\n    ChildrenNode.prototype.getReverseIteratorFrom = function (endPost, indexDefinition) {\n        var idx = this.resolveIndex_(indexDefinition);\n        if (idx) {\n            return idx.getReverseIteratorFrom(endPost, function (key) {\n                return key;\n            });\n        }\n        else {\n            var iterator = this.children_.getReverseIteratorFrom(endPost.name, NamedNode.Wrap);\n            var next = iterator.peek();\n            while (next != null && indexDefinition.compare(next, endPost) > 0) {\n                iterator.getNext();\n                next = iterator.peek();\n            }\n            return iterator;\n        }\n    };\n    /**\n     * @inheritDoc\n     */\n    ChildrenNode.prototype.compareTo = function (other) {\n        if (this.isEmpty()) {\n            if (other.isEmpty()) {\n                return 0;\n            }\n            else {\n                return -1;\n            }\n        }\n        else if (other.isLeafNode() || other.isEmpty()) {\n            return 1;\n        }\n        else if (other === MAX_NODE) {\n            return -1;\n        }\n        else {\n            // Must be another node with children.\n            return 0;\n        }\n    };\n    /**\n     * @inheritDoc\n     */\n    ChildrenNode.prototype.withIndex = function (indexDefinition) {\n        if (indexDefinition === KEY_INDEX ||\n            this.indexMap_.hasIndex(indexDefinition)) {\n            return this;\n        }\n        else {\n            var newIndexMap = this.indexMap_.addIndex(indexDefinition, this.children_);\n            return new ChildrenNode(this.children_, this.priorityNode_, newIndexMap);\n        }\n    };\n    /**\n     * @inheritDoc\n     */\n    ChildrenNode.prototype.isIndexed = function (index) {\n        return index === KEY_INDEX || this.indexMap_.hasIndex(index);\n    };\n    /**\n     * @inheritDoc\n     */\n    ChildrenNode.prototype.equals = function (other) {\n        if (other === this) {\n            return true;\n        }\n        else if (other.isLeafNode()) {\n            return false;\n        }\n        else {\n            var otherChildrenNode = other;\n            if (!this.getPriority().equals(otherChildrenNode.getPriority())) {\n                return false;\n            }\n            else if (this.children_.count() === otherChildrenNode.children_.count()) {\n                var thisIter = this.getIterator(PRIORITY_INDEX);\n                var otherIter = otherChildrenNode.getIterator(PRIORITY_INDEX);\n                var thisCurrent = thisIter.getNext();\n                var otherCurrent = otherIter.getNext();\n                while (thisCurrent && otherCurrent) {\n                    if (thisCurrent.name !== otherCurrent.name ||\n                        !thisCurrent.node.equals(otherCurrent.node)) {\n                        return false;\n                    }\n                    thisCurrent = thisIter.getNext();\n                    otherCurrent = otherIter.getNext();\n                }\n                return thisCurrent === null && otherCurrent === null;\n            }\n            else {\n                return false;\n            }\n        }\n    };\n    /**\n     * Returns a SortedMap ordered by index, or null if the default (by-key) ordering can be used\n     * instead.\n     *\n     * @private\n     * @param {!Index} indexDefinition\n     * @return {?SortedMap.<NamedNode, Node>}\n     */\n    ChildrenNode.prototype.resolveIndex_ = function (indexDefinition) {\n        if (indexDefinition === KEY_INDEX) {\n            return null;\n        }\n        else {\n            return this.indexMap_.get(indexDefinition.toString());\n        }\n    };\n    /**\n     * @private\n     * @type {RegExp}\n     */\n    ChildrenNode.INTEGER_REGEXP_ = /^(0|[1-9]\\d*)$/;\n    return ChildrenNode;\n}());\nexport { ChildrenNode };\n/**\n * @constructor\n * @extends {ChildrenNode}\n * @private\n */\nvar MaxNode = (function (_super) {\n    __extends(MaxNode, _super);\n    function MaxNode() {\n        return _super.call(this, new SortedMap(NAME_COMPARATOR), ChildrenNode.EMPTY_NODE, IndexMap.Default) || this;\n    }\n    MaxNode.prototype.compareTo = function (other) {\n        if (other === this) {\n            return 0;\n        }\n        else {\n            return 1;\n        }\n    };\n    MaxNode.prototype.equals = function (other) {\n        // Not that we every compare it, but MAX_NODE is only ever equal to itself\n        return other === this;\n    };\n    MaxNode.prototype.getPriority = function () {\n        return this;\n    };\n    MaxNode.prototype.getImmediateChild = function (childName) {\n        return ChildrenNode.EMPTY_NODE;\n    };\n    MaxNode.prototype.isEmpty = function () {\n        return false;\n    };\n    return MaxNode;\n}(ChildrenNode));\nexport { MaxNode };\n/**\n * Marker that will sort higher than any other snapshot.\n * @type {!MAX_NODE}\n * @const\n */\nexport var MAX_NODE = new MaxNode();\nObject.defineProperties(NamedNode, {\n    MIN: {\n        value: new NamedNode(MIN_NAME, ChildrenNode.EMPTY_NODE)\n    },\n    MAX: {\n        value: new NamedNode(MAX_NAME, MAX_NODE)\n    }\n});\n/**\n * Reference Extensions\n */\nKeyIndex.__EMPTY_NODE = ChildrenNode.EMPTY_NODE;\nLeafNode.__childrenNodeConstructor = ChildrenNode;\nsetMaxNode(MAX_NODE);\nsetPriorityMaxNode(MAX_NODE);\n\n\n"]}