{"version":3,"sources":["database/src/database/core/snap/childSet.ts"],"names":["LOG_2","Math","log","Base12Num","length","logBase2","num","parseInt","bitMask","bits","Array","join","count","current_","mask","bits_","prototype","nextBitIsOne","result","buildChildSet","childList","cmp","keyFn","mapSortFn","sort","buildBalancedTree","low","high","namedNode","key","node","BLACK","middle","left","right","buildFrom12Array","base12","root","index","buildPennant","chunkSize","color","childTree","attachPennant","pennant","i","isOne","pow","RED"],"mappings":"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","file":"childSet.js","sourcesContent":["/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\nimport { LLRBNode } from '../util/SortedMap';\nimport { SortedMap } from '../util/SortedMap';\nimport { NamedNode } from './Node';\n\nconst LOG_2 = Math.log(2);\n\n/**\n * @constructor\n */\nclass Base12Num {\n  count: number;\n  private current_: number;\n  private bits_: number;\n\n  /**\n   * @param {number} length\n   */\n  constructor(length: number) {\n    const logBase2 = (num: number) =>\n      parseInt((Math.log(num) / LOG_2) as any, 10);\n    const bitMask = (bits: number) => parseInt(Array(bits + 1).join('1'), 2);\n    this.count = logBase2(length + 1);\n    this.current_ = this.count - 1;\n    const mask = bitMask(this.count);\n    this.bits_ = (length + 1) & mask;\n  }\n\n  /**\n   * @return {boolean}\n   */\n  nextBitIsOne(): boolean {\n    //noinspection JSBitwiseOperatorUsage\n    const result = !(this.bits_ & (0x1 << this.current_));\n    this.current_--;\n    return result;\n  }\n}\n\n/**\n * Takes a list of child nodes and constructs a SortedSet using the given comparison\n * function\n *\n * Uses the algorithm described in the paper linked here:\n * http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.46.1458\n *\n * @template K, V\n * @param {Array.<!NamedNode>} childList Unsorted list of children\n * @param {function(!NamedNode, !NamedNode):number} cmp The comparison method to be used\n * @param {(function(NamedNode):K)=} keyFn An optional function to extract K from a node wrapper, if K's\n *                                                        type is not NamedNode\n * @param {(function(K, K):number)=} mapSortFn An optional override for comparator used by the generated sorted map\n * @return {SortedMap.<K, V>}\n */\nexport const buildChildSet = function<K, V>(\n  childList: NamedNode[],\n  cmp: (a: NamedNode, b: NamedNode) => number,\n  keyFn?: (a: NamedNode) => K,\n  mapSortFn?: (a: K, b: K) => number\n): SortedMap<K, V> {\n  childList.sort(cmp);\n\n  const buildBalancedTree = function(\n    low: number,\n    high: number\n  ): LLRBNode<K, V> | null {\n    const length = high - low;\n    let namedNode: NamedNode;\n    let key: K;\n    if (length == 0) {\n      return null;\n    } else if (length == 1) {\n      namedNode = childList[low];\n      key = keyFn ? keyFn(namedNode) : (namedNode as any) as K;\n      return new LLRBNode(\n        key,\n        (namedNode.node as any) as V,\n        LLRBNode.BLACK,\n        null,\n        null\n      );\n    } else {\n      const middle = parseInt((length / 2) as any, 10) + low;\n      const left = buildBalancedTree(low, middle);\n      const right = buildBalancedTree(middle + 1, high);\n      namedNode = childList[middle];\n      key = keyFn ? keyFn(namedNode) : (namedNode as any) as K;\n      return new LLRBNode(\n        key,\n        (namedNode.node as any) as V,\n        LLRBNode.BLACK,\n        left,\n        right\n      );\n    }\n  };\n\n  const buildFrom12Array = function(base12: Base12Num): LLRBNode<K, V> {\n    let node: LLRBNode<K, V> = null;\n    let root = null;\n    let index = childList.length;\n\n    const buildPennant = function(chunkSize: number, color: boolean) {\n      const low = index - chunkSize;\n      const high = index;\n      index -= chunkSize;\n      const childTree = buildBalancedTree(low + 1, high);\n      const namedNode = childList[low];\n      const key: K = keyFn ? keyFn(namedNode) : (namedNode as any) as K;\n      attachPennant(\n        new LLRBNode(key, (namedNode.node as any) as V, color, null, childTree)\n      );\n    };\n\n    const attachPennant = function(pennant: LLRBNode<K, V>) {\n      if (node) {\n        node.left = pennant;\n        node = pennant;\n      } else {\n        root = pennant;\n        node = pennant;\n      }\n    };\n\n    for (let i = 0; i < base12.count; ++i) {\n      const isOne = base12.nextBitIsOne();\n      // The number of nodes taken in each slice is 2^(arr.length - (i + 1))\n      const chunkSize = Math.pow(2, base12.count - (i + 1));\n      if (isOne) {\n        buildPennant(chunkSize, LLRBNode.BLACK);\n      } else {\n        // current == 2\n        buildPennant(chunkSize, LLRBNode.BLACK);\n        buildPennant(chunkSize, LLRBNode.RED);\n      }\n    }\n    return root;\n  };\n\n  const base12 = new Base12Num(childList.length);\n  const root = buildFrom12Array(base12);\n\n  return new SortedMap<K, V>(mapSortFn || (cmp as any), root);\n};\n"]}