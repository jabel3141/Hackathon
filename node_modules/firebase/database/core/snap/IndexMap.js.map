{"version":3,"sources":["database/src/database/core/snap/IndexMap.ts","database/core/snap/IndexMap.js"],"names":["_defaultIndexMap","fallbackObject","IndexMap","indexes_","indexSet_","Object","defineProperty","get","enumerable","configurable","prototype","indexKey","sortedMap","Error","hasIndex","indexDefinition","toString","addIndex","existingChildren","childList","sawIndexedValue","iter","getIterator","Wrap","next","getNext","isDefinedOn","node","push","newIndex","getCompare","indexName","newIndexSet","newIndexes","addToIndexes","namedNode","_this","indexedChildren","index","name","existingSnap","newChildren","remove","insert","removeFromIndexes"],"mappings":"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","file":"IndexMap.js","sourcesContent":["/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\nimport { assert } from '../../../utils/assert';\nimport { buildChildSet } from './childSet';\nimport { contains, clone, map, safeGet } from '../../../utils/obj';\nimport { NamedNode, Node } from './Node';\nimport { PRIORITY_INDEX } from './indexes/PriorityIndex';\nimport { KEY_INDEX } from './indexes/KeyIndex';\nimport { SortedMap } from '../util/SortedMap';\nimport { Index } from './indexes/Index';\n\nlet _defaultIndexMap: IndexMap;\n\nconst fallbackObject = {};\n\n/**\n *\n * @param {Object.<string, FallbackType|SortedMap.<NamedNode, Node>>} indexes\n * @param {Object.<string, Index>} indexSet\n * @constructor\n */\nexport class IndexMap {\n  /**\n   * The default IndexMap for nodes without a priority\n   * @type {!IndexMap}\n   * @const\n   */\n  static get Default(): IndexMap {\n    assert(\n      fallbackObject && PRIORITY_INDEX,\n      'ChildrenNode.ts has not been loaded'\n    );\n    _defaultIndexMap =\n      _defaultIndexMap ||\n      new IndexMap(\n        { '.priority': fallbackObject },\n        { '.priority': PRIORITY_INDEX }\n      );\n    return _defaultIndexMap;\n  }\n\n  constructor(\n    private indexes_: {\n      [k: string]: SortedMap<NamedNode, Node> | /*FallbackType*/ object;\n    },\n    private indexSet_: { [k: string]: Index }\n  ) {}\n\n  /**\n   *\n   * @param {!string} indexKey\n   * @return {?SortedMap.<NamedNode, Node>}\n   */\n  get(indexKey: string): SortedMap<NamedNode, Node> | null {\n    const sortedMap = safeGet(this.indexes_, indexKey);\n    if (!sortedMap) throw new Error('No index defined for ' + indexKey);\n\n    if (sortedMap === fallbackObject) {\n      // The index exists, but it falls back to just name comparison. Return null so that the calling code uses the\n      // regular child map\n      return null;\n    } else {\n      return sortedMap;\n    }\n  }\n\n  /**\n   * @param {!Index} indexDefinition\n   * @return {boolean}\n   */\n  hasIndex(indexDefinition: Index): boolean {\n    return contains(this.indexSet_, indexDefinition.toString());\n  }\n\n  /**\n   * @param {!Index} indexDefinition\n   * @param {!SortedMap.<string, !Node>} existingChildren\n   * @return {!IndexMap}\n   */\n  addIndex(\n    indexDefinition: Index,\n    existingChildren: SortedMap<string, Node>\n  ): IndexMap {\n    assert(\n      indexDefinition !== KEY_INDEX,\n      \"KeyIndex always exists and isn't meant to be added to the IndexMap.\"\n    );\n    const childList = [];\n    let sawIndexedValue = false;\n    const iter = existingChildren.getIterator(NamedNode.Wrap);\n    let next = iter.getNext();\n    while (next) {\n      sawIndexedValue =\n        sawIndexedValue || indexDefinition.isDefinedOn(next.node);\n      childList.push(next);\n      next = iter.getNext();\n    }\n    let newIndex;\n    if (sawIndexedValue) {\n      newIndex = buildChildSet(childList, indexDefinition.getCompare());\n    } else {\n      newIndex = fallbackObject;\n    }\n    const indexName = indexDefinition.toString();\n    const newIndexSet = clone(this.indexSet_);\n    newIndexSet[indexName] = indexDefinition;\n    const newIndexes = clone(this.indexes_);\n    newIndexes[indexName] = newIndex;\n    return new IndexMap(newIndexes, newIndexSet);\n  }\n\n  /**\n   * Ensure that this node is properly tracked in any indexes that we're maintaining\n   * @param {!NamedNode} namedNode\n   * @param {!SortedMap.<string, !Node>} existingChildren\n   * @return {!IndexMap}\n   */\n  addToIndexes(\n    namedNode: NamedNode,\n    existingChildren: SortedMap<string, Node>\n  ): IndexMap {\n    const newIndexes = map(\n      this.indexes_,\n      (indexedChildren: SortedMap<NamedNode, Node>, indexName: string) => {\n        const index = safeGet(this.indexSet_, indexName);\n        assert(index, 'Missing index implementation for ' + indexName);\n        if (indexedChildren === fallbackObject) {\n          // Check to see if we need to index everything\n          if (index.isDefinedOn(namedNode.node)) {\n            // We need to build this index\n            const childList = [];\n            const iter = existingChildren.getIterator(NamedNode.Wrap);\n            let next = iter.getNext();\n            while (next) {\n              if (next.name != namedNode.name) {\n                childList.push(next);\n              }\n              next = iter.getNext();\n            }\n            childList.push(namedNode);\n            return buildChildSet(childList, index.getCompare());\n          } else {\n            // No change, this remains a fallback\n            return fallbackObject;\n          }\n        } else {\n          const existingSnap = existingChildren.get(namedNode.name);\n          let newChildren = indexedChildren;\n          if (existingSnap) {\n            newChildren = newChildren.remove(\n              new NamedNode(namedNode.name, existingSnap)\n            );\n          }\n          return newChildren.insert(namedNode, namedNode.node);\n        }\n      }\n    );\n    return new IndexMap(newIndexes, this.indexSet_);\n  }\n\n  /**\n   * Create a new IndexMap instance with the given value removed\n   * @param {!NamedNode} namedNode\n   * @param {!SortedMap.<string, !Node>} existingChildren\n   * @return {!IndexMap}\n   */\n  removeFromIndexes(\n    namedNode: NamedNode,\n    existingChildren: SortedMap<string, Node>\n  ): IndexMap {\n    const newIndexes = map(this.indexes_, function(\n      indexedChildren: SortedMap<NamedNode, Node>\n    ) {\n      if (indexedChildren === fallbackObject) {\n        // This is the fallback. Just return it, nothing to do in this case\n        return indexedChildren;\n      } else {\n        const existingSnap = existingChildren.get(namedNode.name);\n        if (existingSnap) {\n          return indexedChildren.remove(\n            new NamedNode(namedNode.name, existingSnap)\n          );\n        } else {\n          // No record of this child\n          return indexedChildren;\n        }\n      }\n    });\n    return new IndexMap(newIndexes, this.indexSet_);\n  }\n}\n","/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\nimport { assert } from '../../../utils/assert';\nimport { buildChildSet } from './childSet';\nimport { contains, clone, map, safeGet } from '../../../utils/obj';\nimport { NamedNode } from './Node';\nimport { PRIORITY_INDEX } from './indexes/PriorityIndex';\nimport { KEY_INDEX } from './indexes/KeyIndex';\nvar _defaultIndexMap;\nvar fallbackObject = {};\n/**\n *\n * @param {Object.<string, FallbackType|SortedMap.<NamedNode, Node>>} indexes\n * @param {Object.<string, Index>} indexSet\n * @constructor\n */\nvar IndexMap = (function () {\n    function IndexMap(indexes_, indexSet_) {\n        this.indexes_ = indexes_;\n        this.indexSet_ = indexSet_;\n    }\n    Object.defineProperty(IndexMap, \"Default\", {\n        /**\n         * The default IndexMap for nodes without a priority\n         * @type {!IndexMap}\n         * @const\n         */\n        get: function () {\n            assert(fallbackObject && PRIORITY_INDEX, 'ChildrenNode.ts has not been loaded');\n            _defaultIndexMap =\n                _defaultIndexMap ||\n                    new IndexMap({ '.priority': fallbackObject }, { '.priority': PRIORITY_INDEX });\n            return _defaultIndexMap;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     *\n     * @param {!string} indexKey\n     * @return {?SortedMap.<NamedNode, Node>}\n     */\n    IndexMap.prototype.get = function (indexKey) {\n        var sortedMap = safeGet(this.indexes_, indexKey);\n        if (!sortedMap)\n            throw new Error('No index defined for ' + indexKey);\n        if (sortedMap === fallbackObject) {\n            // The index exists, but it falls back to just name comparison. Return null so that the calling code uses the\n            // regular child map\n            return null;\n        }\n        else {\n            return sortedMap;\n        }\n    };\n    /**\n     * @param {!Index} indexDefinition\n     * @return {boolean}\n     */\n    IndexMap.prototype.hasIndex = function (indexDefinition) {\n        return contains(this.indexSet_, indexDefinition.toString());\n    };\n    /**\n     * @param {!Index} indexDefinition\n     * @param {!SortedMap.<string, !Node>} existingChildren\n     * @return {!IndexMap}\n     */\n    IndexMap.prototype.addIndex = function (indexDefinition, existingChildren) {\n        assert(indexDefinition !== KEY_INDEX, \"KeyIndex always exists and isn't meant to be added to the IndexMap.\");\n        var childList = [];\n        var sawIndexedValue = false;\n        var iter = existingChildren.getIterator(NamedNode.Wrap);\n        var next = iter.getNext();\n        while (next) {\n            sawIndexedValue =\n                sawIndexedValue || indexDefinition.isDefinedOn(next.node);\n            childList.push(next);\n            next = iter.getNext();\n        }\n        var newIndex;\n        if (sawIndexedValue) {\n            newIndex = buildChildSet(childList, indexDefinition.getCompare());\n        }\n        else {\n            newIndex = fallbackObject;\n        }\n        var indexName = indexDefinition.toString();\n        var newIndexSet = clone(this.indexSet_);\n        newIndexSet[indexName] = indexDefinition;\n        var newIndexes = clone(this.indexes_);\n        newIndexes[indexName] = newIndex;\n        return new IndexMap(newIndexes, newIndexSet);\n    };\n    /**\n     * Ensure that this node is properly tracked in any indexes that we're maintaining\n     * @param {!NamedNode} namedNode\n     * @param {!SortedMap.<string, !Node>} existingChildren\n     * @return {!IndexMap}\n     */\n    IndexMap.prototype.addToIndexes = function (namedNode, existingChildren) {\n        var _this = this;\n        var newIndexes = map(this.indexes_, function (indexedChildren, indexName) {\n            var index = safeGet(_this.indexSet_, indexName);\n            assert(index, 'Missing index implementation for ' + indexName);\n            if (indexedChildren === fallbackObject) {\n                // Check to see if we need to index everything\n                if (index.isDefinedOn(namedNode.node)) {\n                    // We need to build this index\n                    var childList = [];\n                    var iter = existingChildren.getIterator(NamedNode.Wrap);\n                    var next = iter.getNext();\n                    while (next) {\n                        if (next.name != namedNode.name) {\n                            childList.push(next);\n                        }\n                        next = iter.getNext();\n                    }\n                    childList.push(namedNode);\n                    return buildChildSet(childList, index.getCompare());\n                }\n                else {\n                    // No change, this remains a fallback\n                    return fallbackObject;\n                }\n            }\n            else {\n                var existingSnap = existingChildren.get(namedNode.name);\n                var newChildren = indexedChildren;\n                if (existingSnap) {\n                    newChildren = newChildren.remove(new NamedNode(namedNode.name, existingSnap));\n                }\n                return newChildren.insert(namedNode, namedNode.node);\n            }\n        });\n        return new IndexMap(newIndexes, this.indexSet_);\n    };\n    /**\n     * Create a new IndexMap instance with the given value removed\n     * @param {!NamedNode} namedNode\n     * @param {!SortedMap.<string, !Node>} existingChildren\n     * @return {!IndexMap}\n     */\n    IndexMap.prototype.removeFromIndexes = function (namedNode, existingChildren) {\n        var newIndexes = map(this.indexes_, function (indexedChildren) {\n            if (indexedChildren === fallbackObject) {\n                // This is the fallback. Just return it, nothing to do in this case\n                return indexedChildren;\n            }\n            else {\n                var existingSnap = existingChildren.get(namedNode.name);\n                if (existingSnap) {\n                    return indexedChildren.remove(new NamedNode(namedNode.name, existingSnap));\n                }\n                else {\n                    // No record of this child\n                    return indexedChildren;\n                }\n            }\n        });\n        return new IndexMap(newIndexes, this.indexSet_);\n    };\n    return IndexMap;\n}());\nexport { IndexMap };\n\n\n"]}