{"version":3,"sources":["database/src/database/core/snap/LeafNode.ts","database/core/snap/LeafNode.js"],"names":["__childrenNodeConstructor","LeafNode","value_","priorityNode_","EMPTY_NODE","lazyHash_","undefined","Object","defineProperty","get","set","val","enumerable","configurable","prototype","isLeafNode","getPriority","updatePriority","newPriorityNode","getImmediateChild","childName","getChild","path","isEmpty","getFront","hasChild","getPredecessorChildName","childNode","updateImmediateChild","newChildNode","updateChild","front","getLength","popFront","numChildren","forEachChild","index","action","exportFormat","getValue","hash","toHash","type","compareTo","other","compareToLeafNode_","otherLeaf","otherLeafType","thisLeafType","otherIndex","VALUE_TYPE_ORDER","indexOf","thisIndex","withIndex","isIndexed","equals"],"mappings":"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","file":"LeafNode.js","sourcesContent":["/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\nimport { assert } from '../../../utils/assert';\nimport { doubleToIEEE754String, sha1 } from '../util/util';\nimport { priorityHashText, validatePriorityNode } from './snap';\nimport { Node } from './Node';\nimport { Path } from '../util/Path';\nimport { Index } from './indexes/Index';\nimport { ChildrenNodeConstructor } from './ChildrenNode';\n\nlet __childrenNodeConstructor: ChildrenNodeConstructor;\n\n/**\n * LeafNode is a class for storing leaf nodes in a DataSnapshot.  It\n * implements Node and stores the value of the node (a string,\n * number, or boolean) accessible via getValue().\n */\nexport class LeafNode implements Node {\n  static set __childrenNodeConstructor(val: ChildrenNodeConstructor) {\n    __childrenNodeConstructor = val;\n  }\n\n  static get __childrenNodeConstructor() {\n    return __childrenNodeConstructor;\n  }\n\n  /**\n   * The sort order for comparing leaf nodes of different types. If two leaf nodes have\n   * the same type, the comparison falls back to their value\n   * @type {Array.<!string>}\n   * @const\n   */\n  static VALUE_TYPE_ORDER = ['object', 'boolean', 'number', 'string'];\n\n  private lazyHash_: string | null = null;\n\n  /**\n   * @implements {Node}\n   * @param {!(string|number|boolean|Object)} value_ The value to store in this leaf node.\n   *                                         The object type is possible in the event of a deferred value\n   * @param {!Node=} priorityNode_ The priority of this node.\n   */\n  constructor(\n    private readonly value_: string | number | boolean | object,\n    private priorityNode_: Node = LeafNode.__childrenNodeConstructor.EMPTY_NODE\n  ) {\n    assert(\n      this.value_ !== undefined && this.value_ !== null,\n      \"LeafNode shouldn't be created with null/undefined value.\"\n    );\n\n    validatePriorityNode(this.priorityNode_);\n  }\n\n  /** @inheritDoc */\n  isLeafNode(): boolean {\n    return true;\n  }\n\n  /** @inheritDoc */\n  getPriority(): Node {\n    return this.priorityNode_;\n  }\n\n  /** @inheritDoc */\n  updatePriority(newPriorityNode: Node): Node {\n    return new LeafNode(this.value_, newPriorityNode);\n  }\n\n  /** @inheritDoc */\n  getImmediateChild(childName: string): Node {\n    // Hack to treat priority as a regular child\n    if (childName === '.priority') {\n      return this.priorityNode_;\n    } else {\n      return LeafNode.__childrenNodeConstructor.EMPTY_NODE;\n    }\n  }\n\n  /** @inheritDoc */\n  getChild(path: Path): Node {\n    if (path.isEmpty()) {\n      return this;\n    } else if (path.getFront() === '.priority') {\n      return this.priorityNode_;\n    } else {\n      return LeafNode.__childrenNodeConstructor.EMPTY_NODE;\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  hasChild(): boolean {\n    return false;\n  }\n\n  /** @inheritDoc */\n  getPredecessorChildName(childName: String, childNode: Node): null {\n    return null;\n  }\n\n  /** @inheritDoc */\n  updateImmediateChild(childName: string, newChildNode: Node): Node {\n    if (childName === '.priority') {\n      return this.updatePriority(newChildNode);\n    } else if (newChildNode.isEmpty() && childName !== '.priority') {\n      return this;\n    } else {\n      return LeafNode.__childrenNodeConstructor.EMPTY_NODE\n        .updateImmediateChild(childName, newChildNode)\n        .updatePriority(this.priorityNode_);\n    }\n  }\n\n  /** @inheritDoc */\n  updateChild(path: Path, newChildNode: Node): Node {\n    const front = path.getFront();\n    if (front === null) {\n      return newChildNode;\n    } else if (newChildNode.isEmpty() && front !== '.priority') {\n      return this;\n    } else {\n      assert(\n        front !== '.priority' || path.getLength() === 1,\n        '.priority must be the last token in a path'\n      );\n\n      return this.updateImmediateChild(\n        front,\n        LeafNode.__childrenNodeConstructor.EMPTY_NODE.updateChild(\n          path.popFront(),\n          newChildNode\n        )\n      );\n    }\n  }\n\n  /** @inheritDoc */\n  isEmpty(): boolean {\n    return false;\n  }\n\n  /** @inheritDoc */\n  numChildren(): number {\n    return 0;\n  }\n\n  /** @inheritDoc */\n  forEachChild(index: Index, action: (s: string, n: Node) => void): any {\n    return false;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  val(exportFormat?: boolean): Object {\n    if (exportFormat && !this.getPriority().isEmpty())\n      return {\n        '.value': this.getValue(),\n        '.priority': this.getPriority().val()\n      };\n    else return this.getValue();\n  }\n\n  /** @inheritDoc */\n  hash(): string {\n    if (this.lazyHash_ === null) {\n      let toHash = '';\n      if (!this.priorityNode_.isEmpty())\n        toHash +=\n          'priority:' +\n          priorityHashText(this.priorityNode_.val() as number | string) +\n          ':';\n\n      const type = typeof this.value_;\n      toHash += type + ':';\n      if (type === 'number') {\n        toHash += doubleToIEEE754String(this.value_ as number);\n      } else {\n        toHash += this.value_;\n      }\n      this.lazyHash_ = sha1(toHash);\n    }\n    return this.lazyHash_;\n  }\n\n  /**\n   * Returns the value of the leaf node.\n   * @return {Object|string|number|boolean} The value of the node.\n   */\n  getValue(): object | string | number | boolean {\n    return this.value_;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  compareTo(other: Node): number {\n    if (other === LeafNode.__childrenNodeConstructor.EMPTY_NODE) {\n      return 1;\n    } else if (other instanceof LeafNode.__childrenNodeConstructor) {\n      return -1;\n    } else {\n      assert(other.isLeafNode(), 'Unknown node type');\n      return this.compareToLeafNode_(other as LeafNode);\n    }\n  }\n\n  /**\n   * Comparison specifically for two leaf nodes\n   * @param {!LeafNode} otherLeaf\n   * @return {!number}\n   * @private\n   */\n  private compareToLeafNode_(otherLeaf: LeafNode): number {\n    const otherLeafType = typeof otherLeaf.value_;\n    const thisLeafType = typeof this.value_;\n    const otherIndex = LeafNode.VALUE_TYPE_ORDER.indexOf(otherLeafType);\n    const thisIndex = LeafNode.VALUE_TYPE_ORDER.indexOf(thisLeafType);\n    assert(otherIndex >= 0, 'Unknown leaf type: ' + otherLeafType);\n    assert(thisIndex >= 0, 'Unknown leaf type: ' + thisLeafType);\n    if (otherIndex === thisIndex) {\n      // Same type, compare values\n      if (thisLeafType === 'object') {\n        // Deferred value nodes are all equal, but we should also never get to this point...\n        return 0;\n      } else {\n        // Note that this works because true > false, all others are number or string comparisons\n        if (this.value_ < otherLeaf.value_) {\n          return -1;\n        } else if (this.value_ === otherLeaf.value_) {\n          return 0;\n        } else {\n          return 1;\n        }\n      }\n    } else {\n      return thisIndex - otherIndex;\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  withIndex(): Node {\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  isIndexed(): boolean {\n    return true;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  equals(other: Node): boolean {\n    /**\n     * @inheritDoc\n     */\n    if (other === this) {\n      return true;\n    } else if (other.isLeafNode()) {\n      const otherLeaf = other as LeafNode;\n      return (\n        this.value_ === otherLeaf.value_ &&\n        this.priorityNode_.equals(otherLeaf.priorityNode_)\n      );\n    } else {\n      return false;\n    }\n  }\n}\n","/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\nimport { assert } from '../../../utils/assert';\nimport { doubleToIEEE754String, sha1 } from '../util/util';\nimport { priorityHashText, validatePriorityNode } from './snap';\nvar __childrenNodeConstructor;\n/**\n * LeafNode is a class for storing leaf nodes in a DataSnapshot.  It\n * implements Node and stores the value of the node (a string,\n * number, or boolean) accessible via getValue().\n */\nvar LeafNode = (function () {\n    /**\n     * @implements {Node}\n     * @param {!(string|number|boolean|Object)} value_ The value to store in this leaf node.\n     *                                         The object type is possible in the event of a deferred value\n     * @param {!Node=} priorityNode_ The priority of this node.\n     */\n    function LeafNode(value_, priorityNode_) {\n        if (priorityNode_ === void 0) { priorityNode_ = LeafNode.__childrenNodeConstructor.EMPTY_NODE; }\n        this.value_ = value_;\n        this.priorityNode_ = priorityNode_;\n        this.lazyHash_ = null;\n        assert(this.value_ !== undefined && this.value_ !== null, \"LeafNode shouldn't be created with null/undefined value.\");\n        validatePriorityNode(this.priorityNode_);\n    }\n    Object.defineProperty(LeafNode, \"__childrenNodeConstructor\", {\n        get: function () {\n            return __childrenNodeConstructor;\n        },\n        set: function (val) {\n            __childrenNodeConstructor = val;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /** @inheritDoc */\n    LeafNode.prototype.isLeafNode = function () {\n        return true;\n    };\n    /** @inheritDoc */\n    LeafNode.prototype.getPriority = function () {\n        return this.priorityNode_;\n    };\n    /** @inheritDoc */\n    LeafNode.prototype.updatePriority = function (newPriorityNode) {\n        return new LeafNode(this.value_, newPriorityNode);\n    };\n    /** @inheritDoc */\n    LeafNode.prototype.getImmediateChild = function (childName) {\n        // Hack to treat priority as a regular child\n        if (childName === '.priority') {\n            return this.priorityNode_;\n        }\n        else {\n            return LeafNode.__childrenNodeConstructor.EMPTY_NODE;\n        }\n    };\n    /** @inheritDoc */\n    LeafNode.prototype.getChild = function (path) {\n        if (path.isEmpty()) {\n            return this;\n        }\n        else if (path.getFront() === '.priority') {\n            return this.priorityNode_;\n        }\n        else {\n            return LeafNode.__childrenNodeConstructor.EMPTY_NODE;\n        }\n    };\n    /**\n     * @inheritDoc\n     */\n    LeafNode.prototype.hasChild = function () {\n        return false;\n    };\n    /** @inheritDoc */\n    LeafNode.prototype.getPredecessorChildName = function (childName, childNode) {\n        return null;\n    };\n    /** @inheritDoc */\n    LeafNode.prototype.updateImmediateChild = function (childName, newChildNode) {\n        if (childName === '.priority') {\n            return this.updatePriority(newChildNode);\n        }\n        else if (newChildNode.isEmpty() && childName !== '.priority') {\n            return this;\n        }\n        else {\n            return LeafNode.__childrenNodeConstructor.EMPTY_NODE\n                .updateImmediateChild(childName, newChildNode)\n                .updatePriority(this.priorityNode_);\n        }\n    };\n    /** @inheritDoc */\n    LeafNode.prototype.updateChild = function (path, newChildNode) {\n        var front = path.getFront();\n        if (front === null) {\n            return newChildNode;\n        }\n        else if (newChildNode.isEmpty() && front !== '.priority') {\n            return this;\n        }\n        else {\n            assert(front !== '.priority' || path.getLength() === 1, '.priority must be the last token in a path');\n            return this.updateImmediateChild(front, LeafNode.__childrenNodeConstructor.EMPTY_NODE.updateChild(path.popFront(), newChildNode));\n        }\n    };\n    /** @inheritDoc */\n    LeafNode.prototype.isEmpty = function () {\n        return false;\n    };\n    /** @inheritDoc */\n    LeafNode.prototype.numChildren = function () {\n        return 0;\n    };\n    /** @inheritDoc */\n    LeafNode.prototype.forEachChild = function (index, action) {\n        return false;\n    };\n    /**\n     * @inheritDoc\n     */\n    LeafNode.prototype.val = function (exportFormat) {\n        if (exportFormat && !this.getPriority().isEmpty())\n            return {\n                '.value': this.getValue(),\n                '.priority': this.getPriority().val()\n            };\n        else\n            return this.getValue();\n    };\n    /** @inheritDoc */\n    LeafNode.prototype.hash = function () {\n        if (this.lazyHash_ === null) {\n            var toHash = '';\n            if (!this.priorityNode_.isEmpty())\n                toHash +=\n                    'priority:' +\n                        priorityHashText(this.priorityNode_.val()) +\n                        ':';\n            var type = typeof this.value_;\n            toHash += type + ':';\n            if (type === 'number') {\n                toHash += doubleToIEEE754String(this.value_);\n            }\n            else {\n                toHash += this.value_;\n            }\n            this.lazyHash_ = sha1(toHash);\n        }\n        return this.lazyHash_;\n    };\n    /**\n     * Returns the value of the leaf node.\n     * @return {Object|string|number|boolean} The value of the node.\n     */\n    LeafNode.prototype.getValue = function () {\n        return this.value_;\n    };\n    /**\n     * @inheritDoc\n     */\n    LeafNode.prototype.compareTo = function (other) {\n        if (other === LeafNode.__childrenNodeConstructor.EMPTY_NODE) {\n            return 1;\n        }\n        else if (other instanceof LeafNode.__childrenNodeConstructor) {\n            return -1;\n        }\n        else {\n            assert(other.isLeafNode(), 'Unknown node type');\n            return this.compareToLeafNode_(other);\n        }\n    };\n    /**\n     * Comparison specifically for two leaf nodes\n     * @param {!LeafNode} otherLeaf\n     * @return {!number}\n     * @private\n     */\n    LeafNode.prototype.compareToLeafNode_ = function (otherLeaf) {\n        var otherLeafType = typeof otherLeaf.value_;\n        var thisLeafType = typeof this.value_;\n        var otherIndex = LeafNode.VALUE_TYPE_ORDER.indexOf(otherLeafType);\n        var thisIndex = LeafNode.VALUE_TYPE_ORDER.indexOf(thisLeafType);\n        assert(otherIndex >= 0, 'Unknown leaf type: ' + otherLeafType);\n        assert(thisIndex >= 0, 'Unknown leaf type: ' + thisLeafType);\n        if (otherIndex === thisIndex) {\n            // Same type, compare values\n            if (thisLeafType === 'object') {\n                // Deferred value nodes are all equal, but we should also never get to this point...\n                return 0;\n            }\n            else {\n                // Note that this works because true > false, all others are number or string comparisons\n                if (this.value_ < otherLeaf.value_) {\n                    return -1;\n                }\n                else if (this.value_ === otherLeaf.value_) {\n                    return 0;\n                }\n                else {\n                    return 1;\n                }\n            }\n        }\n        else {\n            return thisIndex - otherIndex;\n        }\n    };\n    /**\n     * @inheritDoc\n     */\n    LeafNode.prototype.withIndex = function () {\n        return this;\n    };\n    /**\n     * @inheritDoc\n     */\n    LeafNode.prototype.isIndexed = function () {\n        return true;\n    };\n    /**\n     * @inheritDoc\n     */\n    LeafNode.prototype.equals = function (other) {\n        /**\n         * @inheritDoc\n         */\n        if (other === this) {\n            return true;\n        }\n        else if (other.isLeafNode()) {\n            var otherLeaf = other;\n            return (this.value_ === otherLeaf.value_ &&\n                this.priorityNode_.equals(otherLeaf.priorityNode_));\n        }\n        else {\n            return false;\n        }\n    };\n    /**\n     * The sort order for comparing leaf nodes of different types. If two leaf nodes have\n     * the same type, the comparison falls back to their value\n     * @type {Array.<!string>}\n     * @const\n     */\n    LeafNode.VALUE_TYPE_ORDER = ['object', 'boolean', 'number', 'string'];\n    return LeafNode;\n}());\nexport { LeafNode };\n\n\n"]}