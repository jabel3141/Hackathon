{"version":3,"sources":["src/database/core/WriteTree.ts","database/core/WriteTree.js"],"names":["WriteTree","visibleWrites_","Empty","allWrites_","lastWriteId_","prototype","childWrites","path","WriteTreeRef","addOverwrite","snap","writeId","visible","undefined","push","addWrite","addMerge","changedChildren","children","addWrites","getWrite","i","length","record","removeWrite","_this","idx","findIndex","s","writeToRemove","splice","removedWriteWasVisible","removedWriteOverlapsWithOtherWrites","currentWrite","recordContainsPath_","contains","resetTree_","childName","child","getCompleteWriteData","getCompleteNode","calcCompleteEventCache","treePath","completeServerCache","writeIdsToExclude","includeHiddenWrites","shadowingNode","subMerge","childCompoundWrite","isEmpty","hasCompleteWrite","layeredCache","EMPTY_NODE","apply","merge","filter","write","indexOf","mergeAtPath","layerTree_","calcCompleteEventChildren","completeServerChildren","completeChildren","topLevelSet","isLeafNode","forEachChild","childSnap","updateImmediateChild","merge_1","childNode","node","getCompleteChildren","forEach","namedNode","name","calcEventCacheAfterServerOverwrite","childPath","existingEventSnap","existingServerSnap","childMerge","getChild","calcCompleteChild","childKey","isCompleteForChild","getNode","getImmediateChild","shadowingWrite","calcIndexedSlice","completeServerData","startPost","count","reverse","index","toIterate","withIndex","nodes","cmp","getCompare","iter","getReverseIteratorFrom","getIteratorFrom","next","getNext","writeRecord","DefaultFilter_","writes","treeRoot","compoundWrite","writePath","relativePath","getFront","deepNode","popFront","writeTree","treePath_","writeTree_","existingServerCache"],"mappings":"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","file":"WriteTree.js","sourcesContent":["/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\nimport { findKey, forEach, safeGet } from '../../utils/obj';\nimport { assert, assertionError } from '../../utils/assert';\nimport { Path } from './util/Path';\nimport { CompoundWrite } from './CompoundWrite';\nimport { PRIORITY_INDEX } from './snap/indexes/PriorityIndex';\nimport { ChildrenNode } from './snap/ChildrenNode';\nimport { NamedNode, Node } from './snap/Node';\nimport { CacheNode } from './view/CacheNode';\nimport { Index } from './snap/indexes/Index';\n\n/**\n * Defines a single user-initiated write operation. May be the result of a set(), transaction(), or update() call. In\n * the case of a set() or transaction, snap wil be non-null.  In the case of an update(), children will be non-null.\n */\nexport interface WriteRecord {\n  writeId: number;\n  path: Path;\n  snap?: Node | null;\n  children?: { [k: string]: Node } | null;\n  visible: boolean;\n}\n\n/**\n * WriteTree tracks all pending user-initiated writes and has methods to calculate the result of merging them\n * with underlying server data (to create \"event cache\" data).  Pending writes are added with addOverwrite()\n * and addMerge(), and removed with removeWrite().\n *\n * @constructor\n */\nexport class WriteTree {\n  /**\n   * A tree tracking the result of applying all visible writes.  This does not include transactions with\n   * applyLocally=false or writes that are completely shadowed by other writes.\n   *\n   * @type {!CompoundWrite}\n   * @private\n   */\n  private visibleWrites_: CompoundWrite = CompoundWrite.Empty;\n\n  /**\n   * A list of all pending writes, regardless of visibility and shadowed-ness.  Used to calculate arbitrary\n   * sets of the changed data, such as hidden writes (from transactions) or changes with certain writes excluded (also\n   * used by transactions).\n   *\n   * @type {!Array.<!WriteRecord>}\n   * @private\n   */\n  private allWrites_: WriteRecord[] = [];\n\n  private lastWriteId_ = -1;\n\n  /**\n   * Create a new WriteTreeRef for the given path. For use with a new sync point at the given path.\n   *\n   * @param {!Path} path\n   * @return {!WriteTreeRef}\n   */\n  childWrites(path: Path): WriteTreeRef {\n    return new WriteTreeRef(path, this);\n  }\n\n  /**\n   * Record a new overwrite from user code.\n   *\n   * @param {!Path} path\n   * @param {!Node} snap\n   * @param {!number} writeId\n   * @param {boolean=} visible This is set to false by some transactions. It should be excluded from event caches\n   */\n  addOverwrite(path: Path, snap: Node, writeId: number, visible?: boolean) {\n    assert(\n      writeId > this.lastWriteId_,\n      'Stacking an older write on top of newer ones'\n    );\n    if (visible === undefined) {\n      visible = true;\n    }\n    this.allWrites_.push({\n      path: path,\n      snap: snap,\n      writeId: writeId,\n      visible: visible\n    });\n\n    if (visible) {\n      this.visibleWrites_ = this.visibleWrites_.addWrite(path, snap);\n    }\n    this.lastWriteId_ = writeId;\n  }\n\n  /**\n   * Record a new merge from user code.\n   *\n   * @param {!Path} path\n   * @param {!Object.<string, !Node>} changedChildren\n   * @param {!number} writeId\n   */\n  addMerge(\n    path: Path,\n    changedChildren: { [k: string]: Node },\n    writeId: number\n  ) {\n    assert(\n      writeId > this.lastWriteId_,\n      'Stacking an older merge on top of newer ones'\n    );\n    this.allWrites_.push({\n      path: path,\n      children: changedChildren,\n      writeId: writeId,\n      visible: true\n    });\n\n    this.visibleWrites_ = this.visibleWrites_.addWrites(path, changedChildren);\n    this.lastWriteId_ = writeId;\n  }\n\n  /**\n   * @param {!number} writeId\n   * @return {?WriteRecord}\n   */\n  getWrite(writeId: number): WriteRecord | null {\n    for (let i = 0; i < this.allWrites_.length; i++) {\n      const record = this.allWrites_[i];\n      if (record.writeId === writeId) {\n        return record;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Remove a write (either an overwrite or merge) that has been successfully acknowledge by the server. Recalculates\n   * the tree if necessary.  We return true if it may have been visible, meaning views need to reevaluate.\n   *\n   * @param {!number} writeId\n   * @return {boolean} true if the write may have been visible (meaning we'll need to reevaluate / raise\n   * events as a result).\n   */\n  removeWrite(writeId: number): boolean {\n    // Note: disabling this check. It could be a transaction that preempted another transaction, and thus was applied\n    // out of order.\n    //const validClear = revert || this.allWrites_.length === 0 || writeId <= this.allWrites_[0].writeId;\n    //assert(validClear, \"Either we don't have this write, or it's the first one in the queue\");\n\n    const idx = this.allWrites_.findIndex(function(s) {\n      return s.writeId === writeId;\n    });\n    assert(idx >= 0, 'removeWrite called with nonexistent writeId.');\n    const writeToRemove = this.allWrites_[idx];\n    this.allWrites_.splice(idx, 1);\n\n    let removedWriteWasVisible = writeToRemove.visible;\n    let removedWriteOverlapsWithOtherWrites = false;\n\n    let i = this.allWrites_.length - 1;\n\n    while (removedWriteWasVisible && i >= 0) {\n      const currentWrite = this.allWrites_[i];\n      if (currentWrite.visible) {\n        if (\n          i >= idx &&\n          this.recordContainsPath_(currentWrite, writeToRemove.path)\n        ) {\n          // The removed write was completely shadowed by a subsequent write.\n          removedWriteWasVisible = false;\n        } else if (writeToRemove.path.contains(currentWrite.path)) {\n          // Either we're covering some writes or they're covering part of us (depending on which came first).\n          removedWriteOverlapsWithOtherWrites = true;\n        }\n      }\n      i--;\n    }\n\n    if (!removedWriteWasVisible) {\n      return false;\n    } else if (removedWriteOverlapsWithOtherWrites) {\n      // There's some shadowing going on. Just rebuild the visible writes from scratch.\n      this.resetTree_();\n      return true;\n    } else {\n      // There's no shadowing.  We can safely just remove the write(s) from visibleWrites.\n      if (writeToRemove.snap) {\n        this.visibleWrites_ = this.visibleWrites_.removeWrite(\n          writeToRemove.path\n        );\n      } else {\n        const children = writeToRemove.children;\n        forEach(children, (childName: string) => {\n          this.visibleWrites_ = this.visibleWrites_.removeWrite(\n            writeToRemove.path.child(childName)\n          );\n        });\n      }\n      return true;\n    }\n  }\n\n  /**\n   * Return a complete snapshot for the given path if there's visible write data at that path, else null.\n   * No server data is considered.\n   *\n   * @param {!Path} path\n   * @return {?Node}\n   */\n  getCompleteWriteData(path: Path): Node | null {\n    return this.visibleWrites_.getCompleteNode(path);\n  }\n\n  /**\n   * Given optional, underlying server data, and an optional set of constraints (exclude some sets, include hidden\n   * writes), attempt to calculate a complete snapshot for the given path\n   *\n   * @param {!Path} treePath\n   * @param {?Node} completeServerCache\n   * @param {Array.<number>=} writeIdsToExclude An optional set to be excluded\n   * @param {boolean=} includeHiddenWrites Defaults to false, whether or not to layer on writes with visible set to false\n   * @return {?Node}\n   */\n  calcCompleteEventCache(\n    treePath: Path,\n    completeServerCache: Node | null,\n    writeIdsToExclude?: number[],\n    includeHiddenWrites?: boolean\n  ): Node | null {\n    if (!writeIdsToExclude && !includeHiddenWrites) {\n      const shadowingNode = this.visibleWrites_.getCompleteNode(treePath);\n      if (shadowingNode != null) {\n        return shadowingNode;\n      } else {\n        const subMerge = this.visibleWrites_.childCompoundWrite(treePath);\n        if (subMerge.isEmpty()) {\n          return completeServerCache;\n        } else if (\n          completeServerCache == null &&\n          !subMerge.hasCompleteWrite(Path.Empty)\n        ) {\n          // We wouldn't have a complete snapshot, since there's no underlying data and no complete shadow\n          return null;\n        } else {\n          const layeredCache = completeServerCache || ChildrenNode.EMPTY_NODE;\n          return subMerge.apply(layeredCache);\n        }\n      }\n    } else {\n      const merge = this.visibleWrites_.childCompoundWrite(treePath);\n      if (!includeHiddenWrites && merge.isEmpty()) {\n        return completeServerCache;\n      } else {\n        // If the server cache is null, and we don't have a complete cache, we need to return null\n        if (\n          !includeHiddenWrites &&\n          completeServerCache == null &&\n          !merge.hasCompleteWrite(Path.Empty)\n        ) {\n          return null;\n        } else {\n          const filter = function(write: WriteRecord) {\n            return (\n              (write.visible || includeHiddenWrites) &&\n              (!writeIdsToExclude ||\n                !~writeIdsToExclude.indexOf(write.writeId)) &&\n              (write.path.contains(treePath) || treePath.contains(write.path))\n            );\n          };\n          const mergeAtPath = WriteTree.layerTree_(\n            this.allWrites_,\n            filter,\n            treePath\n          );\n          const layeredCache = completeServerCache || ChildrenNode.EMPTY_NODE;\n          return mergeAtPath.apply(layeredCache);\n        }\n      }\n    }\n  }\n\n  /**\n   * With optional, underlying server data, attempt to return a children node of children that we have complete data for.\n   * Used when creating new views, to pre-fill their complete event children snapshot.\n   *\n   * @param {!Path} treePath\n   * @param {?ChildrenNode} completeServerChildren\n   * @return {!ChildrenNode}\n   */\n  calcCompleteEventChildren(\n    treePath: Path,\n    completeServerChildren: ChildrenNode | null\n  ) {\n    let completeChildren = ChildrenNode.EMPTY_NODE as Node;\n    const topLevelSet = this.visibleWrites_.getCompleteNode(treePath);\n    if (topLevelSet) {\n      if (!topLevelSet.isLeafNode()) {\n        // we're shadowing everything. Return the children.\n        topLevelSet.forEachChild(PRIORITY_INDEX, function(\n          childName,\n          childSnap\n        ) {\n          completeChildren = completeChildren.updateImmediateChild(\n            childName,\n            childSnap\n          );\n        });\n      }\n      return completeChildren;\n    } else if (completeServerChildren) {\n      // Layer any children we have on top of this\n      // We know we don't have a top-level set, so just enumerate existing children\n      const merge = this.visibleWrites_.childCompoundWrite(treePath);\n      completeServerChildren.forEachChild(PRIORITY_INDEX, function(\n        childName,\n        childNode\n      ) {\n        const node = merge\n          .childCompoundWrite(new Path(childName))\n          .apply(childNode);\n        completeChildren = completeChildren.updateImmediateChild(\n          childName,\n          node\n        );\n      });\n      // Add any complete children we have from the set\n      merge.getCompleteChildren().forEach(function(namedNode) {\n        completeChildren = completeChildren.updateImmediateChild(\n          namedNode.name,\n          namedNode.node\n        );\n      });\n      return completeChildren;\n    } else {\n      // We don't have anything to layer on top of. Layer on any children we have\n      // Note that we can return an empty snap if we have a defined delete\n      const merge = this.visibleWrites_.childCompoundWrite(treePath);\n      merge.getCompleteChildren().forEach(function(namedNode) {\n        completeChildren = completeChildren.updateImmediateChild(\n          namedNode.name,\n          namedNode.node\n        );\n      });\n      return completeChildren;\n    }\n  }\n\n  /**\n   * Given that the underlying server data has updated, determine what, if anything, needs to be\n   * applied to the event cache.\n   *\n   * Possibilities:\n   *\n   * 1. No writes are shadowing. Events should be raised, the snap to be applied comes from the server data\n   *\n   * 2. Some write is completely shadowing. No events to be raised\n   *\n   * 3. Is partially shadowed. Events\n   *\n   * Either existingEventSnap or existingServerSnap must exist\n   *\n   * @param {!Path} treePath\n   * @param {!Path} childPath\n   * @param {?Node} existingEventSnap\n   * @param {?Node} existingServerSnap\n   * @return {?Node}\n   */\n  calcEventCacheAfterServerOverwrite(\n    treePath: Path,\n    childPath: Path,\n    existingEventSnap: Node | null,\n    existingServerSnap: Node | null\n  ): Node | null {\n    assert(\n      existingEventSnap || existingServerSnap,\n      'Either existingEventSnap or existingServerSnap must exist'\n    );\n    const path = treePath.child(childPath);\n    if (this.visibleWrites_.hasCompleteWrite(path)) {\n      // At this point we can probably guarantee that we're in case 2, meaning no events\n      // May need to check visibility while doing the findRootMostValueAndPath call\n      return null;\n    } else {\n      // No complete shadowing. We're either partially shadowing or not shadowing at all.\n      const childMerge = this.visibleWrites_.childCompoundWrite(path);\n      if (childMerge.isEmpty()) {\n        // We're not shadowing at all. Case 1\n        return existingServerSnap.getChild(childPath);\n      } else {\n        // This could be more efficient if the serverNode + updates doesn't change the eventSnap\n        // However this is tricky to find out, since user updates don't necessary change the server\n        // snap, e.g. priority updates on empty nodes, or deep deletes. Another special case is if the server\n        // adds nodes, but doesn't change any existing writes. It is therefore not enough to\n        // only check if the updates change the serverNode.\n        // Maybe check if the merge tree contains these special cases and only do a full overwrite in that case?\n        return childMerge.apply(existingServerSnap.getChild(childPath));\n      }\n    }\n  }\n\n  /**\n   * Returns a complete child for a given server snap after applying all user writes or null if there is no\n   * complete child for this ChildKey.\n   *\n   * @param {!Path} treePath\n   * @param {!string} childKey\n   * @param {!CacheNode} existingServerSnap\n   * @return {?Node}\n   */\n  calcCompleteChild(\n    treePath: Path,\n    childKey: string,\n    existingServerSnap: CacheNode\n  ): Node | null {\n    const path = treePath.child(childKey);\n    const shadowingNode = this.visibleWrites_.getCompleteNode(path);\n    if (shadowingNode != null) {\n      return shadowingNode;\n    } else {\n      if (existingServerSnap.isCompleteForChild(childKey)) {\n        const childMerge = this.visibleWrites_.childCompoundWrite(path);\n        return childMerge.apply(\n          existingServerSnap.getNode().getImmediateChild(childKey)\n        );\n      } else {\n        return null;\n      }\n    }\n  }\n\n  /**\n   * Returns a node if there is a complete overwrite for this path. More specifically, if there is a write at\n   * a higher path, this will return the child of that write relative to the write and this path.\n   * Returns null if there is no write at this path.\n   *\n   * @param {!Path} path\n   * @return {?Node}\n   */\n  shadowingWrite(path: Path): Node | null {\n    return this.visibleWrites_.getCompleteNode(path);\n  }\n\n  /**\n   * This method is used when processing child remove events on a query. If we can, we pull in children that were outside\n   * the window, but may now be in the window.\n   *\n   * @param {!Path} treePath\n   * @param {?Node} completeServerData\n   * @param {!NamedNode} startPost\n   * @param {!number} count\n   * @param {boolean} reverse\n   * @param {!Index} index\n   * @return {!Array.<!NamedNode>}\n   */\n  calcIndexedSlice(\n    treePath: Path,\n    completeServerData: Node | null,\n    startPost: NamedNode,\n    count: number,\n    reverse: boolean,\n    index: Index\n  ): NamedNode[] {\n    let toIterate: Node;\n    const merge = this.visibleWrites_.childCompoundWrite(treePath);\n    const shadowingNode = merge.getCompleteNode(Path.Empty);\n    if (shadowingNode != null) {\n      toIterate = shadowingNode;\n    } else if (completeServerData != null) {\n      toIterate = merge.apply(completeServerData);\n    } else {\n      // no children to iterate on\n      return [];\n    }\n    toIterate = toIterate.withIndex(index);\n    if (!toIterate.isEmpty() && !toIterate.isLeafNode()) {\n      const nodes = [];\n      const cmp = index.getCompare();\n      const iter = reverse\n        ? (toIterate as ChildrenNode).getReverseIteratorFrom(startPost, index)\n        : (toIterate as ChildrenNode).getIteratorFrom(startPost, index);\n      let next = iter.getNext();\n      while (next && nodes.length < count) {\n        if (cmp(next, startPost) !== 0) {\n          nodes.push(next);\n        }\n        next = iter.getNext();\n      }\n      return nodes;\n    } else {\n      return [];\n    }\n  }\n\n  /**\n   * @param {!WriteRecord} writeRecord\n   * @param {!Path} path\n   * @return {boolean}\n   * @private\n   */\n  private recordContainsPath_(writeRecord: WriteRecord, path: Path): boolean {\n    if (writeRecord.snap) {\n      return writeRecord.path.contains(path);\n    } else {\n      // findKey can return undefined, so use !! to coerce to boolean\n      return !!findKey(writeRecord.children, function(\n        childSnap: Node,\n        childName: string\n      ) {\n        return writeRecord.path.child(childName).contains(path);\n      });\n    }\n  }\n\n  /**\n   * Re-layer the writes and merges into a tree so we can efficiently calculate event snapshots\n   * @private\n   */\n  private resetTree_() {\n    this.visibleWrites_ = WriteTree.layerTree_(\n      this.allWrites_,\n      WriteTree.DefaultFilter_,\n      Path.Empty\n    );\n    if (this.allWrites_.length > 0) {\n      this.lastWriteId_ = this.allWrites_[this.allWrites_.length - 1].writeId;\n    } else {\n      this.lastWriteId_ = -1;\n    }\n  }\n\n  /**\n   * The default filter used when constructing the tree. Keep everything that's visible.\n   *\n   * @param {!WriteRecord} write\n   * @return {boolean}\n   * @private\n   */\n  private static DefaultFilter_(write: WriteRecord) {\n    return write.visible;\n  }\n\n  /**\n   * Static method. Given an array of WriteRecords, a filter for which ones to include, and a path, construct the tree of\n   * event data at that path.\n   *\n   * @param {!Array.<!WriteRecord>} writes\n   * @param {!function(!WriteRecord):boolean} filter\n   * @param {!Path} treeRoot\n   * @return {!CompoundWrite}\n   * @private\n   */\n  private static layerTree_(\n    writes: WriteRecord[],\n    filter: (w: WriteRecord) => boolean,\n    treeRoot: Path\n  ): CompoundWrite {\n    let compoundWrite = CompoundWrite.Empty;\n    for (let i = 0; i < writes.length; ++i) {\n      const write = writes[i];\n      // Theory, a later set will either:\n      // a) abort a relevant transaction, so no need to worry about excluding it from calculating that transaction\n      // b) not be relevant to a transaction (separate branch), so again will not affect the data for that transaction\n      if (filter(write)) {\n        const writePath = write.path;\n        let relativePath;\n        if (write.snap) {\n          if (treeRoot.contains(writePath)) {\n            relativePath = Path.relativePath(treeRoot, writePath);\n            compoundWrite = compoundWrite.addWrite(relativePath, write.snap);\n          } else if (writePath.contains(treeRoot)) {\n            relativePath = Path.relativePath(writePath, treeRoot);\n            compoundWrite = compoundWrite.addWrite(\n              Path.Empty,\n              write.snap.getChild(relativePath)\n            );\n          } else {\n            // There is no overlap between root path and write path, ignore write\n          }\n        } else if (write.children) {\n          if (treeRoot.contains(writePath)) {\n            relativePath = Path.relativePath(treeRoot, writePath);\n            compoundWrite = compoundWrite.addWrites(\n              relativePath,\n              write.children\n            );\n          } else if (writePath.contains(treeRoot)) {\n            relativePath = Path.relativePath(writePath, treeRoot);\n            if (relativePath.isEmpty()) {\n              compoundWrite = compoundWrite.addWrites(\n                Path.Empty,\n                write.children\n              );\n            } else {\n              const child = safeGet(write.children, relativePath.getFront());\n              if (child) {\n                // There exists a child in this node that matches the root path\n                const deepNode = child.getChild(relativePath.popFront());\n                compoundWrite = compoundWrite.addWrite(Path.Empty, deepNode);\n              }\n            }\n          } else {\n            // There is no overlap between root path and write path, ignore write\n          }\n        } else {\n          throw assertionError('WriteRecord should have .snap or .children');\n        }\n      }\n    }\n    return compoundWrite;\n  }\n}\n\n/**\n * A WriteTreeRef wraps a WriteTree and a path, for convenient access to a particular subtree.  All of the methods\n * just proxy to the underlying WriteTree.\n *\n * @constructor\n */\nexport class WriteTreeRef {\n  /**\n   * The path to this particular write tree ref. Used for calling methods on writeTree_ while exposing a simpler\n   * interface to callers.\n   *\n   * @type {!Path}\n   * @private\n   * @const\n   */\n  private readonly treePath_: Path;\n\n  /**\n   * * A reference to the actual tree of write data. All methods are pass-through to the tree, but with the appropriate\n   * path prefixed.\n   *\n   * This lets us make cheap references to points in the tree for sync points without having to copy and maintain all of\n   * the data.\n   *\n   * @type {!WriteTree}\n   * @private\n   * @const\n   */\n  private readonly writeTree_: WriteTree;\n\n  /**\n   * @param {!Path} path\n   * @param {!WriteTree} writeTree\n   */\n  constructor(path: Path, writeTree: WriteTree) {\n    this.treePath_ = path;\n    this.writeTree_ = writeTree;\n  }\n\n  /**\n   * If possible, returns a complete event cache, using the underlying server data if possible. In addition, can be used\n   * to get a cache that includes hidden writes, and excludes arbitrary writes. Note that customizing the returned node\n   * can lead to a more expensive calculation.\n   *\n   * @param {?Node} completeServerCache\n   * @param {Array.<number>=} writeIdsToExclude Optional writes to exclude.\n   * @param {boolean=} includeHiddenWrites Defaults to false, whether or not to layer on writes with visible set to false\n   * @return {?Node}\n   */\n  calcCompleteEventCache(\n    completeServerCache: Node | null,\n    writeIdsToExclude?: number[],\n    includeHiddenWrites?: boolean\n  ): Node | null {\n    return this.writeTree_.calcCompleteEventCache(\n      this.treePath_,\n      completeServerCache,\n      writeIdsToExclude,\n      includeHiddenWrites\n    );\n  }\n\n  /**\n   * If possible, returns a children node containing all of the complete children we have data for. The returned data is a\n   * mix of the given server data and write data.\n   *\n   * @param {?ChildrenNode} completeServerChildren\n   * @return {!ChildrenNode}\n   */\n  calcCompleteEventChildren(completeServerChildren: ChildrenNode | null): ChildrenNode {\n    return this.writeTree_.calcCompleteEventChildren(\n      this.treePath_,\n      completeServerChildren\n    ) as ChildrenNode;\n  }\n\n  /**\n   * Given that either the underlying server data has updated or the outstanding writes have updated, determine what,\n   * if anything, needs to be applied to the event cache.\n   *\n   * Possibilities:\n   *\n   * 1. No writes are shadowing. Events should be raised, the snap to be applied comes from the server data\n   *\n   * 2. Some write is completely shadowing. No events to be raised\n   *\n   * 3. Is partially shadowed. Events should be raised\n   *\n   * Either existingEventSnap or existingServerSnap must exist, this is validated via an assert\n   *\n   * @param {!Path} path\n   * @param {?Node} existingEventSnap\n   * @param {?Node} existingServerSnap\n   * @return {?Node}\n   */\n  calcEventCacheAfterServerOverwrite(\n    path: Path,\n    existingEventSnap: Node | null,\n    existingServerSnap: Node | null\n  ): Node | null {\n    return this.writeTree_.calcEventCacheAfterServerOverwrite(\n      this.treePath_,\n      path,\n      existingEventSnap,\n      existingServerSnap\n    );\n  }\n\n  /**\n   * Returns a node if there is a complete overwrite for this path. More specifically, if there is a write at\n   * a higher path, this will return the child of that write relative to the write and this path.\n   * Returns null if there is no write at this path.\n   *\n   * @param {!Path} path\n   * @return {?Node}\n   */\n  shadowingWrite(path: Path): Node | null {\n    return this.writeTree_.shadowingWrite(this.treePath_.child(path));\n  }\n\n  /**\n   * This method is used when processing child remove events on a query. If we can, we pull in children that were outside\n   * the window, but may now be in the window\n   *\n   * @param {?Node} completeServerData\n   * @param {!NamedNode} startPost\n   * @param {!number} count\n   * @param {boolean} reverse\n   * @param {!Index} index\n   * @return {!Array.<!NamedNode>}\n   */\n  calcIndexedSlice(\n    completeServerData: Node | null,\n    startPost: NamedNode,\n    count: number,\n    reverse: boolean,\n    index: Index\n  ): NamedNode[] {\n    return this.writeTree_.calcIndexedSlice(\n      this.treePath_,\n      completeServerData,\n      startPost,\n      count,\n      reverse,\n      index\n    );\n  }\n\n  /**\n   * Returns a complete child for a given server snap after applying all user writes or null if there is no\n   * complete child for this ChildKey.\n   *\n   * @param {!string} childKey\n   * @param {!CacheNode} existingServerCache\n   * @return {?Node}\n   */\n  calcCompleteChild(\n    childKey: string,\n    existingServerCache: CacheNode\n  ): Node | null {\n    return this.writeTree_.calcCompleteChild(\n      this.treePath_,\n      childKey,\n      existingServerCache\n    );\n  }\n\n  /**\n   * Return a WriteTreeRef for a child.\n   *\n   * @param {string} childName\n   * @return {!WriteTreeRef}\n   */\n  child(childName: string): WriteTreeRef {\n    return new WriteTreeRef(this.treePath_.child(childName), this.writeTree_);\n  }\n}\n","/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\nimport { findKey, forEach, safeGet } from '../../utils/obj';\nimport { assert, assertionError } from '../../utils/assert';\nimport { Path } from './util/Path';\nimport { CompoundWrite } from './CompoundWrite';\nimport { PRIORITY_INDEX } from './snap/indexes/PriorityIndex';\nimport { ChildrenNode } from './snap/ChildrenNode';\n/**\n * WriteTree tracks all pending user-initiated writes and has methods to calculate the result of merging them\n * with underlying server data (to create \"event cache\" data).  Pending writes are added with addOverwrite()\n * and addMerge(), and removed with removeWrite().\n *\n * @constructor\n */\nvar WriteTree = (function () {\n    function WriteTree() {\n        /**\n         * A tree tracking the result of applying all visible writes.  This does not include transactions with\n         * applyLocally=false or writes that are completely shadowed by other writes.\n         *\n         * @type {!CompoundWrite}\n         * @private\n         */\n        this.visibleWrites_ = CompoundWrite.Empty;\n        /**\n         * A list of all pending writes, regardless of visibility and shadowed-ness.  Used to calculate arbitrary\n         * sets of the changed data, such as hidden writes (from transactions) or changes with certain writes excluded (also\n         * used by transactions).\n         *\n         * @type {!Array.<!WriteRecord>}\n         * @private\n         */\n        this.allWrites_ = [];\n        this.lastWriteId_ = -1;\n    }\n    /**\n     * Create a new WriteTreeRef for the given path. For use with a new sync point at the given path.\n     *\n     * @param {!Path} path\n     * @return {!WriteTreeRef}\n     */\n    WriteTree.prototype.childWrites = function (path) {\n        return new WriteTreeRef(path, this);\n    };\n    /**\n     * Record a new overwrite from user code.\n     *\n     * @param {!Path} path\n     * @param {!Node} snap\n     * @param {!number} writeId\n     * @param {boolean=} visible This is set to false by some transactions. It should be excluded from event caches\n     */\n    WriteTree.prototype.addOverwrite = function (path, snap, writeId, visible) {\n        assert(writeId > this.lastWriteId_, 'Stacking an older write on top of newer ones');\n        if (visible === undefined) {\n            visible = true;\n        }\n        this.allWrites_.push({\n            path: path,\n            snap: snap,\n            writeId: writeId,\n            visible: visible\n        });\n        if (visible) {\n            this.visibleWrites_ = this.visibleWrites_.addWrite(path, snap);\n        }\n        this.lastWriteId_ = writeId;\n    };\n    /**\n     * Record a new merge from user code.\n     *\n     * @param {!Path} path\n     * @param {!Object.<string, !Node>} changedChildren\n     * @param {!number} writeId\n     */\n    WriteTree.prototype.addMerge = function (path, changedChildren, writeId) {\n        assert(writeId > this.lastWriteId_, 'Stacking an older merge on top of newer ones');\n        this.allWrites_.push({\n            path: path,\n            children: changedChildren,\n            writeId: writeId,\n            visible: true\n        });\n        this.visibleWrites_ = this.visibleWrites_.addWrites(path, changedChildren);\n        this.lastWriteId_ = writeId;\n    };\n    /**\n     * @param {!number} writeId\n     * @return {?WriteRecord}\n     */\n    WriteTree.prototype.getWrite = function (writeId) {\n        for (var i = 0; i < this.allWrites_.length; i++) {\n            var record = this.allWrites_[i];\n            if (record.writeId === writeId) {\n                return record;\n            }\n        }\n        return null;\n    };\n    /**\n     * Remove a write (either an overwrite or merge) that has been successfully acknowledge by the server. Recalculates\n     * the tree if necessary.  We return true if it may have been visible, meaning views need to reevaluate.\n     *\n     * @param {!number} writeId\n     * @return {boolean} true if the write may have been visible (meaning we'll need to reevaluate / raise\n     * events as a result).\n     */\n    WriteTree.prototype.removeWrite = function (writeId) {\n        // Note: disabling this check. It could be a transaction that preempted another transaction, and thus was applied\n        // out of order.\n        //const validClear = revert || this.allWrites_.length === 0 || writeId <= this.allWrites_[0].writeId;\n        //assert(validClear, \"Either we don't have this write, or it's the first one in the queue\");\n        var _this = this;\n        var idx = this.allWrites_.findIndex(function (s) {\n            return s.writeId === writeId;\n        });\n        assert(idx >= 0, 'removeWrite called with nonexistent writeId.');\n        var writeToRemove = this.allWrites_[idx];\n        this.allWrites_.splice(idx, 1);\n        var removedWriteWasVisible = writeToRemove.visible;\n        var removedWriteOverlapsWithOtherWrites = false;\n        var i = this.allWrites_.length - 1;\n        while (removedWriteWasVisible && i >= 0) {\n            var currentWrite = this.allWrites_[i];\n            if (currentWrite.visible) {\n                if (i >= idx &&\n                    this.recordContainsPath_(currentWrite, writeToRemove.path)) {\n                    // The removed write was completely shadowed by a subsequent write.\n                    removedWriteWasVisible = false;\n                }\n                else if (writeToRemove.path.contains(currentWrite.path)) {\n                    // Either we're covering some writes or they're covering part of us (depending on which came first).\n                    removedWriteOverlapsWithOtherWrites = true;\n                }\n            }\n            i--;\n        }\n        if (!removedWriteWasVisible) {\n            return false;\n        }\n        else if (removedWriteOverlapsWithOtherWrites) {\n            // There's some shadowing going on. Just rebuild the visible writes from scratch.\n            this.resetTree_();\n            return true;\n        }\n        else {\n            // There's no shadowing.  We can safely just remove the write(s) from visibleWrites.\n            if (writeToRemove.snap) {\n                this.visibleWrites_ = this.visibleWrites_.removeWrite(writeToRemove.path);\n            }\n            else {\n                var children = writeToRemove.children;\n                forEach(children, function (childName) {\n                    _this.visibleWrites_ = _this.visibleWrites_.removeWrite(writeToRemove.path.child(childName));\n                });\n            }\n            return true;\n        }\n    };\n    /**\n     * Return a complete snapshot for the given path if there's visible write data at that path, else null.\n     * No server data is considered.\n     *\n     * @param {!Path} path\n     * @return {?Node}\n     */\n    WriteTree.prototype.getCompleteWriteData = function (path) {\n        return this.visibleWrites_.getCompleteNode(path);\n    };\n    /**\n     * Given optional, underlying server data, and an optional set of constraints (exclude some sets, include hidden\n     * writes), attempt to calculate a complete snapshot for the given path\n     *\n     * @param {!Path} treePath\n     * @param {?Node} completeServerCache\n     * @param {Array.<number>=} writeIdsToExclude An optional set to be excluded\n     * @param {boolean=} includeHiddenWrites Defaults to false, whether or not to layer on writes with visible set to false\n     * @return {?Node}\n     */\n    WriteTree.prototype.calcCompleteEventCache = function (treePath, completeServerCache, writeIdsToExclude, includeHiddenWrites) {\n        if (!writeIdsToExclude && !includeHiddenWrites) {\n            var shadowingNode = this.visibleWrites_.getCompleteNode(treePath);\n            if (shadowingNode != null) {\n                return shadowingNode;\n            }\n            else {\n                var subMerge = this.visibleWrites_.childCompoundWrite(treePath);\n                if (subMerge.isEmpty()) {\n                    return completeServerCache;\n                }\n                else if (completeServerCache == null &&\n                    !subMerge.hasCompleteWrite(Path.Empty)) {\n                    // We wouldn't have a complete snapshot, since there's no underlying data and no complete shadow\n                    return null;\n                }\n                else {\n                    var layeredCache = completeServerCache || ChildrenNode.EMPTY_NODE;\n                    return subMerge.apply(layeredCache);\n                }\n            }\n        }\n        else {\n            var merge = this.visibleWrites_.childCompoundWrite(treePath);\n            if (!includeHiddenWrites && merge.isEmpty()) {\n                return completeServerCache;\n            }\n            else {\n                // If the server cache is null, and we don't have a complete cache, we need to return null\n                if (!includeHiddenWrites &&\n                    completeServerCache == null &&\n                    !merge.hasCompleteWrite(Path.Empty)) {\n                    return null;\n                }\n                else {\n                    var filter = function (write) {\n                        return ((write.visible || includeHiddenWrites) &&\n                            (!writeIdsToExclude ||\n                                !~writeIdsToExclude.indexOf(write.writeId)) &&\n                            (write.path.contains(treePath) || treePath.contains(write.path)));\n                    };\n                    var mergeAtPath = WriteTree.layerTree_(this.allWrites_, filter, treePath);\n                    var layeredCache = completeServerCache || ChildrenNode.EMPTY_NODE;\n                    return mergeAtPath.apply(layeredCache);\n                }\n            }\n        }\n    };\n    /**\n     * With optional, underlying server data, attempt to return a children node of children that we have complete data for.\n     * Used when creating new views, to pre-fill their complete event children snapshot.\n     *\n     * @param {!Path} treePath\n     * @param {?ChildrenNode} completeServerChildren\n     * @return {!ChildrenNode}\n     */\n    WriteTree.prototype.calcCompleteEventChildren = function (treePath, completeServerChildren) {\n        var completeChildren = ChildrenNode.EMPTY_NODE;\n        var topLevelSet = this.visibleWrites_.getCompleteNode(treePath);\n        if (topLevelSet) {\n            if (!topLevelSet.isLeafNode()) {\n                // we're shadowing everything. Return the children.\n                topLevelSet.forEachChild(PRIORITY_INDEX, function (childName, childSnap) {\n                    completeChildren = completeChildren.updateImmediateChild(childName, childSnap);\n                });\n            }\n            return completeChildren;\n        }\n        else if (completeServerChildren) {\n            // Layer any children we have on top of this\n            // We know we don't have a top-level set, so just enumerate existing children\n            var merge_1 = this.visibleWrites_.childCompoundWrite(treePath);\n            completeServerChildren.forEachChild(PRIORITY_INDEX, function (childName, childNode) {\n                var node = merge_1\n                    .childCompoundWrite(new Path(childName))\n                    .apply(childNode);\n                completeChildren = completeChildren.updateImmediateChild(childName, node);\n            });\n            // Add any complete children we have from the set\n            merge_1.getCompleteChildren().forEach(function (namedNode) {\n                completeChildren = completeChildren.updateImmediateChild(namedNode.name, namedNode.node);\n            });\n            return completeChildren;\n        }\n        else {\n            // We don't have anything to layer on top of. Layer on any children we have\n            // Note that we can return an empty snap if we have a defined delete\n            var merge = this.visibleWrites_.childCompoundWrite(treePath);\n            merge.getCompleteChildren().forEach(function (namedNode) {\n                completeChildren = completeChildren.updateImmediateChild(namedNode.name, namedNode.node);\n            });\n            return completeChildren;\n        }\n    };\n    /**\n     * Given that the underlying server data has updated, determine what, if anything, needs to be\n     * applied to the event cache.\n     *\n     * Possibilities:\n     *\n     * 1. No writes are shadowing. Events should be raised, the snap to be applied comes from the server data\n     *\n     * 2. Some write is completely shadowing. No events to be raised\n     *\n     * 3. Is partially shadowed. Events\n     *\n     * Either existingEventSnap or existingServerSnap must exist\n     *\n     * @param {!Path} treePath\n     * @param {!Path} childPath\n     * @param {?Node} existingEventSnap\n     * @param {?Node} existingServerSnap\n     * @return {?Node}\n     */\n    WriteTree.prototype.calcEventCacheAfterServerOverwrite = function (treePath, childPath, existingEventSnap, existingServerSnap) {\n        assert(existingEventSnap || existingServerSnap, 'Either existingEventSnap or existingServerSnap must exist');\n        var path = treePath.child(childPath);\n        if (this.visibleWrites_.hasCompleteWrite(path)) {\n            // At this point we can probably guarantee that we're in case 2, meaning no events\n            // May need to check visibility while doing the findRootMostValueAndPath call\n            return null;\n        }\n        else {\n            // No complete shadowing. We're either partially shadowing or not shadowing at all.\n            var childMerge = this.visibleWrites_.childCompoundWrite(path);\n            if (childMerge.isEmpty()) {\n                // We're not shadowing at all. Case 1\n                return existingServerSnap.getChild(childPath);\n            }\n            else {\n                // This could be more efficient if the serverNode + updates doesn't change the eventSnap\n                // However this is tricky to find out, since user updates don't necessary change the server\n                // snap, e.g. priority updates on empty nodes, or deep deletes. Another special case is if the server\n                // adds nodes, but doesn't change any existing writes. It is therefore not enough to\n                // only check if the updates change the serverNode.\n                // Maybe check if the merge tree contains these special cases and only do a full overwrite in that case?\n                return childMerge.apply(existingServerSnap.getChild(childPath));\n            }\n        }\n    };\n    /**\n     * Returns a complete child for a given server snap after applying all user writes or null if there is no\n     * complete child for this ChildKey.\n     *\n     * @param {!Path} treePath\n     * @param {!string} childKey\n     * @param {!CacheNode} existingServerSnap\n     * @return {?Node}\n     */\n    WriteTree.prototype.calcCompleteChild = function (treePath, childKey, existingServerSnap) {\n        var path = treePath.child(childKey);\n        var shadowingNode = this.visibleWrites_.getCompleteNode(path);\n        if (shadowingNode != null) {\n            return shadowingNode;\n        }\n        else {\n            if (existingServerSnap.isCompleteForChild(childKey)) {\n                var childMerge = this.visibleWrites_.childCompoundWrite(path);\n                return childMerge.apply(existingServerSnap.getNode().getImmediateChild(childKey));\n            }\n            else {\n                return null;\n            }\n        }\n    };\n    /**\n     * Returns a node if there is a complete overwrite for this path. More specifically, if there is a write at\n     * a higher path, this will return the child of that write relative to the write and this path.\n     * Returns null if there is no write at this path.\n     *\n     * @param {!Path} path\n     * @return {?Node}\n     */\n    WriteTree.prototype.shadowingWrite = function (path) {\n        return this.visibleWrites_.getCompleteNode(path);\n    };\n    /**\n     * This method is used when processing child remove events on a query. If we can, we pull in children that were outside\n     * the window, but may now be in the window.\n     *\n     * @param {!Path} treePath\n     * @param {?Node} completeServerData\n     * @param {!NamedNode} startPost\n     * @param {!number} count\n     * @param {boolean} reverse\n     * @param {!Index} index\n     * @return {!Array.<!NamedNode>}\n     */\n    WriteTree.prototype.calcIndexedSlice = function (treePath, completeServerData, startPost, count, reverse, index) {\n        var toIterate;\n        var merge = this.visibleWrites_.childCompoundWrite(treePath);\n        var shadowingNode = merge.getCompleteNode(Path.Empty);\n        if (shadowingNode != null) {\n            toIterate = shadowingNode;\n        }\n        else if (completeServerData != null) {\n            toIterate = merge.apply(completeServerData);\n        }\n        else {\n            // no children to iterate on\n            return [];\n        }\n        toIterate = toIterate.withIndex(index);\n        if (!toIterate.isEmpty() && !toIterate.isLeafNode()) {\n            var nodes = [];\n            var cmp = index.getCompare();\n            var iter = reverse\n                ? toIterate.getReverseIteratorFrom(startPost, index)\n                : toIterate.getIteratorFrom(startPost, index);\n            var next = iter.getNext();\n            while (next && nodes.length < count) {\n                if (cmp(next, startPost) !== 0) {\n                    nodes.push(next);\n                }\n                next = iter.getNext();\n            }\n            return nodes;\n        }\n        else {\n            return [];\n        }\n    };\n    /**\n     * @param {!WriteRecord} writeRecord\n     * @param {!Path} path\n     * @return {boolean}\n     * @private\n     */\n    WriteTree.prototype.recordContainsPath_ = function (writeRecord, path) {\n        if (writeRecord.snap) {\n            return writeRecord.path.contains(path);\n        }\n        else {\n            // findKey can return undefined, so use !! to coerce to boolean\n            return !!findKey(writeRecord.children, function (childSnap, childName) {\n                return writeRecord.path.child(childName).contains(path);\n            });\n        }\n    };\n    /**\n     * Re-layer the writes and merges into a tree so we can efficiently calculate event snapshots\n     * @private\n     */\n    WriteTree.prototype.resetTree_ = function () {\n        this.visibleWrites_ = WriteTree.layerTree_(this.allWrites_, WriteTree.DefaultFilter_, Path.Empty);\n        if (this.allWrites_.length > 0) {\n            this.lastWriteId_ = this.allWrites_[this.allWrites_.length - 1].writeId;\n        }\n        else {\n            this.lastWriteId_ = -1;\n        }\n    };\n    /**\n     * The default filter used when constructing the tree. Keep everything that's visible.\n     *\n     * @param {!WriteRecord} write\n     * @return {boolean}\n     * @private\n     */\n    WriteTree.DefaultFilter_ = function (write) {\n        return write.visible;\n    };\n    /**\n     * Static method. Given an array of WriteRecords, a filter for which ones to include, and a path, construct the tree of\n     * event data at that path.\n     *\n     * @param {!Array.<!WriteRecord>} writes\n     * @param {!function(!WriteRecord):boolean} filter\n     * @param {!Path} treeRoot\n     * @return {!CompoundWrite}\n     * @private\n     */\n    WriteTree.layerTree_ = function (writes, filter, treeRoot) {\n        var compoundWrite = CompoundWrite.Empty;\n        for (var i = 0; i < writes.length; ++i) {\n            var write = writes[i];\n            // Theory, a later set will either:\n            // a) abort a relevant transaction, so no need to worry about excluding it from calculating that transaction\n            // b) not be relevant to a transaction (separate branch), so again will not affect the data for that transaction\n            if (filter(write)) {\n                var writePath = write.path;\n                var relativePath = void 0;\n                if (write.snap) {\n                    if (treeRoot.contains(writePath)) {\n                        relativePath = Path.relativePath(treeRoot, writePath);\n                        compoundWrite = compoundWrite.addWrite(relativePath, write.snap);\n                    }\n                    else if (writePath.contains(treeRoot)) {\n                        relativePath = Path.relativePath(writePath, treeRoot);\n                        compoundWrite = compoundWrite.addWrite(Path.Empty, write.snap.getChild(relativePath));\n                    }\n                    else {\n                        // There is no overlap between root path and write path, ignore write\n                    }\n                }\n                else if (write.children) {\n                    if (treeRoot.contains(writePath)) {\n                        relativePath = Path.relativePath(treeRoot, writePath);\n                        compoundWrite = compoundWrite.addWrites(relativePath, write.children);\n                    }\n                    else if (writePath.contains(treeRoot)) {\n                        relativePath = Path.relativePath(writePath, treeRoot);\n                        if (relativePath.isEmpty()) {\n                            compoundWrite = compoundWrite.addWrites(Path.Empty, write.children);\n                        }\n                        else {\n                            var child = safeGet(write.children, relativePath.getFront());\n                            if (child) {\n                                // There exists a child in this node that matches the root path\n                                var deepNode = child.getChild(relativePath.popFront());\n                                compoundWrite = compoundWrite.addWrite(Path.Empty, deepNode);\n                            }\n                        }\n                    }\n                    else {\n                        // There is no overlap between root path and write path, ignore write\n                    }\n                }\n                else {\n                    throw assertionError('WriteRecord should have .snap or .children');\n                }\n            }\n        }\n        return compoundWrite;\n    };\n    return WriteTree;\n}());\nexport { WriteTree };\n/**\n * A WriteTreeRef wraps a WriteTree and a path, for convenient access to a particular subtree.  All of the methods\n * just proxy to the underlying WriteTree.\n *\n * @constructor\n */\nvar WriteTreeRef = (function () {\n    /**\n     * @param {!Path} path\n     * @param {!WriteTree} writeTree\n     */\n    function WriteTreeRef(path, writeTree) {\n        this.treePath_ = path;\n        this.writeTree_ = writeTree;\n    }\n    /**\n     * If possible, returns a complete event cache, using the underlying server data if possible. In addition, can be used\n     * to get a cache that includes hidden writes, and excludes arbitrary writes. Note that customizing the returned node\n     * can lead to a more expensive calculation.\n     *\n     * @param {?Node} completeServerCache\n     * @param {Array.<number>=} writeIdsToExclude Optional writes to exclude.\n     * @param {boolean=} includeHiddenWrites Defaults to false, whether or not to layer on writes with visible set to false\n     * @return {?Node}\n     */\n    WriteTreeRef.prototype.calcCompleteEventCache = function (completeServerCache, writeIdsToExclude, includeHiddenWrites) {\n        return this.writeTree_.calcCompleteEventCache(this.treePath_, completeServerCache, writeIdsToExclude, includeHiddenWrites);\n    };\n    /**\n     * If possible, returns a children node containing all of the complete children we have data for. The returned data is a\n     * mix of the given server data and write data.\n     *\n     * @param {?ChildrenNode} completeServerChildren\n     * @return {!ChildrenNode}\n     */\n    WriteTreeRef.prototype.calcCompleteEventChildren = function (completeServerChildren) {\n        return this.writeTree_.calcCompleteEventChildren(this.treePath_, completeServerChildren);\n    };\n    /**\n     * Given that either the underlying server data has updated or the outstanding writes have updated, determine what,\n     * if anything, needs to be applied to the event cache.\n     *\n     * Possibilities:\n     *\n     * 1. No writes are shadowing. Events should be raised, the snap to be applied comes from the server data\n     *\n     * 2. Some write is completely shadowing. No events to be raised\n     *\n     * 3. Is partially shadowed. Events should be raised\n     *\n     * Either existingEventSnap or existingServerSnap must exist, this is validated via an assert\n     *\n     * @param {!Path} path\n     * @param {?Node} existingEventSnap\n     * @param {?Node} existingServerSnap\n     * @return {?Node}\n     */\n    WriteTreeRef.prototype.calcEventCacheAfterServerOverwrite = function (path, existingEventSnap, existingServerSnap) {\n        return this.writeTree_.calcEventCacheAfterServerOverwrite(this.treePath_, path, existingEventSnap, existingServerSnap);\n    };\n    /**\n     * Returns a node if there is a complete overwrite for this path. More specifically, if there is a write at\n     * a higher path, this will return the child of that write relative to the write and this path.\n     * Returns null if there is no write at this path.\n     *\n     * @param {!Path} path\n     * @return {?Node}\n     */\n    WriteTreeRef.prototype.shadowingWrite = function (path) {\n        return this.writeTree_.shadowingWrite(this.treePath_.child(path));\n    };\n    /**\n     * This method is used when processing child remove events on a query. If we can, we pull in children that were outside\n     * the window, but may now be in the window\n     *\n     * @param {?Node} completeServerData\n     * @param {!NamedNode} startPost\n     * @param {!number} count\n     * @param {boolean} reverse\n     * @param {!Index} index\n     * @return {!Array.<!NamedNode>}\n     */\n    WriteTreeRef.prototype.calcIndexedSlice = function (completeServerData, startPost, count, reverse, index) {\n        return this.writeTree_.calcIndexedSlice(this.treePath_, completeServerData, startPost, count, reverse, index);\n    };\n    /**\n     * Returns a complete child for a given server snap after applying all user writes or null if there is no\n     * complete child for this ChildKey.\n     *\n     * @param {!string} childKey\n     * @param {!CacheNode} existingServerCache\n     * @return {?Node}\n     */\n    WriteTreeRef.prototype.calcCompleteChild = function (childKey, existingServerCache) {\n        return this.writeTree_.calcCompleteChild(this.treePath_, childKey, existingServerCache);\n    };\n    /**\n     * Return a WriteTreeRef for a child.\n     *\n     * @param {string} childName\n     * @return {!WriteTreeRef}\n     */\n    WriteTreeRef.prototype.child = function (childName) {\n        return new WriteTreeRef(this.treePath_.child(childName), this.writeTree_);\n    };\n    return WriteTreeRef;\n}());\nexport { WriteTreeRef };\n\n\n"]}