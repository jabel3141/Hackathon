{"version":3,"sources":["database/src/database/core/stats/StatsReporter.ts","database/core/stats/StatsReporter.js"],"names":["FIRST_STATS_MIN_TIME","FIRST_STATS_MAX_TIME","REPORT_STATS_INTERVAL","StatsReporter","collection","server_","statsToReport_","statsListener_","timeout","Math","random","reportStats_","bind","floor","prototype","includeStat","stat","_this","stats","get","reportedStats","haveStatsToReport","value","reportStats"],"mappings":";;;;;;;AAgBA;;AACA;;AACA;;AAIA;AACA;AACA;AACA,IAAMA,uBAAuB,KAAK,IAAlC,C,CAzBA;;;;;;;;;;;;;;;;AA0BA,IAAMC,uBAAuB,KAAK,IAAlC;AAEA;AACA,IAAMC,wBAAwB,IAAI,EAAJ,GAAS,IAAvC;AAEA;;;AAGA,IAAAC,gBAAA,YAAA;AAIE;;;;AAIA,aAAAA,aAAA,CAAYC,UAAZ,EAAiDC,OAAjD,EAAuE;AAAtB,aAAAA,OAAA,GAAAA,OAAA;AANzC,aAAAC,cAAA,GAA2C,EAA3C;AAON,aAAKC,cAAL,GAAsB,iCAAkBH,UAAlB,CAAtB;AAEA,YAAMI,UACJR,uBACA,CAACC,uBAAuBD,oBAAxB,IAAgDS,KAAKC,MAAL,EAFlD;AAGA,yCAAsB,KAAKC,YAAL,CAAkBC,IAAlB,CAAuB,IAAvB,CAAtB,EAAoDH,KAAKI,KAAL,CAAWL,OAAX,CAApD;AACD;AAEDL,kBAAAW,SAAA,CAAAC,WAAA,GAAA,UAAYC,IAAZ,EAAwB;AACtB,aAAKV,cAAL,CAAoBU,IAApB,IAA4B,IAA5B;AACD,KAFD;AAIQb,kBAAAW,SAAA,CAAAH,YAAA,GAAR,YAAA;AAAA,YAAAM,QAAA,IAAA;AACE,YAAMC,QAAQ,KAAKX,cAAL,CAAoBY,GAApB,EAAd;AACA,YAAMC,gBAA8B,EAApC;AACA,YAAIC,oBAAoB,KAAxB;AAEA,0BAAQH,KAAR,EAAe,UAACF,IAAD,EAAeM,KAAf,EAA4B;AACzC,gBAAIA,QAAQ,CAAR,IAAa,mBAASL,MAAKX,cAAd,EAA8BU,IAA9B,CAAjB,EAAsD;AACpDI,8BAAcJ,IAAd,IAAsBM,KAAtB;AACAD,oCAAoB,IAApB;AACD;AACF,SALD;AAOA,YAAIA,iBAAJ,EAAuB;AACrB,iBAAKhB,OAAL,CAAakB,WAAb,CAAyBH,aAAzB;AACD;AAED;AACA,yCACE,KAAKT,YAAL,CAAkBC,IAAlB,CAAuB,IAAvB,CADF,EAEEH,KAAKI,KAAL,CAAWJ,KAAKC,MAAL,KAAgB,CAAhB,GAAoBR,qBAA/B,CAFF;AAID,KArBO;AAsBV,WAAAC,aAAA;AA3CA,CAAA,EAAA;QC6BSA,a,GAAAA,a","file":"StatsReporter.js","sourcesContent":["/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\nimport { contains, forEach } from '../../../utils/obj';\nimport { setTimeoutNonBlocking } from '../util/util';\nimport { StatsListener } from './StatsListener';\nimport { StatsCollection } from './StatsCollection';\nimport { ServerActions } from '../ServerActions';\n\n// Assuming some apps may have a short amount of time on page, and a bulk of firebase operations probably\n// happen on page load, we try to report our first set of stats pretty quickly, but we wait at least 10\n// seconds to try to ensure the Firebase connection is established / settled.\nconst FIRST_STATS_MIN_TIME = 10 * 1000;\nconst FIRST_STATS_MAX_TIME = 30 * 1000;\n\n// We'll continue to report stats on average every 5 minutes.\nconst REPORT_STATS_INTERVAL = 5 * 60 * 1000;\n\n/**\n * @constructor\n */\nexport class StatsReporter {\n  private statsListener_: StatsListener;\n  private statsToReport_: { [k: string]: boolean } = {};\n\n  /**\n   * @param collection\n   * @param server_\n   */\n  constructor(collection: StatsCollection, private server_: ServerActions) {\n    this.statsListener_ = new StatsListener(collection);\n\n    const timeout =\n      FIRST_STATS_MIN_TIME +\n      (FIRST_STATS_MAX_TIME - FIRST_STATS_MIN_TIME) * Math.random();\n    setTimeoutNonBlocking(this.reportStats_.bind(this), Math.floor(timeout));\n  }\n\n  includeStat(stat: string) {\n    this.statsToReport_[stat] = true;\n  }\n\n  private reportStats_() {\n    const stats = this.statsListener_.get();\n    const reportedStats: typeof stats = {};\n    let haveStatsToReport = false;\n\n    forEach(stats, (stat: string, value: number) => {\n      if (value > 0 && contains(this.statsToReport_, stat)) {\n        reportedStats[stat] = value;\n        haveStatsToReport = true;\n      }\n    });\n\n    if (haveStatsToReport) {\n      this.server_.reportStats(reportedStats);\n    }\n\n    // queue our next run.\n    setTimeoutNonBlocking(\n      this.reportStats_.bind(this),\n      Math.floor(Math.random() * 2 * REPORT_STATS_INTERVAL)\n    );\n  }\n}\n","/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\nimport { contains, forEach } from '../../../utils/obj';\nimport { setTimeoutNonBlocking } from '../util/util';\nimport { StatsListener } from './StatsListener';\n// Assuming some apps may have a short amount of time on page, and a bulk of firebase operations probably\n// happen on page load, we try to report our first set of stats pretty quickly, but we wait at least 10\n// seconds to try to ensure the Firebase connection is established / settled.\nvar FIRST_STATS_MIN_TIME = 10 * 1000;\nvar FIRST_STATS_MAX_TIME = 30 * 1000;\n// We'll continue to report stats on average every 5 minutes.\nvar REPORT_STATS_INTERVAL = 5 * 60 * 1000;\n/**\n * @constructor\n */\nvar StatsReporter = (function () {\n    /**\n     * @param collection\n     * @param server_\n     */\n    function StatsReporter(collection, server_) {\n        this.server_ = server_;\n        this.statsToReport_ = {};\n        this.statsListener_ = new StatsListener(collection);\n        var timeout = FIRST_STATS_MIN_TIME +\n            (FIRST_STATS_MAX_TIME - FIRST_STATS_MIN_TIME) * Math.random();\n        setTimeoutNonBlocking(this.reportStats_.bind(this), Math.floor(timeout));\n    }\n    StatsReporter.prototype.includeStat = function (stat) {\n        this.statsToReport_[stat] = true;\n    };\n    StatsReporter.prototype.reportStats_ = function () {\n        var _this = this;\n        var stats = this.statsListener_.get();\n        var reportedStats = {};\n        var haveStatsToReport = false;\n        forEach(stats, function (stat, value) {\n            if (value > 0 && contains(_this.statsToReport_, stat)) {\n                reportedStats[stat] = value;\n                haveStatsToReport = true;\n            }\n        });\n        if (haveStatsToReport) {\n            this.server_.reportStats(reportedStats);\n        }\n        // queue our next run.\n        setTimeoutNonBlocking(this.reportStats_.bind(this), Math.floor(Math.random() * 2 * REPORT_STATS_INTERVAL));\n    };\n    return StatsReporter;\n}());\nexport { StatsReporter };\n\n\n"]}