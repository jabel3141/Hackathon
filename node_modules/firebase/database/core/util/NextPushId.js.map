{"version":3,"sources":["database/src/database/core/util/NextPushId.ts"],"names":["nextPushId","PUSH_CHARS","lastPushTime","lastRandChars","now","duplicateTime","i","timeStampChars","Array","charAt","Math","floor","id","join","random","length"],"mappings":";;;;;;;AAgBA;;AAEA;;;;;;;;;;;;;;AAcO,IAAMA,kCAAc,YAAA;AACzB;AACA,QAAMC,aACJ,kEADF;AAGA;AACA;AACA,QAAIC,eAAe,CAAnB;AAEA;AACA;AACA;AACA;AACA,QAAMC,gBAA0B,EAAhC;AAEA,WAAO,UAASC,GAAT,EAAoB;AACzB,YAAMC,gBAAgBD,QAAQF,YAA9B;AACAA,uBAAeE,GAAf;AAEA,YAAIE,CAAJ;AACA,YAAMC,iBAAiB,IAAIC,KAAJ,CAAU,CAAV,CAAvB;AACA,aAAKF,IAAI,CAAT,EAAYA,KAAK,CAAjB,EAAoBA,GAApB,EAAyB;AACvBC,2BAAeD,CAAf,IAAoBL,WAAWQ,MAAX,CAAkBL,MAAM,EAAxB,CAApB;AACA;AACA;AACAA,kBAAMM,KAAKC,KAAL,CAAWP,MAAM,EAAjB,CAAN;AACD;AACD,4BAAOA,QAAQ,CAAf,EAAkB,0BAAlB;AAEA,YAAIQ,KAAKL,eAAeM,IAAf,CAAoB,EAApB,CAAT;AAEA,YAAI,CAACR,aAAL,EAAoB;AAClB,iBAAKC,IAAI,CAAT,EAAYA,IAAI,EAAhB,EAAoBA,GAApB,EAAyB;AACvBH,8BAAcG,CAAd,IAAmBI,KAAKC,KAAL,CAAWD,KAAKI,MAAL,KAAgB,EAA3B,CAAnB;AACD;AACF,SAJD,MAIO;AACL;AACA;AACA,iBAAKR,IAAI,EAAT,EAAaA,KAAK,CAAL,IAAUH,cAAcG,CAAd,MAAqB,EAA5C,EAAgDA,GAAhD,EAAqD;AACnDH,8BAAcG,CAAd,IAAmB,CAAnB;AACD;AACDH,0BAAcG,CAAd;AACD;AACD,aAAKA,IAAI,CAAT,EAAYA,IAAI,EAAhB,EAAoBA,GAApB,EAAyB;AACvBM,kBAAMX,WAAWQ,MAAX,CAAkBN,cAAcG,CAAd,CAAlB,CAAN;AACD;AACD,4BAAOM,GAAGG,MAAH,KAAc,EAArB,EAAyB,kCAAzB;AAEA,eAAOH,EAAP;AACD,KAlCD;AAmCD,CAlDyB,EAAnB,C,CAhCP","file":"NextPushId.js","sourcesContent":["/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\nimport { assert } from '../../../utils/assert';\n\n/**\n * Fancy ID generator that creates 20-character string identifiers with the\n * following properties:\n *\n * 1. They're based on timestamp so that they sort *after* any existing ids.\n * 2. They contain 72-bits of random data after the timestamp so that IDs won't\n *    collide with other clients' IDs.\n * 3. They sort *lexicographically* (so the timestamp is converted to characters\n *    that will sort properly).\n * 4. They're monotonically increasing. Even if you generate more than one in\n *    the same timestamp, the latter ones will sort after the former ones. We do\n *    this by using the previous random bits but \"incrementing\" them by 1 (only\n *    in the case of a timestamp collision).\n */\nexport const nextPushId = (function() {\n  // Modeled after base64 web-safe chars, but ordered by ASCII.\n  const PUSH_CHARS =\n    '-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz';\n\n  // Timestamp of last push, used to prevent local collisions if you push twice\n  // in one ms.\n  let lastPushTime = 0;\n\n  // We generate 72-bits of randomness which get turned into 12 characters and\n  // appended to the timestamp to prevent collisions with other clients. We\n  // store the last characters we generated because in the event of a collision,\n  // we'll use those same characters except \"incremented\" by one.\n  const lastRandChars: number[] = [];\n\n  return function(now: number) {\n    const duplicateTime = now === lastPushTime;\n    lastPushTime = now;\n\n    let i;\n    const timeStampChars = new Array(8);\n    for (i = 7; i >= 0; i--) {\n      timeStampChars[i] = PUSH_CHARS.charAt(now % 64);\n      // NOTE: Can't use << here because javascript will convert to int and lose\n      // the upper bits.\n      now = Math.floor(now / 64);\n    }\n    assert(now === 0, 'Cannot push at time == 0');\n\n    let id = timeStampChars.join('');\n\n    if (!duplicateTime) {\n      for (i = 0; i < 12; i++) {\n        lastRandChars[i] = Math.floor(Math.random() * 64);\n      }\n    } else {\n      // If the timestamp hasn't changed since last push, use the same random\n      // number, except incremented by 1.\n      for (i = 11; i >= 0 && lastRandChars[i] === 63; i--) {\n        lastRandChars[i] = 0;\n      }\n      lastRandChars[i]++;\n    }\n    for (i = 0; i < 12; i++) {\n      id += PUSH_CHARS.charAt(lastRandChars[i]);\n    }\n    assert(id.length === 20, 'nextPushId: Length should be 20.');\n\n    return id;\n  };\n})();\n"]}