{"version":3,"sources":["database/src/database/core/util/ImmutableTree.ts"],"names":["emptyChildrenSingleton","EmptyChildren","ImmutableTree","value","children","fromObject","obj","tree","Empty","childPath","childSnap","set","prototype","isEmpty","findRootMostMatchingPathAndValue","relativePath","predicate","path","front","getFront","child","get","childExistingPathAndValue","popFront","fullPath","findRootMostValueAndPath","subtree","childTree","toSet","newChild","newChildren","insert","remove","setTree","newTree","fold","fn","fold_","pathSoFar","accum","inorderTraversal","childKey","findOnPath","f","findOnPath_","pathToFollow","result","nextChild","foreachOnPath","foreachOnPath_","currentRelativePath","foreach","foreach_","childName","foreachChild"],"mappings":"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","file":"ImmutableTree.js","sourcesContent":["/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\nimport { SortedMap } from './SortedMap';\nimport { Path } from './Path';\nimport { stringCompare } from './util';\nimport { forEach } from '../../../utils/obj';\n\nlet emptyChildrenSingleton: SortedMap<string, ImmutableTree<null>>;\n\n/**\n * Singleton empty children collection.\n *\n * @const\n * @type {!SortedMap.<string, !ImmutableTree.<?>>}\n */\nconst EmptyChildren = (): SortedMap<string, ImmutableTree<null>> => {\n  if (!emptyChildrenSingleton) {\n    emptyChildrenSingleton = new SortedMap<string, ImmutableTree<null>>(\n      stringCompare\n    );\n  }\n  return emptyChildrenSingleton;\n};\n\n/**\n * A tree with immutable elements.\n */\nexport class ImmutableTree<T> {\n  static Empty = new ImmutableTree<any>(null);\n\n  /**\n   * @template T\n   * @param {!Object.<string, !T>} obj\n   * @return {!ImmutableTree.<!T>}\n   */\n  static fromObject<T>(obj: { [k: string]: T }): ImmutableTree<T> {\n    let tree: ImmutableTree<T> = ImmutableTree.Empty;\n    forEach(obj, (childPath: string, childSnap: T) => {\n      tree = tree.set(new Path(childPath), childSnap);\n    });\n    return tree;\n  }\n\n  /**\n   * @template T\n   * @param {?T} value\n   * @param {SortedMap.<string, !ImmutableTree.<T>>=} children\n   */\n  constructor(\n    public readonly value: T | null,\n    public readonly children: SortedMap<\n      string,\n      ImmutableTree<T>\n    > = EmptyChildren()\n  ) {}\n\n  /**\n   * True if the value is empty and there are no children\n   * @return {boolean}\n   */\n  isEmpty(): boolean {\n    return this.value === null && this.children.isEmpty();\n  }\n\n  /**\n   * Given a path and predicate, return the first node and the path to that node\n   * where the predicate returns true.\n   *\n   * TODO Do a perf test -- If we're creating a bunch of {path: value:} objects\n   * on the way back out, it may be better to pass down a pathSoFar obj.\n   *\n   * @param {!Path} relativePath The remainder of the path\n   * @param {function(T):boolean} predicate The predicate to satisfy to return a\n   *   node\n   * @return {?{path:!Path, value:!T}}\n   */\n  findRootMostMatchingPathAndValue(\n    relativePath: Path,\n    predicate: (a: T) => boolean\n  ): { path: Path; value: T } | null {\n    if (this.value != null && predicate(this.value)) {\n      return { path: Path.Empty, value: this.value };\n    } else {\n      if (relativePath.isEmpty()) {\n        return null;\n      } else {\n        const front = relativePath.getFront();\n        const child = this.children.get(front);\n        if (child !== null) {\n          const childExistingPathAndValue = child.findRootMostMatchingPathAndValue(\n            relativePath.popFront(),\n            predicate\n          );\n          if (childExistingPathAndValue != null) {\n            const fullPath = new Path(front).child(\n              childExistingPathAndValue.path\n            );\n            return { path: fullPath, value: childExistingPathAndValue.value };\n          } else {\n            return null;\n          }\n        } else {\n          return null;\n        }\n      }\n    }\n  }\n\n  /**\n   * Find, if it exists, the shortest subpath of the given path that points a defined\n   * value in the tree\n   * @param {!Path} relativePath\n   * @return {?{path: !Path, value: !T}}\n   */\n  findRootMostValueAndPath(\n    relativePath: Path\n  ): { path: Path; value: T } | null {\n    return this.findRootMostMatchingPathAndValue(relativePath, () => true);\n  }\n\n  /**\n   * @param {!Path} relativePath\n   * @return {!ImmutableTree.<T>} The subtree at the given path\n   */\n  subtree(relativePath: Path): ImmutableTree<T> {\n    if (relativePath.isEmpty()) {\n      return this;\n    } else {\n      const front = relativePath.getFront();\n      const childTree = this.children.get(front);\n      if (childTree !== null) {\n        return childTree.subtree(relativePath.popFront());\n      } else {\n        return ImmutableTree.Empty;\n      }\n    }\n  }\n\n  /**\n   * Sets a value at the specified path.\n   *\n   * @param {!Path} relativePath Path to set value at.\n   * @param {?T} toSet Value to set.\n   * @return {!ImmutableTree.<T>} Resulting tree.\n   */\n  set(relativePath: Path, toSet: T | null): ImmutableTree<T> {\n    if (relativePath.isEmpty()) {\n      return new ImmutableTree(toSet, this.children);\n    } else {\n      const front = relativePath.getFront();\n      const child = this.children.get(front) || ImmutableTree.Empty;\n      const newChild = child.set(relativePath.popFront(), toSet);\n      const newChildren = this.children.insert(front, newChild);\n      return new ImmutableTree(this.value, newChildren);\n    }\n  }\n\n  /**\n   * Removes the value at the specified path.\n   *\n   * @param {!Path} relativePath Path to value to remove.\n   * @return {!ImmutableTree.<T>} Resulting tree.\n   */\n  remove(relativePath: Path): ImmutableTree<T> {\n    if (relativePath.isEmpty()) {\n      if (this.children.isEmpty()) {\n        return ImmutableTree.Empty;\n      } else {\n        return new ImmutableTree(null, this.children);\n      }\n    } else {\n      const front = relativePath.getFront();\n      const child = this.children.get(front);\n      if (child) {\n        const newChild = child.remove(relativePath.popFront());\n        let newChildren;\n        if (newChild.isEmpty()) {\n          newChildren = this.children.remove(front);\n        } else {\n          newChildren = this.children.insert(front, newChild);\n        }\n        if (this.value === null && newChildren.isEmpty()) {\n          return ImmutableTree.Empty;\n        } else {\n          return new ImmutableTree(this.value, newChildren);\n        }\n      } else {\n        return this;\n      }\n    }\n  }\n\n  /**\n   * Gets a value from the tree.\n   *\n   * @param {!Path} relativePath Path to get value for.\n   * @return {?T} Value at path, or null.\n   */\n  get(relativePath: Path): T | null {\n    if (relativePath.isEmpty()) {\n      return this.value;\n    } else {\n      const front = relativePath.getFront();\n      const child = this.children.get(front);\n      if (child) {\n        return child.get(relativePath.popFront());\n      } else {\n        return null;\n      }\n    }\n  }\n\n  /**\n   * Replace the subtree at the specified path with the given new tree.\n   *\n   * @param {!Path} relativePath Path to replace subtree for.\n   * @param {!ImmutableTree} newTree New tree.\n   * @return {!ImmutableTree} Resulting tree.\n   */\n  setTree(relativePath: Path, newTree: ImmutableTree<T>): ImmutableTree<T> {\n    if (relativePath.isEmpty()) {\n      return newTree;\n    } else {\n      const front = relativePath.getFront();\n      const child = this.children.get(front) || ImmutableTree.Empty;\n      const newChild = child.setTree(relativePath.popFront(), newTree);\n      let newChildren;\n      if (newChild.isEmpty()) {\n        newChildren = this.children.remove(front);\n      } else {\n        newChildren = this.children.insert(front, newChild);\n      }\n      return new ImmutableTree(this.value, newChildren);\n    }\n  }\n\n  /**\n   * Performs a depth first fold on this tree. Transforms a tree into a single\n   * value, given a function that operates on the path to a node, an optional\n   * current value, and a map of child names to folded subtrees\n   * @template V\n   * @param {function(Path, ?T, Object.<string, V>):V} fn\n   * @return {V}\n   */\n  fold<V>(fn: (path: Path, value: T, children: { [k: string]: V }) => V): V {\n    return this.fold_(Path.Empty, fn);\n  }\n\n  /**\n   * Recursive helper for public-facing fold() method\n   * @template V\n   * @param {!Path} pathSoFar\n   * @param {function(Path, ?T, Object.<string, V>):V} fn\n   * @return {V}\n   * @private\n   */\n  private fold_<V>(\n    pathSoFar: Path,\n    fn: (path: Path, value: T | null, children: { [k: string]: V }) => V\n  ): V {\n    const accum: { [k: string]: V } = {};\n    this.children.inorderTraversal(function(\n      childKey: string,\n      childTree: ImmutableTree<T>\n    ) {\n      accum[childKey] = childTree.fold_(pathSoFar.child(childKey), fn);\n    });\n    return fn(pathSoFar, this.value, accum);\n  }\n\n  /**\n   * Find the first matching value on the given path. Return the result of applying f to it.\n   * @template V\n   * @param {!Path} path\n   * @param {!function(!Path, !T):?V} f\n   * @return {?V}\n   */\n  findOnPath<V>(path: Path, f: (path: Path, value: T) => V | null): V | null {\n    return this.findOnPath_(path, Path.Empty, f);\n  }\n\n  private findOnPath_<V>(\n    pathToFollow: Path,\n    pathSoFar: Path,\n    f: (path: Path, value: T) => V | null\n  ): V | null {\n    const result = this.value ? f(pathSoFar, this.value) : false;\n    if (result) {\n      return result;\n    } else {\n      if (pathToFollow.isEmpty()) {\n        return null;\n      } else {\n        const front = pathToFollow.getFront()!;\n        const nextChild = this.children.get(front);\n        if (nextChild) {\n          return nextChild.findOnPath_(\n            pathToFollow.popFront(),\n            pathSoFar.child(front),\n            f\n          );\n        } else {\n          return null;\n        }\n      }\n    }\n  }\n\n  /**\n   *\n   * @param {!Path} path\n   * @param {!function(!Path, !T)} f\n   * @returns {!ImmutableTree.<T>}\n   */\n  foreachOnPath(\n    path: Path,\n    f: (path: Path, value: T) => void\n  ): ImmutableTree<T> {\n    return this.foreachOnPath_(path, Path.Empty, f);\n  }\n\n  private foreachOnPath_(\n    pathToFollow: Path,\n    currentRelativePath: Path,\n    f: (path: Path, value: T) => void\n  ): ImmutableTree<T> {\n    if (pathToFollow.isEmpty()) {\n      return this;\n    } else {\n      if (this.value) {\n        f(currentRelativePath, this.value);\n      }\n      const front = pathToFollow.getFront();\n      const nextChild = this.children.get(front);\n      if (nextChild) {\n        return nextChild.foreachOnPath_(\n          pathToFollow.popFront(),\n          currentRelativePath.child(front),\n          f\n        );\n      } else {\n        return ImmutableTree.Empty;\n      }\n    }\n  }\n\n  /**\n   * Calls the given function for each node in the tree that has a value.\n   *\n   * @param {function(!Path, !T)} f A function to be called with\n   *   the path from the root of the tree to a node, and the value at that node.\n   *   Called in depth-first order.\n   */\n  foreach(f: (path: Path, value: T) => void) {\n    this.foreach_(Path.Empty, f);\n  }\n\n  private foreach_(\n    currentRelativePath: Path,\n    f: (path: Path, value: T) => void\n  ) {\n    this.children.inorderTraversal(function(childName, childTree) {\n      childTree.foreach_(currentRelativePath.child(childName), f);\n    });\n    if (this.value) {\n      f(currentRelativePath, this.value);\n    }\n  }\n\n  /**\n   *\n   * @param {function(string, !T)} f\n   */\n  foreachChild(f: (name: string, value: T) => void) {\n    this.children.inorderTraversal(\n      (childName: string, childTree: ImmutableTree<T>) => {\n        if (childTree.value) {\n          f(childName, childTree.value);\n        }\n      }\n    );\n  }\n}\n"]}