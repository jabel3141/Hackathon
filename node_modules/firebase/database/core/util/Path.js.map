{"version":3,"sources":["database/src/database/core/util/Path.ts","database/core/util/Path.js"],"names":["Path","pathOrString","pieceNum","pieces_","split","copyTo","i","length","pieceNum_","Object","defineProperty","get","enumerable","configurable","prototype","getFront","getLength","popFront","getBack","toString","pathString","toUrlEncodedString","encodeURIComponent","String","slice","begin","parent","pieces","push","child","childPathObj","childPieces","isEmpty","relativePath","outerPath","innerPath","outer","inner","Error","comparePaths","left","right","leftKeys","rightKeys","cmp","equals","other","j","contains","ValidationPath","path","errorPrefix_","parts_","byteLength_","Math","max","checkValid_","pop","last","MAX_PATH_LENGTH_BYTES","MAX_PATH_DEPTH","toErrorString","join"],"mappings":"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","file":"Path.js","sourcesContent":["/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\nimport { nameCompare } from './util';\nimport { stringLength } from '../../../utils/utf8';\n/**\n * An immutable object representing a parsed path.  It's immutable so that you\n * can pass them around to other functions without worrying about them changing\n * it.\n */\n\nexport class Path {\n  private pieces_: string[];\n  private pieceNum_: number;\n\n  /**\n   * Singleton to represent an empty path\n   *\n   * @const\n   */\n  static get Empty() {\n    return new Path('');\n  }\n\n  /**\n   * @param {string|Array.<string>} pathOrString Path string to parse,\n   *      or another path, or the raw tokens array\n   * @param {number=} pieceNum\n   */\n  constructor(pathOrString: string | string[], pieceNum?: number) {\n    if (pieceNum === void 0) {\n      this.pieces_ = (pathOrString as string).split('/');\n\n      // Remove empty pieces.\n      let copyTo = 0;\n      for (let i = 0; i < this.pieces_.length; i++) {\n        if (this.pieces_[i].length > 0) {\n          this.pieces_[copyTo] = this.pieces_[i];\n          copyTo++;\n        }\n      }\n      this.pieces_.length = copyTo;\n\n      this.pieceNum_ = 0;\n    } else {\n      this.pieces_ = pathOrString as string[];\n      this.pieceNum_ = pieceNum;\n    }\n  }\n\n  getFront(): string | null {\n    if (this.pieceNum_ >= this.pieces_.length) return null;\n\n    return this.pieces_[this.pieceNum_];\n  }\n\n  /**\n   * @return {number} The number of segments in this path\n   */\n  getLength(): number {\n    return this.pieces_.length - this.pieceNum_;\n  }\n\n  /**\n   * @return {!Path}\n   */\n  popFront(): Path {\n    let pieceNum = this.pieceNum_;\n    if (pieceNum < this.pieces_.length) {\n      pieceNum++;\n    }\n    return new Path(this.pieces_, pieceNum);\n  }\n\n  /**\n   * @return {?string}\n   */\n  getBack(): string | null {\n    if (this.pieceNum_ < this.pieces_.length)\n      return this.pieces_[this.pieces_.length - 1];\n\n    return null;\n  }\n\n  toString(): string {\n    let pathString = '';\n    for (let i = this.pieceNum_; i < this.pieces_.length; i++) {\n      if (this.pieces_[i] !== '') pathString += '/' + this.pieces_[i];\n    }\n\n    return pathString || '/';\n  }\n\n  toUrlEncodedString(): string {\n    let pathString = '';\n    for (let i = this.pieceNum_; i < this.pieces_.length; i++) {\n      if (this.pieces_[i] !== '')\n        pathString += '/' + encodeURIComponent(String(this.pieces_[i]));\n    }\n\n    return pathString || '/';\n  }\n\n  /**\n   * Shallow copy of the parts of the path.\n   *\n   * @param {number=} begin\n   * @return {!Array<string>}\n   */\n  slice(begin: number = 0): string[] {\n    return this.pieces_.slice(this.pieceNum_ + begin);\n  }\n\n  /**\n   * @return {?Path}\n   */\n  parent(): Path | null {\n    if (this.pieceNum_ >= this.pieces_.length) return null;\n\n    const pieces = [];\n    for (let i = this.pieceNum_; i < this.pieces_.length - 1; i++)\n      pieces.push(this.pieces_[i]);\n\n    return new Path(pieces, 0);\n  }\n\n  /**\n   * @param {string|!Path} childPathObj\n   * @return {!Path}\n   */\n  child(childPathObj: string | Path): Path {\n    const pieces = [];\n    for (let i = this.pieceNum_; i < this.pieces_.length; i++)\n      pieces.push(this.pieces_[i]);\n\n    if (childPathObj instanceof Path) {\n      for (\n        let i = childPathObj.pieceNum_;\n        i < childPathObj.pieces_.length;\n        i++\n      ) {\n        pieces.push(childPathObj.pieces_[i]);\n      }\n    } else {\n      const childPieces = childPathObj.split('/');\n      for (let i = 0; i < childPieces.length; i++) {\n        if (childPieces[i].length > 0) pieces.push(childPieces[i]);\n      }\n    }\n\n    return new Path(pieces, 0);\n  }\n\n  /**\n   * @return {boolean} True if there are no segments in this path\n   */\n  isEmpty(): boolean {\n    return this.pieceNum_ >= this.pieces_.length;\n  }\n\n  /**\n   * @param {!Path} outerPath\n   * @param {!Path} innerPath\n   * @return {!Path} The path from outerPath to innerPath\n   */\n  static relativePath(outerPath: Path, innerPath: Path): Path {\n    const outer = outerPath.getFront(),\n      inner = innerPath.getFront();\n    if (outer === null) {\n      return innerPath;\n    } else if (outer === inner) {\n      return Path.relativePath(outerPath.popFront(), innerPath.popFront());\n    } else {\n      throw new Error(\n        'INTERNAL ERROR: innerPath (' +\n          innerPath +\n          ') is not within ' +\n          'outerPath (' +\n          outerPath +\n          ')'\n      );\n    }\n  }\n\n  /**\n   * @param {!Path} left\n   * @param {!Path} right\n   * @return {number} -1, 0, 1 if left is less, equal, or greater than the right.\n   */\n  static comparePaths(left: Path, right: Path): number {\n    const leftKeys = left.slice();\n    const rightKeys = right.slice();\n    for (let i = 0; i < leftKeys.length && i < rightKeys.length; i++) {\n      const cmp = nameCompare(leftKeys[i], rightKeys[i]);\n      if (cmp !== 0) return cmp;\n    }\n    if (leftKeys.length === rightKeys.length) return 0;\n    return leftKeys.length < rightKeys.length ? -1 : 1;\n  }\n\n  /**\n   *\n   * @param {Path} other\n   * @return {boolean} true if paths are the same.\n   */\n  equals(other: Path): boolean {\n    if (this.getLength() !== other.getLength()) {\n      return false;\n    }\n\n    for (\n      let i = this.pieceNum_, j = other.pieceNum_;\n      i <= this.pieces_.length;\n      i++, j++\n    ) {\n      if (this.pieces_[i] !== other.pieces_[j]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   *\n   * @param {!Path} other\n   * @return {boolean} True if this path is a parent (or the same as) other\n   */\n  contains(other: Path): boolean {\n    let i = this.pieceNum_;\n    let j = other.pieceNum_;\n    if (this.getLength() > other.getLength()) {\n      return false;\n    }\n    while (i < this.pieces_.length) {\n      if (this.pieces_[i] !== other.pieces_[j]) {\n        return false;\n      }\n      ++i;\n      ++j;\n    }\n    return true;\n  }\n} // end Path\n\n/**\n * Dynamic (mutable) path used to count path lengths.\n *\n * This class is used to efficiently check paths for valid\n * length (in UTF8 bytes) and depth (used in path validation).\n *\n * Throws Error exception if path is ever invalid.\n *\n * The definition of a path always begins with '/'.\n */\nexport class ValidationPath {\n  /** @type {!Array<string>} */\n  private parts_: string[];\n  /** @type {number} Initialize to number of '/' chars needed in path. */\n  private byteLength_: number;\n\n  /**\n   * @param {!Path} path Initial Path.\n   * @param {string} errorPrefix_ Prefix for any error messages.\n   */\n  constructor(path: Path, private errorPrefix_: string) {\n    /** @type {!Array<string>} */\n    this.parts_ = path.slice();\n    /** @type {number} Initialize to number of '/' chars needed in path. */\n    this.byteLength_ = Math.max(1, this.parts_.length);\n\n    for (let i = 0; i < this.parts_.length; i++) {\n      this.byteLength_ += stringLength(this.parts_[i]);\n    }\n    this.checkValid_();\n  }\n\n  /** @const {number} Maximum key depth. */\n  static get MAX_PATH_DEPTH() {\n    return 32;\n  }\n\n  /** @const {number} Maximum number of (UTF8) bytes in a Firebase path. */\n  static get MAX_PATH_LENGTH_BYTES() {\n    return 768;\n  }\n\n  /** @param {string} child */\n  push(child: string) {\n    // Count the needed '/'\n    if (this.parts_.length > 0) {\n      this.byteLength_ += 1;\n    }\n    this.parts_.push(child);\n    this.byteLength_ += stringLength(child);\n    this.checkValid_();\n  }\n\n  pop() {\n    const last = this.parts_.pop();\n    this.byteLength_ -= stringLength(last);\n    // Un-count the previous '/'\n    if (this.parts_.length > 0) {\n      this.byteLength_ -= 1;\n    }\n  }\n\n  private checkValid_() {\n    if (this.byteLength_ > ValidationPath.MAX_PATH_LENGTH_BYTES) {\n      throw new Error(\n        this.errorPrefix_ +\n          'has a key path longer than ' +\n          ValidationPath.MAX_PATH_LENGTH_BYTES +\n          ' bytes (' +\n          this.byteLength_ +\n          ').'\n      );\n    }\n    if (this.parts_.length > ValidationPath.MAX_PATH_DEPTH) {\n      throw new Error(\n        this.errorPrefix_ +\n          'path specified exceeds the maximum depth that can be written (' +\n          ValidationPath.MAX_PATH_DEPTH +\n          ') or object contains a cycle ' +\n          this.toErrorString()\n      );\n    }\n  }\n\n  /**\n   * String for use in error messages - uses '.' notation for path.\n   *\n   * @return {string}\n   */\n  toErrorString(): string {\n    if (this.parts_.length == 0) {\n      return '';\n    }\n    return \"in property '\" + this.parts_.join('.') + \"'\";\n  }\n}\n","/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\nimport { nameCompare } from './util';\nimport { stringLength } from '../../../utils/utf8';\n/**\n * An immutable object representing a parsed path.  It's immutable so that you\n * can pass them around to other functions without worrying about them changing\n * it.\n */\nvar Path = (function () {\n    /**\n     * @param {string|Array.<string>} pathOrString Path string to parse,\n     *      or another path, or the raw tokens array\n     * @param {number=} pieceNum\n     */\n    function Path(pathOrString, pieceNum) {\n        if (pieceNum === void 0) {\n            this.pieces_ = pathOrString.split('/');\n            // Remove empty pieces.\n            var copyTo = 0;\n            for (var i = 0; i < this.pieces_.length; i++) {\n                if (this.pieces_[i].length > 0) {\n                    this.pieces_[copyTo] = this.pieces_[i];\n                    copyTo++;\n                }\n            }\n            this.pieces_.length = copyTo;\n            this.pieceNum_ = 0;\n        }\n        else {\n            this.pieces_ = pathOrString;\n            this.pieceNum_ = pieceNum;\n        }\n    }\n    Object.defineProperty(Path, \"Empty\", {\n        /**\n         * Singleton to represent an empty path\n         *\n         * @const\n         */\n        get: function () {\n            return new Path('');\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Path.prototype.getFront = function () {\n        if (this.pieceNum_ >= this.pieces_.length)\n            return null;\n        return this.pieces_[this.pieceNum_];\n    };\n    /**\n     * @return {number} The number of segments in this path\n     */\n    Path.prototype.getLength = function () {\n        return this.pieces_.length - this.pieceNum_;\n    };\n    /**\n     * @return {!Path}\n     */\n    Path.prototype.popFront = function () {\n        var pieceNum = this.pieceNum_;\n        if (pieceNum < this.pieces_.length) {\n            pieceNum++;\n        }\n        return new Path(this.pieces_, pieceNum);\n    };\n    /**\n     * @return {?string}\n     */\n    Path.prototype.getBack = function () {\n        if (this.pieceNum_ < this.pieces_.length)\n            return this.pieces_[this.pieces_.length - 1];\n        return null;\n    };\n    Path.prototype.toString = function () {\n        var pathString = '';\n        for (var i = this.pieceNum_; i < this.pieces_.length; i++) {\n            if (this.pieces_[i] !== '')\n                pathString += '/' + this.pieces_[i];\n        }\n        return pathString || '/';\n    };\n    Path.prototype.toUrlEncodedString = function () {\n        var pathString = '';\n        for (var i = this.pieceNum_; i < this.pieces_.length; i++) {\n            if (this.pieces_[i] !== '')\n                pathString += '/' + encodeURIComponent(String(this.pieces_[i]));\n        }\n        return pathString || '/';\n    };\n    /**\n     * Shallow copy of the parts of the path.\n     *\n     * @param {number=} begin\n     * @return {!Array<string>}\n     */\n    Path.prototype.slice = function (begin) {\n        if (begin === void 0) { begin = 0; }\n        return this.pieces_.slice(this.pieceNum_ + begin);\n    };\n    /**\n     * @return {?Path}\n     */\n    Path.prototype.parent = function () {\n        if (this.pieceNum_ >= this.pieces_.length)\n            return null;\n        var pieces = [];\n        for (var i = this.pieceNum_; i < this.pieces_.length - 1; i++)\n            pieces.push(this.pieces_[i]);\n        return new Path(pieces, 0);\n    };\n    /**\n     * @param {string|!Path} childPathObj\n     * @return {!Path}\n     */\n    Path.prototype.child = function (childPathObj) {\n        var pieces = [];\n        for (var i = this.pieceNum_; i < this.pieces_.length; i++)\n            pieces.push(this.pieces_[i]);\n        if (childPathObj instanceof Path) {\n            for (var i = childPathObj.pieceNum_; i < childPathObj.pieces_.length; i++) {\n                pieces.push(childPathObj.pieces_[i]);\n            }\n        }\n        else {\n            var childPieces = childPathObj.split('/');\n            for (var i = 0; i < childPieces.length; i++) {\n                if (childPieces[i].length > 0)\n                    pieces.push(childPieces[i]);\n            }\n        }\n        return new Path(pieces, 0);\n    };\n    /**\n     * @return {boolean} True if there are no segments in this path\n     */\n    Path.prototype.isEmpty = function () {\n        return this.pieceNum_ >= this.pieces_.length;\n    };\n    /**\n     * @param {!Path} outerPath\n     * @param {!Path} innerPath\n     * @return {!Path} The path from outerPath to innerPath\n     */\n    Path.relativePath = function (outerPath, innerPath) {\n        var outer = outerPath.getFront(), inner = innerPath.getFront();\n        if (outer === null) {\n            return innerPath;\n        }\n        else if (outer === inner) {\n            return Path.relativePath(outerPath.popFront(), innerPath.popFront());\n        }\n        else {\n            throw new Error('INTERNAL ERROR: innerPath (' +\n                innerPath +\n                ') is not within ' +\n                'outerPath (' +\n                outerPath +\n                ')');\n        }\n    };\n    /**\n     * @param {!Path} left\n     * @param {!Path} right\n     * @return {number} -1, 0, 1 if left is less, equal, or greater than the right.\n     */\n    Path.comparePaths = function (left, right) {\n        var leftKeys = left.slice();\n        var rightKeys = right.slice();\n        for (var i = 0; i < leftKeys.length && i < rightKeys.length; i++) {\n            var cmp = nameCompare(leftKeys[i], rightKeys[i]);\n            if (cmp !== 0)\n                return cmp;\n        }\n        if (leftKeys.length === rightKeys.length)\n            return 0;\n        return leftKeys.length < rightKeys.length ? -1 : 1;\n    };\n    /**\n     *\n     * @param {Path} other\n     * @return {boolean} true if paths are the same.\n     */\n    Path.prototype.equals = function (other) {\n        if (this.getLength() !== other.getLength()) {\n            return false;\n        }\n        for (var i = this.pieceNum_, j = other.pieceNum_; i <= this.pieces_.length; i++, j++) {\n            if (this.pieces_[i] !== other.pieces_[j]) {\n                return false;\n            }\n        }\n        return true;\n    };\n    /**\n     *\n     * @param {!Path} other\n     * @return {boolean} True if this path is a parent (or the same as) other\n     */\n    Path.prototype.contains = function (other) {\n        var i = this.pieceNum_;\n        var j = other.pieceNum_;\n        if (this.getLength() > other.getLength()) {\n            return false;\n        }\n        while (i < this.pieces_.length) {\n            if (this.pieces_[i] !== other.pieces_[j]) {\n                return false;\n            }\n            ++i;\n            ++j;\n        }\n        return true;\n    };\n    return Path;\n}()); // end Path\nexport { Path };\n/**\n * Dynamic (mutable) path used to count path lengths.\n *\n * This class is used to efficiently check paths for valid\n * length (in UTF8 bytes) and depth (used in path validation).\n *\n * Throws Error exception if path is ever invalid.\n *\n * The definition of a path always begins with '/'.\n */\nvar ValidationPath = (function () {\n    /**\n     * @param {!Path} path Initial Path.\n     * @param {string} errorPrefix_ Prefix for any error messages.\n     */\n    function ValidationPath(path, errorPrefix_) {\n        this.errorPrefix_ = errorPrefix_;\n        /** @type {!Array<string>} */\n        this.parts_ = path.slice();\n        /** @type {number} Initialize to number of '/' chars needed in path. */\n        this.byteLength_ = Math.max(1, this.parts_.length);\n        for (var i = 0; i < this.parts_.length; i++) {\n            this.byteLength_ += stringLength(this.parts_[i]);\n        }\n        this.checkValid_();\n    }\n    Object.defineProperty(ValidationPath, \"MAX_PATH_DEPTH\", {\n        /** @const {number} Maximum key depth. */\n        get: function () {\n            return 32;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ValidationPath, \"MAX_PATH_LENGTH_BYTES\", {\n        /** @const {number} Maximum number of (UTF8) bytes in a Firebase path. */\n        get: function () {\n            return 768;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /** @param {string} child */\n    ValidationPath.prototype.push = function (child) {\n        // Count the needed '/'\n        if (this.parts_.length > 0) {\n            this.byteLength_ += 1;\n        }\n        this.parts_.push(child);\n        this.byteLength_ += stringLength(child);\n        this.checkValid_();\n    };\n    ValidationPath.prototype.pop = function () {\n        var last = this.parts_.pop();\n        this.byteLength_ -= stringLength(last);\n        // Un-count the previous '/'\n        if (this.parts_.length > 0) {\n            this.byteLength_ -= 1;\n        }\n    };\n    ValidationPath.prototype.checkValid_ = function () {\n        if (this.byteLength_ > ValidationPath.MAX_PATH_LENGTH_BYTES) {\n            throw new Error(this.errorPrefix_ +\n                'has a key path longer than ' +\n                ValidationPath.MAX_PATH_LENGTH_BYTES +\n                ' bytes (' +\n                this.byteLength_ +\n                ').');\n        }\n        if (this.parts_.length > ValidationPath.MAX_PATH_DEPTH) {\n            throw new Error(this.errorPrefix_ +\n                'path specified exceeds the maximum depth that can be written (' +\n                ValidationPath.MAX_PATH_DEPTH +\n                ') or object contains a cycle ' +\n                this.toErrorString());\n        }\n    };\n    /**\n     * String for use in error messages - uses '.' notation for path.\n     *\n     * @return {string}\n     */\n    ValidationPath.prototype.toErrorString = function () {\n        if (this.parts_.length == 0) {\n            return '';\n        }\n        return \"in property '\" + this.parts_.join('.') + \"'\";\n    };\n    return ValidationPath;\n}());\nexport { ValidationPath };\n\n\n"]}