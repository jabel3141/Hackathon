{"version":3,"sources":["database/src/database/core/util/SortedMap.ts","database/core/util/SortedMap.js"],"names":["SortedMapIterator","node","startKey","comparator","isReverse_","resultGenerator_","nodeStack_","cmp","isEmpty","key","left","right","push","prototype","getNext","length","pop","result","value","hasNext","peek","LLRBNode","color","RED","SortedMap","EMPTY_NODE","copy","count","inorderTraversal","action","reverseTraversal","min_","minKey","maxKey","insert","n","fixUp_","removeMin_","isRed_","moveRedLeft_","remove","smallest","rotateRight_","moveRedRight_","rotateLeft_","colorFlip_","nl","nr","checkMaxDepth_","blackDepth","check_","Math","pow","Error","BLACK","LLRBEmptyNode","comparator_","root_","get","getPredecessorKey","rightParent","getIterator","resultGenerator","getIteratorFrom","getReverseIteratorFrom","getReverseIterator"],"mappings":"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","file":"SortedMap.js","sourcesContent":["/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/**\n * @fileoverview Implementation of an immutable SortedMap using a Left-leaning\n * Red-Black Tree, adapted from the implementation in Mugs\n * (http://mads379.github.com/mugs/) by Mads Hartmann Jensen\n * (mads379@gmail.com).\n *\n * Original paper on Left-leaning Red-Black Trees:\n *   http://www.cs.princeton.edu/~rs/talks/LLRB/LLRB.pdf\n *\n * Invariant 1: No red node has a red child\n * Invariant 2: Every leaf path has the same number of black nodes\n * Invariant 3: Only the left child can be red (left leaning)\n */\n\n// TODO: There are some improvements I'd like to make to improve memory / perf:\n//  * Create two prototypes, LLRedNode and LLBlackNode, instead of storing a\n//    color property in every node.\n// TODO: It would also be good (and possibly necessary) to create a base\n// interface for LLRBNode and LLRBEmptyNode.\n\nexport type Comparator<K> = (key1: K, key2: K) => number;\n\n/**\n * An iterator over an LLRBNode.\n */\nexport class SortedMapIterator<K, V, T> {\n  /** @private\n   * @type {Array.<!LLRBNode>}\n   */\n  private nodeStack_: (LLRBNode<K, V> | LLRBEmptyNode<K, V>)[] = [];\n\n  /**\n   * @template K, V, T\n   * @param {LLRBNode|LLRBEmptyNode} node Node to iterate.\n   * @param {?K} startKey\n   * @param {function(K, K): number} comparator\n   * @param {boolean} isReverse_ Whether or not to iterate in reverse\n   * @param {(function(K, V):T)=} resultGenerator_\n   */\n  constructor(\n    node: LLRBNode<K, V> | LLRBEmptyNode<K, V>,\n    startKey: K | null,\n    comparator: Comparator<K>,\n    private isReverse_: boolean,\n    private resultGenerator_: ((k: K, v: V) => T) | null = null\n  ) {\n    let cmp = 1;\n    while (!node.isEmpty()) {\n      node = node as LLRBNode<K, V>;\n      cmp = startKey ? comparator(node.key, startKey) : 1;\n      // flip the comparison if we're going in reverse\n      if (isReverse_) cmp *= -1;\n\n      if (cmp < 0) {\n        // This node is less than our start key. ignore it\n        if (this.isReverse_) {\n          node = node.left;\n        } else {\n          node = node.right;\n        }\n      } else if (cmp === 0) {\n        // This node is exactly equal to our start key. Push it on the stack, but stop iterating;\n        this.nodeStack_.push(node);\n        break;\n      } else {\n        // This node is greater than our start key, add it to the stack and move to the next one\n        this.nodeStack_.push(node);\n        if (this.isReverse_) {\n          node = node.right;\n        } else {\n          node = node.left;\n        }\n      }\n    }\n  }\n\n  getNext(): T {\n    if (this.nodeStack_.length === 0) return null;\n\n    let node = this.nodeStack_.pop();\n    let result: T;\n    if (this.resultGenerator_)\n      result = this.resultGenerator_(node.key, node.value);\n    else result = { key: node.key, value: node.value } as any;\n\n    if (this.isReverse_) {\n      node = node.left;\n      while (!node.isEmpty()) {\n        this.nodeStack_.push(node);\n        node = node.right;\n      }\n    } else {\n      node = node.right;\n      while (!node.isEmpty()) {\n        this.nodeStack_.push(node);\n        node = node.left;\n      }\n    }\n\n    return result;\n  }\n\n  hasNext(): boolean {\n    return this.nodeStack_.length > 0;\n  }\n\n  peek(): T {\n    if (this.nodeStack_.length === 0) return null;\n\n    const node = this.nodeStack_[this.nodeStack_.length - 1];\n    if (this.resultGenerator_) {\n      return this.resultGenerator_(node.key, node.value);\n    } else {\n      return { key: node.key, value: node.value } as any;\n    }\n  }\n}\n\n/**\n * Represents a node in a Left-leaning Red-Black tree.\n */\nexport class LLRBNode<K, V> {\n  color: boolean;\n  left: LLRBNode<K, V> | LLRBEmptyNode<K, V>;\n  right: LLRBNode<K, V> | LLRBEmptyNode<K, V>;\n\n  /**\n   * @template K, V\n   * @param {!K} key Key associated with this node.\n   * @param {!V} value Value associated with this node.\n   * @param {?boolean} color Whether this node is red.\n   * @param {?(LLRBNode|LLRBEmptyNode)=} left Left child.\n   * @param {?(LLRBNode|LLRBEmptyNode)=} right Right child.\n   */\n  constructor(\n    public key: K,\n    public value: V,\n    color: boolean | null,\n    left?: LLRBNode<K, V> | LLRBEmptyNode<K, V> | null,\n    right?: LLRBNode<K, V> | LLRBEmptyNode<K, V> | null\n  ) {\n    this.color = color != null ? color : LLRBNode.RED;\n    this.left =\n      left != null ? left : SortedMap.EMPTY_NODE as LLRBEmptyNode<K, V>;\n    this.right =\n      right != null ? right : SortedMap.EMPTY_NODE as LLRBEmptyNode<K, V>;\n  }\n\n  static RED = true;\n  static BLACK = false;\n\n  /**\n   * Returns a copy of the current node, optionally replacing pieces of it.\n   *\n   * @param {?K} key New key for the node, or null.\n   * @param {?V} value New value for the node, or null.\n   * @param {?boolean} color New color for the node, or null.\n   * @param {?LLRBNode|LLRBEmptyNode} left New left child for the node, or null.\n   * @param {?LLRBNode|LLRBEmptyNode} right New right child for the node, or null.\n   * @return {!LLRBNode} The node copy.\n   */\n  copy(\n    key: K | null,\n    value: V | null,\n    color: boolean | null,\n    left: LLRBNode<K, V> | LLRBEmptyNode<K, V> | null,\n    right: LLRBNode<K, V> | LLRBEmptyNode<K, V> | null\n  ): LLRBNode<K, V> {\n    return new LLRBNode(\n      key != null ? key : this.key,\n      value != null ? value : this.value,\n      color != null ? color : this.color,\n      left != null ? left : this.left,\n      right != null ? right : this.right\n    );\n  }\n\n  /**\n   * @return {number} The total number of nodes in the tree.\n   */\n  count(): number {\n    return this.left.count() + 1 + this.right.count();\n  }\n\n  /**\n   * @return {boolean} True if the tree is empty.\n   */\n  isEmpty(): boolean {\n    return false;\n  }\n\n  /**\n   * Traverses the tree in key order and calls the specified action function\n   * for each node.\n   *\n   * @param {function(!K, !V):*} action Callback function to be called for each\n   *   node.  If it returns true, traversal is aborted.\n   * @return {*} The first truthy value returned by action, or the last falsey\n   *   value returned by action\n   */\n  inorderTraversal(action: (k: K, v: V) => any): boolean {\n    return (\n      this.left.inorderTraversal(action) ||\n      action(this.key, this.value) ||\n      this.right.inorderTraversal(action)\n    );\n  }\n\n  /**\n   * Traverses the tree in reverse key order and calls the specified action function\n   * for each node.\n   *\n   * @param {function(!Object, !Object)} action Callback function to be called for each\n   * node.  If it returns true, traversal is aborted.\n   * @return {*} True if traversal was aborted.\n   */\n  reverseTraversal(action: (k: K, v: V) => void): boolean {\n    return (\n      this.right.reverseTraversal(action) ||\n      action(this.key, this.value) ||\n      this.left.reverseTraversal(action)\n    );\n  }\n\n  /**\n   * @return {!Object} The minimum node in the tree.\n   * @private\n   */\n  private min_(): LLRBNode<K, V> {\n    if (this.left.isEmpty()) {\n      return this;\n    } else {\n      return (this.left as LLRBNode<K, V>).min_();\n    }\n  }\n\n  /**\n   * @return {!K} The maximum key in the tree.\n   */\n  minKey(): K {\n    return this.min_().key;\n  }\n\n  /**\n   * @return {!K} The maximum key in the tree.\n   */\n  maxKey(): K {\n    if (this.right.isEmpty()) {\n      return this.key;\n    } else {\n      return this.right.maxKey();\n    }\n  }\n\n  /**\n   *\n   * @param {!Object} key Key to insert.\n   * @param {!Object} value Value to insert.\n   * @param {Comparator} comparator Comparator.\n   * @return {!LLRBNode} New tree, with the key/value added.\n   */\n  insert(key: K, value: V, comparator: Comparator<K>): LLRBNode<K, V> {\n    let cmp, n;\n    n = this;\n    cmp = comparator(key, n.key);\n    if (cmp < 0) {\n      n = n.copy(null, null, null, n.left.insert(key, value, comparator), null);\n    } else if (cmp === 0) {\n      n = n.copy(null, value, null, null, null);\n    } else {\n      n = n.copy(\n        null,\n        null,\n        null,\n        null,\n        n.right.insert(key, value, comparator)\n      );\n    }\n    return n.fixUp_();\n  }\n\n  /**\n   * @private\n   * @return {!LLRBNode|LLRBEmptyNode} New tree, with the minimum key removed.\n   */\n  private removeMin_(): LLRBNode<K, V> | LLRBEmptyNode<K, V> {\n    if (this.left.isEmpty()) {\n      return SortedMap.EMPTY_NODE as LLRBEmptyNode<K, V>;\n    }\n    let n: LLRBNode<K, V> = this;\n    if (!n.left.isRed_() && !n.left.left.isRed_()) n = n.moveRedLeft_();\n    n = n.copy(null, null, null, (n.left as LLRBNode<K, V>).removeMin_(), null);\n    return n.fixUp_();\n  }\n\n  /**\n   * @param {!Object} key The key of the item to remove.\n   * @param {Comparator} comparator Comparator.\n   * @return {!LLRBNode|LLRBEmptyNode} New tree, with the specified item removed.\n   */\n  remove(\n    key: K,\n    comparator: Comparator<K>\n  ): LLRBNode<K, V> | LLRBEmptyNode<K, V> {\n    let n, smallest;\n    n = this;\n    if (comparator(key, n.key) < 0) {\n      if (!n.left.isEmpty() && !n.left.isRed_() && !n.left.left.isRed_()) {\n        n = n.moveRedLeft_();\n      }\n      n = n.copy(null, null, null, n.left.remove(key, comparator), null);\n    } else {\n      if (n.left.isRed_()) n = n.rotateRight_();\n      if (!n.right.isEmpty() && !n.right.isRed_() && !n.right.left.isRed_()) {\n        n = n.moveRedRight_();\n      }\n      if (comparator(key, n.key) === 0) {\n        if (n.right.isEmpty()) {\n          return SortedMap.EMPTY_NODE as LLRBEmptyNode<K, V>;\n        } else {\n          smallest = (n.right as LLRBNode<K, V>).min_();\n          n = n.copy(\n            smallest.key,\n            smallest.value,\n            null,\n            null,\n            (n.right as LLRBNode<K, V>).removeMin_()\n          );\n        }\n      }\n      n = n.copy(null, null, null, null, n.right.remove(key, comparator));\n    }\n    return n.fixUp_();\n  }\n\n  /**\n   * @private\n   * @return {boolean} Whether this is a RED node.\n   */\n  isRed_(): boolean {\n    return this.color;\n  }\n\n  /**\n   * @private\n   * @return {!LLRBNode} New tree after performing any needed rotations.\n   */\n  private fixUp_(): LLRBNode<K, V> {\n    let n = this as any;\n    if (n.right.isRed_() && !n.left.isRed_()) n = n.rotateLeft_();\n    if (n.left.isRed_() && n.left.left.isRed_()) n = n.rotateRight_();\n    if (n.left.isRed_() && n.right.isRed_()) n = n.colorFlip_();\n    return n;\n  }\n\n  /**\n   * @private\n   * @return {!LLRBNode} New tree, after moveRedLeft.\n   */\n  private moveRedLeft_(): LLRBNode<K, V> {\n    let n = this.colorFlip_();\n    if (n.right.left.isRed_()) {\n      n = n.copy(\n        null,\n        null,\n        null,\n        null,\n        (n.right as LLRBNode<K, V>).rotateRight_()\n      );\n      n = n.rotateLeft_();\n      n = n.colorFlip_();\n    }\n    return n;\n  }\n\n  /**\n   * @private\n   * @return {!LLRBNode} New tree, after moveRedRight.\n   */\n  private moveRedRight_(): LLRBNode<K, V> {\n    let n = this.colorFlip_();\n    if (n.left.left.isRed_()) {\n      n = n.rotateRight_();\n      n = n.colorFlip_();\n    }\n    return n;\n  }\n\n  /**\n   * @private\n   * @return {!LLRBNode} New tree, after rotateLeft.\n   */\n  private rotateLeft_(): LLRBNode<K, V> {\n    const nl = this.copy(null, null, LLRBNode.RED, null, this.right.left);\n    return this.right.copy(null, null, this.color, nl, null) as LLRBNode<K, V>;\n  }\n\n  /**\n   * @private\n   * @return {!LLRBNode} New tree, after rotateRight.\n   */\n  private rotateRight_(): LLRBNode<K, V> {\n    const nr = this.copy(null, null, LLRBNode.RED, this.left.right, null);\n    return this.left.copy(null, null, this.color, null, nr) as LLRBNode<K, V>;\n  }\n\n  /**\n   * @private\n   * @return {!LLRBNode} New tree, after colorFlip.\n   */\n  private colorFlip_(): LLRBNode<K, V> {\n    const left = this.left.copy(null, null, !this.left.color, null, null);\n    const right = this.right.copy(null, null, !this.right.color, null, null);\n    return this.copy(null, null, !this.color, left, right);\n  }\n\n  /**\n   * For testing.\n   *\n   * @private\n   * @return {boolean} True if all is well.\n   */\n  private checkMaxDepth_(): boolean {\n    const blackDepth = this.check_();\n    return Math.pow(2.0, blackDepth) <= this.count() + 1;\n  }\n\n  /**\n   * @private\n   * @return {number} Not sure what this returns exactly. :-).\n   */\n  check_(): number {\n    let blackDepth;\n    if (this.isRed_() && this.left.isRed_()) {\n      throw new Error(\n        'Red node has red child(' + this.key + ',' + this.value + ')'\n      );\n    }\n    if (this.right.isRed_()) {\n      throw new Error(\n        'Right child of (' + this.key + ',' + this.value + ') is red'\n      );\n    }\n    blackDepth = this.left.check_();\n    if (blackDepth !== this.right.check_()) {\n      throw new Error('Black depths differ');\n    } else {\n      return blackDepth + (this.isRed_() ? 0 : 1);\n    }\n  }\n}\n\n/**\n * Represents an empty node (a leaf node in the Red-Black Tree).\n */\nexport class LLRBEmptyNode<K, V> {\n  key: K;\n  value: V;\n  left: LLRBNode<K, V> | LLRBEmptyNode<K, V>;\n  right: LLRBNode<K, V> | LLRBEmptyNode<K, V>;\n  color: boolean;\n\n  /**\n   * Returns a copy of the current node.\n   *\n   * @return {!LLRBEmptyNode} The node copy.\n   */\n  copy(\n    key: K | null,\n    value: V | null,\n    color: boolean | null,\n    left: LLRBNode<K, V> | LLRBEmptyNode<K, V> | null,\n    right: LLRBNode<K, V> | LLRBEmptyNode<K, V> | null\n  ): LLRBEmptyNode<K, V> {\n    return this;\n  }\n\n  /**\n   * Returns a copy of the tree, with the specified key/value added.\n   *\n   * @param {!K} key Key to be added.\n   * @param {!V} value Value to be added.\n   * @param {Comparator} comparator Comparator.\n   * @return {!LLRBNode} New tree, with item added.\n   */\n  insert(key: K, value: V, comparator: Comparator<K>): LLRBNode<K, V> {\n    return new LLRBNode(key, value, null);\n  }\n\n  /**\n   * Returns a copy of the tree, with the specified key removed.\n   *\n   * @param {!K} key The key to remove.\n   * @param {Comparator} comparator Comparator.\n   * @return {!LLRBEmptyNode} New tree, with item removed.\n   */\n  remove(key: K, comparator: Comparator<K>): LLRBEmptyNode<K, V> {\n    return this;\n  }\n\n  /**\n   * @return {number} The total number of nodes in the tree.\n   */\n  count(): number {\n    return 0;\n  }\n\n  /**\n   * @return {boolean} True if the tree is empty.\n   */\n  isEmpty(): boolean {\n    return true;\n  }\n\n  /**\n   * Traverses the tree in key order and calls the specified action function\n   * for each node.\n   *\n   * @param {function(!K, !V):*} action Callback function to be called for each\n   * node.  If it returns true, traversal is aborted.\n   * @return {boolean} True if traversal was aborted.\n   */\n  inorderTraversal(action: (k: K, v: V) => any): boolean {\n    return false;\n  }\n\n  /**\n   * Traverses the tree in reverse key order and calls the specified action function\n   * for each node.\n   *\n   * @param {function(!K, !V)} action Callback function to be called for each\n   * node.  If it returns true, traversal is aborted.\n   * @return {boolean} True if traversal was aborted.\n   */\n  reverseTraversal(action: (k: K, v: V) => void): boolean {\n    return false;\n  }\n\n  /**\n   * @return {null}\n   */\n  minKey(): null {\n    return null;\n  }\n\n  /**\n   * @return {null}\n   */\n  maxKey(): null {\n    return null;\n  }\n\n  /**\n   * @private\n   * @return {number} Not sure what this returns exactly. :-).\n   */\n  check_(): number {\n    return 0;\n  }\n\n  /**\n   * @private\n   * @return {boolean} Whether this node is red.\n   */\n  isRed_() {\n    return false;\n  }\n}\n\n/**\n * An immutable sorted map implementation, based on a Left-leaning Red-Black\n * tree.\n */\nexport class SortedMap<K, V> {\n  /**\n   * Always use the same empty node, to reduce memory.\n   * @const\n   */\n  static EMPTY_NODE = new LLRBEmptyNode();\n\n  /**\n   * @template K, V\n   * @param {function(K, K):number} comparator_ Key comparator.\n   * @param {LLRBNode=} root_ (Optional) Root node for the map.\n   */\n  constructor(\n    private comparator_: Comparator<K>,\n    private root_:\n      | LLRBNode<K, V>\n      | LLRBEmptyNode<K, V> = SortedMap.EMPTY_NODE as LLRBEmptyNode<K, V>\n  ) {}\n\n  /**\n   * Returns a copy of the map, with the specified key/value added or replaced.\n   * (TODO: We should perhaps rename this method to 'put')\n   *\n   * @param {!K} key Key to be added.\n   * @param {!V} value Value to be added.\n   * @return {!SortedMap.<K, V>} New map, with item added.\n   */\n  insert(key: K, value: V): SortedMap<K, V> {\n    return new SortedMap(\n      this.comparator_,\n      this.root_\n        .insert(key, value, this.comparator_)\n        .copy(null, null, LLRBNode.BLACK, null, null)\n    );\n  }\n\n  /**\n   * Returns a copy of the map, with the specified key removed.\n   *\n   * @param {!K} key The key to remove.\n   * @return {!SortedMap.<K, V>} New map, with item removed.\n   */\n  remove(key: K): SortedMap<K, V> {\n    return new SortedMap(\n      this.comparator_,\n      this.root_\n        .remove(key, this.comparator_)\n        .copy(null, null, LLRBNode.BLACK, null, null)\n    );\n  }\n\n  /**\n   * Returns the value of the node with the given key, or null.\n   *\n   * @param {!K} key The key to look up.\n   * @return {?V} The value of the node with the given key, or null if the\n   * key doesn't exist.\n   */\n  get(key: K): V | null {\n    let cmp;\n    let node = this.root_;\n    while (!node.isEmpty()) {\n      cmp = this.comparator_(key, node.key);\n      if (cmp === 0) {\n        return node.value;\n      } else if (cmp < 0) {\n        node = node.left;\n      } else if (cmp > 0) {\n        node = node.right;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Returns the key of the item *before* the specified key, or null if key is the first item.\n   * @param {K} key The key to find the predecessor of\n   * @return {?K} The predecessor key.\n   */\n  getPredecessorKey(key: K): K | null {\n    let cmp,\n      node = this.root_,\n      rightParent = null;\n    while (!node.isEmpty()) {\n      cmp = this.comparator_(key, node.key);\n      if (cmp === 0) {\n        if (!node.left.isEmpty()) {\n          node = node.left;\n          while (!node.right.isEmpty()) node = node.right;\n          return node.key;\n        } else if (rightParent) {\n          return rightParent.key;\n        } else {\n          return null; // first item.\n        }\n      } else if (cmp < 0) {\n        node = node.left;\n      } else if (cmp > 0) {\n        rightParent = node;\n        node = node.right;\n      }\n    }\n\n    throw new Error(\n      'Attempted to find predecessor key for a nonexistent key.  What gives?'\n    );\n  }\n\n  /**\n   * @return {boolean} True if the map is empty.\n   */\n  isEmpty(): boolean {\n    return this.root_.isEmpty();\n  }\n\n  /**\n   * @return {number} The total number of nodes in the map.\n   */\n  count(): number {\n    return this.root_.count();\n  }\n\n  /**\n   * @return {?K} The minimum key in the map.\n   */\n  minKey(): K | null {\n    return this.root_.minKey();\n  }\n\n  /**\n   * @return {?K} The maximum key in the map.\n   */\n  maxKey(): K | null {\n    return this.root_.maxKey();\n  }\n\n  /**\n   * Traverses the map in key order and calls the specified action function\n   * for each key/value pair.\n   *\n   * @param {function(!K, !V):*} action Callback function to be called\n   * for each key/value pair.  If action returns true, traversal is aborted.\n   * @return {*} The first truthy value returned by action, or the last falsey\n   *   value returned by action\n   */\n  inorderTraversal(action: (k: K, v: V) => any): boolean {\n    return this.root_.inorderTraversal(action);\n  }\n\n  /**\n   * Traverses the map in reverse key order and calls the specified action function\n   * for each key/value pair.\n   *\n   * @param {function(!Object, !Object)} action Callback function to be called\n   * for each key/value pair.  If action returns true, traversal is aborted.\n   * @return {*} True if the traversal was aborted.\n   */\n  reverseTraversal(action: (k: K, v: V) => void): boolean {\n    return this.root_.reverseTraversal(action);\n  }\n\n  /**\n   * Returns an iterator over the SortedMap.\n   * @template T\n   * @param {(function(K, V):T)=} resultGenerator\n   * @return {SortedMapIterator.<K, V, T>} The iterator.\n   */\n  getIterator<T>(\n    resultGenerator?: (k: K, v: V) => T\n  ): SortedMapIterator<K, V, T> {\n    return new SortedMapIterator(\n      this.root_,\n      null,\n      this.comparator_,\n      false,\n      resultGenerator\n    );\n  }\n\n  getIteratorFrom<T>(\n    key: K,\n    resultGenerator?: (k: K, v: V) => T\n  ): SortedMapIterator<K, V, T> {\n    return new SortedMapIterator(\n      this.root_,\n      key,\n      this.comparator_,\n      false,\n      resultGenerator\n    );\n  }\n\n  getReverseIteratorFrom<T>(\n    key: K,\n    resultGenerator?: (k: K, v: V) => T\n  ): SortedMapIterator<K, V, T> {\n    return new SortedMapIterator(\n      this.root_,\n      key,\n      this.comparator_,\n      true,\n      resultGenerator\n    );\n  }\n\n  getReverseIterator<T>(\n    resultGenerator?: (k: K, v: V) => T\n  ): SortedMapIterator<K, V, T> {\n    return new SortedMapIterator(\n      this.root_,\n      null,\n      this.comparator_,\n      true,\n      resultGenerator\n    );\n  }\n}\n","/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n/**\n * An iterator over an LLRBNode.\n */\nvar SortedMapIterator = (function () {\n    /**\n     * @template K, V, T\n     * @param {LLRBNode|LLRBEmptyNode} node Node to iterate.\n     * @param {?K} startKey\n     * @param {function(K, K): number} comparator\n     * @param {boolean} isReverse_ Whether or not to iterate in reverse\n     * @param {(function(K, V):T)=} resultGenerator_\n     */\n    function SortedMapIterator(node, startKey, comparator, isReverse_, resultGenerator_) {\n        if (resultGenerator_ === void 0) { resultGenerator_ = null; }\n        this.isReverse_ = isReverse_;\n        this.resultGenerator_ = resultGenerator_;\n        /** @private\n         * @type {Array.<!LLRBNode>}\n         */\n        this.nodeStack_ = [];\n        var cmp = 1;\n        while (!node.isEmpty()) {\n            node = node;\n            cmp = startKey ? comparator(node.key, startKey) : 1;\n            // flip the comparison if we're going in reverse\n            if (isReverse_)\n                cmp *= -1;\n            if (cmp < 0) {\n                // This node is less than our start key. ignore it\n                if (this.isReverse_) {\n                    node = node.left;\n                }\n                else {\n                    node = node.right;\n                }\n            }\n            else if (cmp === 0) {\n                // This node is exactly equal to our start key. Push it on the stack, but stop iterating;\n                this.nodeStack_.push(node);\n                break;\n            }\n            else {\n                // This node is greater than our start key, add it to the stack and move to the next one\n                this.nodeStack_.push(node);\n                if (this.isReverse_) {\n                    node = node.right;\n                }\n                else {\n                    node = node.left;\n                }\n            }\n        }\n    }\n    SortedMapIterator.prototype.getNext = function () {\n        if (this.nodeStack_.length === 0)\n            return null;\n        var node = this.nodeStack_.pop();\n        var result;\n        if (this.resultGenerator_)\n            result = this.resultGenerator_(node.key, node.value);\n        else\n            result = { key: node.key, value: node.value };\n        if (this.isReverse_) {\n            node = node.left;\n            while (!node.isEmpty()) {\n                this.nodeStack_.push(node);\n                node = node.right;\n            }\n        }\n        else {\n            node = node.right;\n            while (!node.isEmpty()) {\n                this.nodeStack_.push(node);\n                node = node.left;\n            }\n        }\n        return result;\n    };\n    SortedMapIterator.prototype.hasNext = function () {\n        return this.nodeStack_.length > 0;\n    };\n    SortedMapIterator.prototype.peek = function () {\n        if (this.nodeStack_.length === 0)\n            return null;\n        var node = this.nodeStack_[this.nodeStack_.length - 1];\n        if (this.resultGenerator_) {\n            return this.resultGenerator_(node.key, node.value);\n        }\n        else {\n            return { key: node.key, value: node.value };\n        }\n    };\n    return SortedMapIterator;\n}());\nexport { SortedMapIterator };\n/**\n * Represents a node in a Left-leaning Red-Black tree.\n */\nvar LLRBNode = (function () {\n    /**\n     * @template K, V\n     * @param {!K} key Key associated with this node.\n     * @param {!V} value Value associated with this node.\n     * @param {?boolean} color Whether this node is red.\n     * @param {?(LLRBNode|LLRBEmptyNode)=} left Left child.\n     * @param {?(LLRBNode|LLRBEmptyNode)=} right Right child.\n     */\n    function LLRBNode(key, value, color, left, right) {\n        this.key = key;\n        this.value = value;\n        this.color = color != null ? color : LLRBNode.RED;\n        this.left =\n            left != null ? left : SortedMap.EMPTY_NODE;\n        this.right =\n            right != null ? right : SortedMap.EMPTY_NODE;\n    }\n    /**\n     * Returns a copy of the current node, optionally replacing pieces of it.\n     *\n     * @param {?K} key New key for the node, or null.\n     * @param {?V} value New value for the node, or null.\n     * @param {?boolean} color New color for the node, or null.\n     * @param {?LLRBNode|LLRBEmptyNode} left New left child for the node, or null.\n     * @param {?LLRBNode|LLRBEmptyNode} right New right child for the node, or null.\n     * @return {!LLRBNode} The node copy.\n     */\n    LLRBNode.prototype.copy = function (key, value, color, left, right) {\n        return new LLRBNode(key != null ? key : this.key, value != null ? value : this.value, color != null ? color : this.color, left != null ? left : this.left, right != null ? right : this.right);\n    };\n    /**\n     * @return {number} The total number of nodes in the tree.\n     */\n    LLRBNode.prototype.count = function () {\n        return this.left.count() + 1 + this.right.count();\n    };\n    /**\n     * @return {boolean} True if the tree is empty.\n     */\n    LLRBNode.prototype.isEmpty = function () {\n        return false;\n    };\n    /**\n     * Traverses the tree in key order and calls the specified action function\n     * for each node.\n     *\n     * @param {function(!K, !V):*} action Callback function to be called for each\n     *   node.  If it returns true, traversal is aborted.\n     * @return {*} The first truthy value returned by action, or the last falsey\n     *   value returned by action\n     */\n    LLRBNode.prototype.inorderTraversal = function (action) {\n        return (this.left.inorderTraversal(action) ||\n            action(this.key, this.value) ||\n            this.right.inorderTraversal(action));\n    };\n    /**\n     * Traverses the tree in reverse key order and calls the specified action function\n     * for each node.\n     *\n     * @param {function(!Object, !Object)} action Callback function to be called for each\n     * node.  If it returns true, traversal is aborted.\n     * @return {*} True if traversal was aborted.\n     */\n    LLRBNode.prototype.reverseTraversal = function (action) {\n        return (this.right.reverseTraversal(action) ||\n            action(this.key, this.value) ||\n            this.left.reverseTraversal(action));\n    };\n    /**\n     * @return {!Object} The minimum node in the tree.\n     * @private\n     */\n    LLRBNode.prototype.min_ = function () {\n        if (this.left.isEmpty()) {\n            return this;\n        }\n        else {\n            return this.left.min_();\n        }\n    };\n    /**\n     * @return {!K} The maximum key in the tree.\n     */\n    LLRBNode.prototype.minKey = function () {\n        return this.min_().key;\n    };\n    /**\n     * @return {!K} The maximum key in the tree.\n     */\n    LLRBNode.prototype.maxKey = function () {\n        if (this.right.isEmpty()) {\n            return this.key;\n        }\n        else {\n            return this.right.maxKey();\n        }\n    };\n    /**\n     *\n     * @param {!Object} key Key to insert.\n     * @param {!Object} value Value to insert.\n     * @param {Comparator} comparator Comparator.\n     * @return {!LLRBNode} New tree, with the key/value added.\n     */\n    LLRBNode.prototype.insert = function (key, value, comparator) {\n        var cmp, n;\n        n = this;\n        cmp = comparator(key, n.key);\n        if (cmp < 0) {\n            n = n.copy(null, null, null, n.left.insert(key, value, comparator), null);\n        }\n        else if (cmp === 0) {\n            n = n.copy(null, value, null, null, null);\n        }\n        else {\n            n = n.copy(null, null, null, null, n.right.insert(key, value, comparator));\n        }\n        return n.fixUp_();\n    };\n    /**\n     * @private\n     * @return {!LLRBNode|LLRBEmptyNode} New tree, with the minimum key removed.\n     */\n    LLRBNode.prototype.removeMin_ = function () {\n        if (this.left.isEmpty()) {\n            return SortedMap.EMPTY_NODE;\n        }\n        var n = this;\n        if (!n.left.isRed_() && !n.left.left.isRed_())\n            n = n.moveRedLeft_();\n        n = n.copy(null, null, null, n.left.removeMin_(), null);\n        return n.fixUp_();\n    };\n    /**\n     * @param {!Object} key The key of the item to remove.\n     * @param {Comparator} comparator Comparator.\n     * @return {!LLRBNode|LLRBEmptyNode} New tree, with the specified item removed.\n     */\n    LLRBNode.prototype.remove = function (key, comparator) {\n        var n, smallest;\n        n = this;\n        if (comparator(key, n.key) < 0) {\n            if (!n.left.isEmpty() && !n.left.isRed_() && !n.left.left.isRed_()) {\n                n = n.moveRedLeft_();\n            }\n            n = n.copy(null, null, null, n.left.remove(key, comparator), null);\n        }\n        else {\n            if (n.left.isRed_())\n                n = n.rotateRight_();\n            if (!n.right.isEmpty() && !n.right.isRed_() && !n.right.left.isRed_()) {\n                n = n.moveRedRight_();\n            }\n            if (comparator(key, n.key) === 0) {\n                if (n.right.isEmpty()) {\n                    return SortedMap.EMPTY_NODE;\n                }\n                else {\n                    smallest = n.right.min_();\n                    n = n.copy(smallest.key, smallest.value, null, null, n.right.removeMin_());\n                }\n            }\n            n = n.copy(null, null, null, null, n.right.remove(key, comparator));\n        }\n        return n.fixUp_();\n    };\n    /**\n     * @private\n     * @return {boolean} Whether this is a RED node.\n     */\n    LLRBNode.prototype.isRed_ = function () {\n        return this.color;\n    };\n    /**\n     * @private\n     * @return {!LLRBNode} New tree after performing any needed rotations.\n     */\n    LLRBNode.prototype.fixUp_ = function () {\n        var n = this;\n        if (n.right.isRed_() && !n.left.isRed_())\n            n = n.rotateLeft_();\n        if (n.left.isRed_() && n.left.left.isRed_())\n            n = n.rotateRight_();\n        if (n.left.isRed_() && n.right.isRed_())\n            n = n.colorFlip_();\n        return n;\n    };\n    /**\n     * @private\n     * @return {!LLRBNode} New tree, after moveRedLeft.\n     */\n    LLRBNode.prototype.moveRedLeft_ = function () {\n        var n = this.colorFlip_();\n        if (n.right.left.isRed_()) {\n            n = n.copy(null, null, null, null, n.right.rotateRight_());\n            n = n.rotateLeft_();\n            n = n.colorFlip_();\n        }\n        return n;\n    };\n    /**\n     * @private\n     * @return {!LLRBNode} New tree, after moveRedRight.\n     */\n    LLRBNode.prototype.moveRedRight_ = function () {\n        var n = this.colorFlip_();\n        if (n.left.left.isRed_()) {\n            n = n.rotateRight_();\n            n = n.colorFlip_();\n        }\n        return n;\n    };\n    /**\n     * @private\n     * @return {!LLRBNode} New tree, after rotateLeft.\n     */\n    LLRBNode.prototype.rotateLeft_ = function () {\n        var nl = this.copy(null, null, LLRBNode.RED, null, this.right.left);\n        return this.right.copy(null, null, this.color, nl, null);\n    };\n    /**\n     * @private\n     * @return {!LLRBNode} New tree, after rotateRight.\n     */\n    LLRBNode.prototype.rotateRight_ = function () {\n        var nr = this.copy(null, null, LLRBNode.RED, this.left.right, null);\n        return this.left.copy(null, null, this.color, null, nr);\n    };\n    /**\n     * @private\n     * @return {!LLRBNode} New tree, after colorFlip.\n     */\n    LLRBNode.prototype.colorFlip_ = function () {\n        var left = this.left.copy(null, null, !this.left.color, null, null);\n        var right = this.right.copy(null, null, !this.right.color, null, null);\n        return this.copy(null, null, !this.color, left, right);\n    };\n    /**\n     * For testing.\n     *\n     * @private\n     * @return {boolean} True if all is well.\n     */\n    LLRBNode.prototype.checkMaxDepth_ = function () {\n        var blackDepth = this.check_();\n        return Math.pow(2.0, blackDepth) <= this.count() + 1;\n    };\n    /**\n     * @private\n     * @return {number} Not sure what this returns exactly. :-).\n     */\n    LLRBNode.prototype.check_ = function () {\n        var blackDepth;\n        if (this.isRed_() && this.left.isRed_()) {\n            throw new Error('Red node has red child(' + this.key + ',' + this.value + ')');\n        }\n        if (this.right.isRed_()) {\n            throw new Error('Right child of (' + this.key + ',' + this.value + ') is red');\n        }\n        blackDepth = this.left.check_();\n        if (blackDepth !== this.right.check_()) {\n            throw new Error('Black depths differ');\n        }\n        else {\n            return blackDepth + (this.isRed_() ? 0 : 1);\n        }\n    };\n    LLRBNode.RED = true;\n    LLRBNode.BLACK = false;\n    return LLRBNode;\n}());\nexport { LLRBNode };\n/**\n * Represents an empty node (a leaf node in the Red-Black Tree).\n */\nvar LLRBEmptyNode = (function () {\n    function LLRBEmptyNode() {\n    }\n    /**\n     * Returns a copy of the current node.\n     *\n     * @return {!LLRBEmptyNode} The node copy.\n     */\n    LLRBEmptyNode.prototype.copy = function (key, value, color, left, right) {\n        return this;\n    };\n    /**\n     * Returns a copy of the tree, with the specified key/value added.\n     *\n     * @param {!K} key Key to be added.\n     * @param {!V} value Value to be added.\n     * @param {Comparator} comparator Comparator.\n     * @return {!LLRBNode} New tree, with item added.\n     */\n    LLRBEmptyNode.prototype.insert = function (key, value, comparator) {\n        return new LLRBNode(key, value, null);\n    };\n    /**\n     * Returns a copy of the tree, with the specified key removed.\n     *\n     * @param {!K} key The key to remove.\n     * @param {Comparator} comparator Comparator.\n     * @return {!LLRBEmptyNode} New tree, with item removed.\n     */\n    LLRBEmptyNode.prototype.remove = function (key, comparator) {\n        return this;\n    };\n    /**\n     * @return {number} The total number of nodes in the tree.\n     */\n    LLRBEmptyNode.prototype.count = function () {\n        return 0;\n    };\n    /**\n     * @return {boolean} True if the tree is empty.\n     */\n    LLRBEmptyNode.prototype.isEmpty = function () {\n        return true;\n    };\n    /**\n     * Traverses the tree in key order and calls the specified action function\n     * for each node.\n     *\n     * @param {function(!K, !V):*} action Callback function to be called for each\n     * node.  If it returns true, traversal is aborted.\n     * @return {boolean} True if traversal was aborted.\n     */\n    LLRBEmptyNode.prototype.inorderTraversal = function (action) {\n        return false;\n    };\n    /**\n     * Traverses the tree in reverse key order and calls the specified action function\n     * for each node.\n     *\n     * @param {function(!K, !V)} action Callback function to be called for each\n     * node.  If it returns true, traversal is aborted.\n     * @return {boolean} True if traversal was aborted.\n     */\n    LLRBEmptyNode.prototype.reverseTraversal = function (action) {\n        return false;\n    };\n    /**\n     * @return {null}\n     */\n    LLRBEmptyNode.prototype.minKey = function () {\n        return null;\n    };\n    /**\n     * @return {null}\n     */\n    LLRBEmptyNode.prototype.maxKey = function () {\n        return null;\n    };\n    /**\n     * @private\n     * @return {number} Not sure what this returns exactly. :-).\n     */\n    LLRBEmptyNode.prototype.check_ = function () {\n        return 0;\n    };\n    /**\n     * @private\n     * @return {boolean} Whether this node is red.\n     */\n    LLRBEmptyNode.prototype.isRed_ = function () {\n        return false;\n    };\n    return LLRBEmptyNode;\n}());\nexport { LLRBEmptyNode };\n/**\n * An immutable sorted map implementation, based on a Left-leaning Red-Black\n * tree.\n */\nvar SortedMap = (function () {\n    /**\n     * @template K, V\n     * @param {function(K, K):number} comparator_ Key comparator.\n     * @param {LLRBNode=} root_ (Optional) Root node for the map.\n     */\n    function SortedMap(comparator_, root_) {\n        if (root_ === void 0) { root_ = SortedMap.EMPTY_NODE; }\n        this.comparator_ = comparator_;\n        this.root_ = root_;\n    }\n    /**\n     * Returns a copy of the map, with the specified key/value added or replaced.\n     * (TODO: We should perhaps rename this method to 'put')\n     *\n     * @param {!K} key Key to be added.\n     * @param {!V} value Value to be added.\n     * @return {!SortedMap.<K, V>} New map, with item added.\n     */\n    SortedMap.prototype.insert = function (key, value) {\n        return new SortedMap(this.comparator_, this.root_\n            .insert(key, value, this.comparator_)\n            .copy(null, null, LLRBNode.BLACK, null, null));\n    };\n    /**\n     * Returns a copy of the map, with the specified key removed.\n     *\n     * @param {!K} key The key to remove.\n     * @return {!SortedMap.<K, V>} New map, with item removed.\n     */\n    SortedMap.prototype.remove = function (key) {\n        return new SortedMap(this.comparator_, this.root_\n            .remove(key, this.comparator_)\n            .copy(null, null, LLRBNode.BLACK, null, null));\n    };\n    /**\n     * Returns the value of the node with the given key, or null.\n     *\n     * @param {!K} key The key to look up.\n     * @return {?V} The value of the node with the given key, or null if the\n     * key doesn't exist.\n     */\n    SortedMap.prototype.get = function (key) {\n        var cmp;\n        var node = this.root_;\n        while (!node.isEmpty()) {\n            cmp = this.comparator_(key, node.key);\n            if (cmp === 0) {\n                return node.value;\n            }\n            else if (cmp < 0) {\n                node = node.left;\n            }\n            else if (cmp > 0) {\n                node = node.right;\n            }\n        }\n        return null;\n    };\n    /**\n     * Returns the key of the item *before* the specified key, or null if key is the first item.\n     * @param {K} key The key to find the predecessor of\n     * @return {?K} The predecessor key.\n     */\n    SortedMap.prototype.getPredecessorKey = function (key) {\n        var cmp, node = this.root_, rightParent = null;\n        while (!node.isEmpty()) {\n            cmp = this.comparator_(key, node.key);\n            if (cmp === 0) {\n                if (!node.left.isEmpty()) {\n                    node = node.left;\n                    while (!node.right.isEmpty())\n                        node = node.right;\n                    return node.key;\n                }\n                else if (rightParent) {\n                    return rightParent.key;\n                }\n                else {\n                    return null; // first item.\n                }\n            }\n            else if (cmp < 0) {\n                node = node.left;\n            }\n            else if (cmp > 0) {\n                rightParent = node;\n                node = node.right;\n            }\n        }\n        throw new Error('Attempted to find predecessor key for a nonexistent key.  What gives?');\n    };\n    /**\n     * @return {boolean} True if the map is empty.\n     */\n    SortedMap.prototype.isEmpty = function () {\n        return this.root_.isEmpty();\n    };\n    /**\n     * @return {number} The total number of nodes in the map.\n     */\n    SortedMap.prototype.count = function () {\n        return this.root_.count();\n    };\n    /**\n     * @return {?K} The minimum key in the map.\n     */\n    SortedMap.prototype.minKey = function () {\n        return this.root_.minKey();\n    };\n    /**\n     * @return {?K} The maximum key in the map.\n     */\n    SortedMap.prototype.maxKey = function () {\n        return this.root_.maxKey();\n    };\n    /**\n     * Traverses the map in key order and calls the specified action function\n     * for each key/value pair.\n     *\n     * @param {function(!K, !V):*} action Callback function to be called\n     * for each key/value pair.  If action returns true, traversal is aborted.\n     * @return {*} The first truthy value returned by action, or the last falsey\n     *   value returned by action\n     */\n    SortedMap.prototype.inorderTraversal = function (action) {\n        return this.root_.inorderTraversal(action);\n    };\n    /**\n     * Traverses the map in reverse key order and calls the specified action function\n     * for each key/value pair.\n     *\n     * @param {function(!Object, !Object)} action Callback function to be called\n     * for each key/value pair.  If action returns true, traversal is aborted.\n     * @return {*} True if the traversal was aborted.\n     */\n    SortedMap.prototype.reverseTraversal = function (action) {\n        return this.root_.reverseTraversal(action);\n    };\n    /**\n     * Returns an iterator over the SortedMap.\n     * @template T\n     * @param {(function(K, V):T)=} resultGenerator\n     * @return {SortedMapIterator.<K, V, T>} The iterator.\n     */\n    SortedMap.prototype.getIterator = function (resultGenerator) {\n        return new SortedMapIterator(this.root_, null, this.comparator_, false, resultGenerator);\n    };\n    SortedMap.prototype.getIteratorFrom = function (key, resultGenerator) {\n        return new SortedMapIterator(this.root_, key, this.comparator_, false, resultGenerator);\n    };\n    SortedMap.prototype.getReverseIteratorFrom = function (key, resultGenerator) {\n        return new SortedMapIterator(this.root_, key, this.comparator_, true, resultGenerator);\n    };\n    SortedMap.prototype.getReverseIterator = function (resultGenerator) {\n        return new SortedMapIterator(this.root_, null, this.comparator_, true, resultGenerator);\n    };\n    /**\n     * Always use the same empty node, to reduce memory.\n     * @const\n     */\n    SortedMap.EMPTY_NODE = new LLRBEmptyNode();\n    return SortedMap;\n}());\nexport { SortedMap };\n\n\n"]}