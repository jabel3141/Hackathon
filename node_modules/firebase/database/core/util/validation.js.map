{"version":3,"sources":["database/src/database/core/util/validation.ts"],"names":["INVALID_KEY_REGEX_","INVALID_PATH_REGEX_","MAX_LEAF_SIZE_","isValidKey","key","length","test","isValidPathString","pathString","isValidRootPathString","replace","isValidPriority","priority","validateFirebaseDataArg","fnName","argumentNumber","data","path","optional","undefined","validateFirebaseData","errorPrefix","path_","Error","toErrorString","toString","substring","hasDotValue_1","hasActualChild_1","value","push","pop","validateFirebaseMergePaths","mergePaths","i","curPath","keys","slice","j","sort","comparePaths","prevPath","contains","validateFirebaseMergeDataArg","Array","isArray","child","getBack","validatePriority","validateEventType","eventType","validateKey","validatePathString","validateRootPathString","validateWritablePath","getFront","validateUrl","parsedUrl","repoInfo","host","namespace","validateCredential","cred","validateBoolean","bool","validateString","string","validateObject","obj","validateObjectContainsKey","opt_type","objectContainsKey","val"],"mappings":"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","file":"validation.js","sourcesContent":["/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\nimport { Path, ValidationPath } from './Path';\nimport { forEach, contains, safeGet } from '../../../utils/obj';\nimport { isInvalidJSONNumber } from './util';\nimport { errorPrefix as errorPrefixFxn } from '../../../utils/validation';\nimport { stringLength } from '../../../utils/utf8';\nimport { RepoInfo } from '../RepoInfo';\n\n/**\n * True for invalid Firebase keys\n * @type {RegExp}\n * @private\n */\nexport const INVALID_KEY_REGEX_ = /[\\[\\].#$\\/\\u0000-\\u001F\\u007F]/;\n\n/**\n * True for invalid Firebase paths.\n * Allows '/' in paths.\n * @type {RegExp}\n * @private\n */\nexport const INVALID_PATH_REGEX_ = /[\\[\\].#$\\u0000-\\u001F\\u007F]/;\n\n/**\n * Maximum number of characters to allow in leaf value\n * @type {number}\n * @private\n */\nexport const MAX_LEAF_SIZE_ = 10 * 1024 * 1024;\n\n/**\n * @param {*} key\n * @return {boolean}\n */\nexport const isValidKey = function(key: any): boolean {\n  return (\n    typeof key === 'string' && key.length !== 0 && !INVALID_KEY_REGEX_.test(key)\n  );\n};\n\n/**\n * @param {string} pathString\n * @return {boolean}\n */\nexport const isValidPathString = function(pathString: string): boolean {\n  return (\n    typeof pathString === 'string' &&\n    pathString.length !== 0 &&\n    !INVALID_PATH_REGEX_.test(pathString)\n  );\n};\n\n/**\n * @param {string} pathString\n * @return {boolean}\n */\nexport const isValidRootPathString = function(pathString: string): boolean {\n  if (pathString) {\n    // Allow '/.info/' at the beginning.\n    pathString = pathString.replace(/^\\/*\\.info(\\/|$)/, '/');\n  }\n\n  return isValidPathString(pathString);\n};\n\n/**\n * @param {*} priority\n * @return {boolean}\n */\nexport const isValidPriority = function(priority: any): boolean {\n  return (\n    priority === null ||\n    typeof priority === 'string' ||\n    (typeof priority === 'number' && !isInvalidJSONNumber(priority)) ||\n    (priority && typeof priority === 'object' && contains(priority, '.sv'))\n  );\n};\n\n/**\n * Pre-validate a datum passed as an argument to Firebase function.\n *\n * @param {string} fnName\n * @param {number} argumentNumber\n * @param {*} data\n * @param {!Path} path\n * @param {boolean} optional\n */\nexport const validateFirebaseDataArg = function(\n  fnName: string,\n  argumentNumber: number,\n  data: any,\n  path: Path,\n  optional: boolean\n) {\n  if (optional && data === undefined) return;\n\n  validateFirebaseData(\n    errorPrefixFxn(fnName, argumentNumber, optional),\n    data,\n    path\n  );\n};\n\n/**\n * Validate a data object client-side before sending to server.\n *\n * @param {string} errorPrefix\n * @param {*} data\n * @param {!Path|!ValidationPath} path_\n */\nexport const validateFirebaseData = function(\n  errorPrefix: string,\n  data: any,\n  path_: Path | ValidationPath\n) {\n  const path =\n    path_ instanceof Path ? new ValidationPath(path_, errorPrefix) : path_;\n\n  if (data === undefined) {\n    throw new Error(errorPrefix + 'contains undefined ' + path.toErrorString());\n  }\n  if (typeof data === 'function') {\n    throw new Error(\n      errorPrefix +\n        'contains a function ' +\n        path.toErrorString() +\n        ' with contents = ' +\n        data.toString()\n    );\n  }\n  if (isInvalidJSONNumber(data)) {\n    throw new Error(\n      errorPrefix + 'contains ' + data.toString() + ' ' + path.toErrorString()\n    );\n  }\n\n  // Check max leaf size, but try to avoid the utf8 conversion if we can.\n  if (\n    typeof data === 'string' &&\n    data.length > MAX_LEAF_SIZE_ / 3 &&\n    stringLength(data) > MAX_LEAF_SIZE_\n  ) {\n    throw new Error(\n      errorPrefix +\n        'contains a string greater than ' +\n        MAX_LEAF_SIZE_ +\n        ' utf8 bytes ' +\n        path.toErrorString() +\n        \" ('\" +\n        data.substring(0, 50) +\n        \"...')\"\n    );\n  }\n\n  // TODO = Perf = Consider combining the recursive validation of keys into NodeFromJSON\n  // to save extra walking of large objects.\n  if (data && typeof data === 'object') {\n    let hasDotValue = false,\n      hasActualChild = false;\n    forEach(data, function(key: string, value: any) {\n      if (key === '.value') {\n        hasDotValue = true;\n      } else if (key !== '.priority' && key !== '.sv') {\n        hasActualChild = true;\n        if (!isValidKey(key)) {\n          throw new Error(\n            errorPrefix +\n              ' contains an invalid key (' +\n              key +\n              ') ' +\n              path.toErrorString() +\n              '.  Keys must be non-empty strings ' +\n              'and can\\'t contain \".\", \"#\", \"$\", \"/\", \"[\", or \"]\"'\n          );\n        }\n      }\n\n      path.push(key);\n      validateFirebaseData(errorPrefix, value, path);\n      path.pop();\n    });\n\n    if (hasDotValue && hasActualChild) {\n      throw new Error(\n        errorPrefix +\n          ' contains \".value\" child ' +\n          path.toErrorString() +\n          ' in addition to actual children.'\n      );\n    }\n  }\n};\n\n/**\n * Pre-validate paths passed in the firebase function.\n *\n * @param {string} errorPrefix\n * @param {Array<!Path>} mergePaths\n */\nexport const validateFirebaseMergePaths = function(\n  errorPrefix: string,\n  mergePaths: Path[]\n) {\n  let i, curPath;\n  for (i = 0; i < mergePaths.length; i++) {\n    curPath = mergePaths[i];\n    const keys = curPath.slice();\n    for (let j = 0; j < keys.length; j++) {\n      if (keys[j] === '.priority' && j === keys.length - 1) {\n        // .priority is OK\n      } else if (!isValidKey(keys[j])) {\n        throw new Error(\n          errorPrefix +\n            'contains an invalid key (' +\n            keys[j] +\n            ') in path ' +\n            curPath.toString() +\n            '. Keys must be non-empty strings ' +\n            'and can\\'t contain \".\", \"#\", \"$\", \"/\", \"[\", or \"]\"'\n        );\n      }\n    }\n  }\n\n  // Check that update keys are not descendants of each other.\n  // We rely on the property that sorting guarantees that ancestors come\n  // right before descendants.\n  mergePaths.sort(Path.comparePaths);\n  let prevPath: Path | null = null;\n  for (i = 0; i < mergePaths.length; i++) {\n    curPath = mergePaths[i];\n    if (prevPath !== null && prevPath.contains(curPath)) {\n      throw new Error(\n        errorPrefix +\n          'contains a path ' +\n          prevPath.toString() +\n          ' that is ancestor of another path ' +\n          curPath.toString()\n      );\n    }\n    prevPath = curPath;\n  }\n};\n\n/**\n * pre-validate an object passed as an argument to firebase function (\n * must be an object - e.g. for firebase.update()).\n *\n * @param {string} fnName\n * @param {number} argumentNumber\n * @param {*} data\n * @param {!Path} path\n * @param {boolean} optional\n */\nexport const validateFirebaseMergeDataArg = function(\n  fnName: string,\n  argumentNumber: number,\n  data: any,\n  path: Path,\n  optional: boolean\n) {\n  if (optional && data === undefined) return;\n\n  const errorPrefix = errorPrefixFxn(fnName, argumentNumber, optional);\n\n  if (!(data && typeof data === 'object') || Array.isArray(data)) {\n    throw new Error(\n      errorPrefix + ' must be an object containing the children to replace.'\n    );\n  }\n\n  const mergePaths: Path[] = [];\n  forEach(data, function(key: string, value: any) {\n    const curPath = new Path(key);\n    validateFirebaseData(errorPrefix, value, path.child(curPath));\n    if (curPath.getBack() === '.priority') {\n      if (!isValidPriority(value)) {\n        throw new Error(\n          errorPrefix +\n            \"contains an invalid value for '\" +\n            curPath.toString() +\n            \"', which must be a valid \" +\n            'Firebase priority (a string, finite number, server value, or null).'\n        );\n      }\n    }\n    mergePaths.push(curPath);\n  });\n  validateFirebaseMergePaths(errorPrefix, mergePaths);\n};\n\nexport const validatePriority = function(\n  fnName: string,\n  argumentNumber: number,\n  priority: any,\n  optional: boolean\n) {\n  if (optional && priority === undefined) return;\n  if (isInvalidJSONNumber(priority))\n    throw new Error(\n      errorPrefixFxn(fnName, argumentNumber, optional) +\n        'is ' +\n        priority.toString() +\n        ', but must be a valid Firebase priority (a string, finite number, ' +\n        'server value, or null).'\n    );\n  // Special case to allow importing data with a .sv.\n  if (!isValidPriority(priority))\n    throw new Error(\n      errorPrefixFxn(fnName, argumentNumber, optional) +\n        'must be a valid Firebase priority ' +\n        '(a string, finite number, server value, or null).'\n    );\n};\n\nexport const validateEventType = function(\n  fnName: string,\n  argumentNumber: number,\n  eventType: string,\n  optional: boolean\n) {\n  if (optional && eventType === undefined) return;\n\n  switch (eventType) {\n    case 'value':\n    case 'child_added':\n    case 'child_removed':\n    case 'child_changed':\n    case 'child_moved':\n      break;\n    default:\n      throw new Error(\n        errorPrefixFxn(fnName, argumentNumber, optional) +\n          'must be a valid event type = \"value\", \"child_added\", \"child_removed\", ' +\n          '\"child_changed\", or \"child_moved\".'\n      );\n  }\n};\n\nexport const validateKey = function(\n  fnName: string,\n  argumentNumber: number,\n  key: string,\n  optional: boolean\n) {\n  if (optional && key === undefined) return;\n  if (!isValidKey(key))\n    throw new Error(\n      errorPrefixFxn(fnName, argumentNumber, optional) +\n        'was an invalid key = \"' +\n        key +\n        '\".  Firebase keys must be non-empty strings and ' +\n        'can\\'t contain \".\", \"#\", \"$\", \"/\", \"[\", or \"]\").'\n    );\n};\n\nexport const validatePathString = function(\n  fnName: string,\n  argumentNumber: number,\n  pathString: string,\n  optional: boolean\n) {\n  if (optional && pathString === undefined) return;\n\n  if (!isValidPathString(pathString))\n    throw new Error(\n      errorPrefixFxn(fnName, argumentNumber, optional) +\n        'was an invalid path = \"' +\n        pathString +\n        '\". Paths must be non-empty strings and ' +\n        'can\\'t contain \".\", \"#\", \"$\", \"[\", or \"]\"'\n    );\n};\n\nexport const validateRootPathString = function(\n  fnName: string,\n  argumentNumber: number,\n  pathString: string,\n  optional: boolean\n) {\n  if (pathString) {\n    // Allow '/.info/' at the beginning.\n    pathString = pathString.replace(/^\\/*\\.info(\\/|$)/, '/');\n  }\n\n  validatePathString(fnName, argumentNumber, pathString, optional);\n};\n\nexport const validateWritablePath = function(fnName: string, path: Path) {\n  if (path.getFront() === '.info') {\n    throw new Error(fnName + \" failed = Can't modify data under /.info/\");\n  }\n};\n\nexport const validateUrl = function(\n  fnName: string,\n  argumentNumber: number,\n  parsedUrl: { repoInfo: RepoInfo; path: Path }\n) {\n  // TODO = Validate server better.\n  const pathString = parsedUrl.path.toString();\n  if (\n    !(typeof parsedUrl.repoInfo.host === 'string') ||\n    parsedUrl.repoInfo.host.length === 0 ||\n    !isValidKey(parsedUrl.repoInfo.namespace) ||\n    (pathString.length !== 0 && !isValidRootPathString(pathString))\n  ) {\n    throw new Error(\n      errorPrefixFxn(fnName, argumentNumber, false) +\n        'must be a valid firebase URL and ' +\n        'the path can\\'t contain \".\", \"#\", \"$\", \"[\", or \"]\".'\n    );\n  }\n};\n\nexport const validateCredential = function(\n  fnName: string,\n  argumentNumber: number,\n  cred: any,\n  optional: boolean\n) {\n  if (optional && cred === undefined) return;\n  if (!(typeof cred === 'string'))\n    throw new Error(\n      errorPrefixFxn(fnName, argumentNumber, optional) +\n        'must be a valid credential (a string).'\n    );\n};\n\nexport const validateBoolean = function(\n  fnName: string,\n  argumentNumber: number,\n  bool: any,\n  optional: boolean\n) {\n  if (optional && bool === undefined) return;\n  if (typeof bool !== 'boolean')\n    throw new Error(\n      errorPrefixFxn(fnName, argumentNumber, optional) + 'must be a boolean.'\n    );\n};\n\nexport const validateString = function(\n  fnName: string,\n  argumentNumber: number,\n  string: any,\n  optional: boolean\n) {\n  if (optional && string === undefined) return;\n  if (!(typeof string === 'string')) {\n    throw new Error(\n      errorPrefixFxn(fnName, argumentNumber, optional) +\n        'must be a valid string.'\n    );\n  }\n};\n\nexport const validateObject = function(\n  fnName: string,\n  argumentNumber: number,\n  obj: any,\n  optional: boolean\n) {\n  if (optional && obj === undefined) return;\n  if (!(obj && typeof obj === 'object') || obj === null) {\n    throw new Error(\n      errorPrefixFxn(fnName, argumentNumber, optional) +\n        'must be a valid object.'\n    );\n  }\n};\n\nexport const validateObjectContainsKey = function(\n  fnName: string,\n  argumentNumber: number,\n  obj: any,\n  key: string,\n  optional: boolean,\n  opt_type?: string\n) {\n  const objectContainsKey =\n    obj && typeof obj === 'object' && contains(obj, key);\n\n  if (!objectContainsKey) {\n    if (optional) {\n      return;\n    } else {\n      throw new Error(\n        errorPrefixFxn(fnName, argumentNumber, optional) +\n          'must contain the key \"' +\n          key +\n          '\"'\n      );\n    }\n  }\n\n  if (opt_type) {\n    const val = safeGet(obj, key);\n    if (\n      (opt_type === 'number' && !(typeof val === 'number')) ||\n      (opt_type === 'string' && !(typeof val === 'string')) ||\n      (opt_type === 'boolean' && !(typeof val === 'boolean')) ||\n      (opt_type === 'function' && !(typeof val === 'function')) ||\n      (opt_type === 'object' && !(typeof val === 'object') && val)\n    ) {\n      if (optional) {\n        throw new Error(\n          errorPrefixFxn(fnName, argumentNumber, optional) +\n            'contains invalid value for key \"' +\n            key +\n            '\" (must be of type \"' +\n            opt_type +\n            '\")'\n        );\n      } else {\n        throw new Error(\n          errorPrefixFxn(fnName, argumentNumber, optional) +\n            'must contain the key \"' +\n            key +\n            '\" with type \"' +\n            opt_type +\n            '\"'\n        );\n      }\n    }\n  }\n};\n"]}