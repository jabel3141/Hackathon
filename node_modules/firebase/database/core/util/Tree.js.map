{"version":3,"sources":["database/src/database/core/util/Tree.ts","database/core/util/Tree.js"],"names":["TreeNode","children","childCount","value","Tree","name_","parent_","node_","prototype","subTree","pathObj","path","child","next","getFront","childNode","popFront","getValue","setValue","updateParents_","clear","hasChildren","isEmpty","forEachChild","action","_this","childTree","forEachDescendant","includeSelf","childrenFirst","forEachAncestor","node","parent","forEachImmediateDescendantWithValue","name","updateChild_","childName","childEmpty","childExists"],"mappings":"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","file":"Tree.js","sourcesContent":["/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\nimport { assert } from '../../../utils/assert';\nimport { Path } from './Path';\nimport { forEach, contains, safeGet } from '../../../utils/obj';\n\n/**\n * Node in a Tree.\n */\nexport class TreeNode<T> {\n  // TODO: Consider making accessors that create children and value lazily or\n  // separate Internal / Leaf 'types'.\n  children: { [name: string]: TreeNode<T> } = {};\n  childCount = 0;\n  value: T | null = null;\n}\n\n/**\n * A light-weight tree, traversable by path.  Nodes can have both values and children.\n * Nodes are not enumerated (by forEachChild) unless they have a value or non-empty\n * children.\n */\nexport class Tree<T> {\n  /**\n   * @template T\n   * @param {string=} name_ Optional name of the node.\n   * @param {Tree=} parent_ Optional parent node.\n   * @param {TreeNode=} node_ Optional node to wrap.\n   */\n  constructor(\n    private name_: string = '',\n    private parent_: Tree<T> | null = null,\n    private node_: TreeNode<T> = new TreeNode<T>()\n  ) {}\n\n  /**\n   * Returns a sub-Tree for the given path.\n   *\n   * @param {!(string|Path)} pathObj Path to look up.\n   * @return {!Tree.<T>} Tree for path.\n   */\n  subTree(pathObj: string | Path): Tree<T> {\n    // TODO: Require pathObj to be Path?\n    let path = pathObj instanceof Path ? pathObj : new Path(pathObj);\n    let child = this as any,\n      next;\n    while ((next = path.getFront()) !== null) {\n      const childNode = safeGet(child.node_.children, next) || new TreeNode();\n      child = new Tree(next, child, childNode);\n      path = path.popFront();\n    }\n\n    return child;\n  }\n\n  /**\n   * Returns the data associated with this tree node.\n   *\n   * @return {?T} The data or null if no data exists.\n   */\n  getValue(): T | null {\n    return this.node_.value;\n  }\n\n  /**\n   * Sets data to this tree node.\n   *\n   * @param {!T} value Value to set.\n   */\n  setValue(value: T) {\n    assert(typeof value !== 'undefined', 'Cannot set value to undefined');\n    this.node_.value = value;\n    this.updateParents_();\n  }\n\n  /**\n   * Clears the contents of the tree node (its value and all children).\n   */\n  clear() {\n    this.node_.value = null;\n    this.node_.children = {};\n    this.node_.childCount = 0;\n    this.updateParents_();\n  }\n\n  /**\n   * @return {boolean} Whether the tree has any children.\n   */\n  hasChildren(): boolean {\n    return this.node_.childCount > 0;\n  }\n\n  /**\n   * @return {boolean} Whether the tree is empty (no value or children).\n   */\n  isEmpty(): boolean {\n    return this.getValue() === null && !this.hasChildren();\n  }\n\n  /**\n   * Calls action for each child of this tree node.\n   *\n   * @param {function(!Tree.<T>)} action Action to be called for each child.\n   */\n  forEachChild(action: (tree: Tree<T>) => void) {\n    forEach(this.node_.children, (child: string, childTree: TreeNode<T>) => {\n      action(new Tree<T>(child, this, childTree));\n    });\n  }\n\n  /**\n   * Does a depth-first traversal of this node's descendants, calling action for each one.\n   *\n   * @param {function(!Tree.<T>)} action Action to be called for each child.\n   * @param {boolean=} includeSelf Whether to call action on this node as well. Defaults to\n   *   false.\n   * @param {boolean=} childrenFirst Whether to call action on children before calling it on\n   *   parent.\n   */\n  forEachDescendant(\n    action: (tree: Tree<T>) => void,\n    includeSelf?: boolean,\n    childrenFirst?: boolean\n  ) {\n    if (includeSelf && !childrenFirst) action(this);\n\n    this.forEachChild(function(child) {\n      child.forEachDescendant(action, /*includeSelf=*/ true, childrenFirst);\n    });\n\n    if (includeSelf && childrenFirst) action(this);\n  }\n\n  /**\n   * Calls action on each ancestor node.\n   *\n   * @param {function(!Tree.<T>)} action Action to be called on each parent; return\n   *   true to abort.\n   * @param {boolean=} includeSelf Whether to call action on this node as well.\n   * @return {boolean} true if the action callback returned true.\n   */\n  forEachAncestor(\n    action: (tree: Tree<T>) => void,\n    includeSelf?: boolean\n  ): boolean {\n    let node = includeSelf ? this : this.parent();\n    while (node !== null) {\n      if (action(node)) {\n        return true;\n      }\n      node = node.parent();\n    }\n    return false;\n  }\n\n  /**\n   * Does a depth-first traversal of this node's descendants.  When a descendant with a value\n   * is found, action is called on it and traversal does not continue inside the node.\n   * Action is *not* called on this node.\n   *\n   * @param {function(!Tree.<T>)} action Action to be called for each child.\n   */\n  forEachImmediateDescendantWithValue(action: (tree: Tree<T>) => void) {\n    this.forEachChild(function(child) {\n      if (child.getValue() !== null) action(child);\n      else child.forEachImmediateDescendantWithValue(action);\n    });\n  }\n\n  /**\n   * @return {!Path} The path of this tree node, as a Path.\n   */\n  path(): Path {\n    return new Path(\n      this.parent_ === null\n        ? this.name_\n        : this.parent_.path() + '/' + this.name_\n    );\n  }\n\n  /**\n   * @return {string} The name of the tree node.\n   */\n  name(): string {\n    return this.name_;\n  }\n\n  /**\n   * @return {?Tree} The parent tree node, or null if this is the root of the tree.\n   */\n  parent(): Tree<T> | null {\n    return this.parent_;\n  }\n\n  /**\n   * Adds or removes this child from its parent based on whether it's empty or not.\n   *\n   * @private\n   */\n  private updateParents_() {\n    if (this.parent_ !== null) this.parent_.updateChild_(this.name_, this);\n  }\n\n  /**\n   * Adds or removes the passed child to this tree node, depending on whether it's empty.\n   *\n   * @param {string} childName The name of the child to update.\n   * @param {!Tree.<T>} child The child to update.\n   * @private\n   */\n  private updateChild_(childName: string, child: Tree<T>) {\n    const childEmpty = child.isEmpty();\n    const childExists = contains(this.node_.children, childName);\n    if (childEmpty && childExists) {\n      delete this.node_.children[childName];\n      this.node_.childCount--;\n      this.updateParents_();\n    } else if (!childEmpty && !childExists) {\n      this.node_.children[childName] = child.node_;\n      this.node_.childCount++;\n      this.updateParents_();\n    }\n  }\n}\n","/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\nimport { assert } from '../../../utils/assert';\nimport { Path } from './Path';\nimport { forEach, contains, safeGet } from '../../../utils/obj';\n/**\n * Node in a Tree.\n */\nvar TreeNode = (function () {\n    function TreeNode() {\n        // TODO: Consider making accessors that create children and value lazily or\n        // separate Internal / Leaf 'types'.\n        this.children = {};\n        this.childCount = 0;\n        this.value = null;\n    }\n    return TreeNode;\n}());\nexport { TreeNode };\n/**\n * A light-weight tree, traversable by path.  Nodes can have both values and children.\n * Nodes are not enumerated (by forEachChild) unless they have a value or non-empty\n * children.\n */\nvar Tree = (function () {\n    /**\n     * @template T\n     * @param {string=} name_ Optional name of the node.\n     * @param {Tree=} parent_ Optional parent node.\n     * @param {TreeNode=} node_ Optional node to wrap.\n     */\n    function Tree(name_, parent_, node_) {\n        if (name_ === void 0) { name_ = ''; }\n        if (parent_ === void 0) { parent_ = null; }\n        if (node_ === void 0) { node_ = new TreeNode(); }\n        this.name_ = name_;\n        this.parent_ = parent_;\n        this.node_ = node_;\n    }\n    /**\n     * Returns a sub-Tree for the given path.\n     *\n     * @param {!(string|Path)} pathObj Path to look up.\n     * @return {!Tree.<T>} Tree for path.\n     */\n    Tree.prototype.subTree = function (pathObj) {\n        // TODO: Require pathObj to be Path?\n        var path = pathObj instanceof Path ? pathObj : new Path(pathObj);\n        var child = this, next;\n        while ((next = path.getFront()) !== null) {\n            var childNode = safeGet(child.node_.children, next) || new TreeNode();\n            child = new Tree(next, child, childNode);\n            path = path.popFront();\n        }\n        return child;\n    };\n    /**\n     * Returns the data associated with this tree node.\n     *\n     * @return {?T} The data or null if no data exists.\n     */\n    Tree.prototype.getValue = function () {\n        return this.node_.value;\n    };\n    /**\n     * Sets data to this tree node.\n     *\n     * @param {!T} value Value to set.\n     */\n    Tree.prototype.setValue = function (value) {\n        assert(typeof value !== 'undefined', 'Cannot set value to undefined');\n        this.node_.value = value;\n        this.updateParents_();\n    };\n    /**\n     * Clears the contents of the tree node (its value and all children).\n     */\n    Tree.prototype.clear = function () {\n        this.node_.value = null;\n        this.node_.children = {};\n        this.node_.childCount = 0;\n        this.updateParents_();\n    };\n    /**\n     * @return {boolean} Whether the tree has any children.\n     */\n    Tree.prototype.hasChildren = function () {\n        return this.node_.childCount > 0;\n    };\n    /**\n     * @return {boolean} Whether the tree is empty (no value or children).\n     */\n    Tree.prototype.isEmpty = function () {\n        return this.getValue() === null && !this.hasChildren();\n    };\n    /**\n     * Calls action for each child of this tree node.\n     *\n     * @param {function(!Tree.<T>)} action Action to be called for each child.\n     */\n    Tree.prototype.forEachChild = function (action) {\n        var _this = this;\n        forEach(this.node_.children, function (child, childTree) {\n            action(new Tree(child, _this, childTree));\n        });\n    };\n    /**\n     * Does a depth-first traversal of this node's descendants, calling action for each one.\n     *\n     * @param {function(!Tree.<T>)} action Action to be called for each child.\n     * @param {boolean=} includeSelf Whether to call action on this node as well. Defaults to\n     *   false.\n     * @param {boolean=} childrenFirst Whether to call action on children before calling it on\n     *   parent.\n     */\n    Tree.prototype.forEachDescendant = function (action, includeSelf, childrenFirst) {\n        if (includeSelf && !childrenFirst)\n            action(this);\n        this.forEachChild(function (child) {\n            child.forEachDescendant(action, /*includeSelf=*/ true, childrenFirst);\n        });\n        if (includeSelf && childrenFirst)\n            action(this);\n    };\n    /**\n     * Calls action on each ancestor node.\n     *\n     * @param {function(!Tree.<T>)} action Action to be called on each parent; return\n     *   true to abort.\n     * @param {boolean=} includeSelf Whether to call action on this node as well.\n     * @return {boolean} true if the action callback returned true.\n     */\n    Tree.prototype.forEachAncestor = function (action, includeSelf) {\n        var node = includeSelf ? this : this.parent();\n        while (node !== null) {\n            if (action(node)) {\n                return true;\n            }\n            node = node.parent();\n        }\n        return false;\n    };\n    /**\n     * Does a depth-first traversal of this node's descendants.  When a descendant with a value\n     * is found, action is called on it and traversal does not continue inside the node.\n     * Action is *not* called on this node.\n     *\n     * @param {function(!Tree.<T>)} action Action to be called for each child.\n     */\n    Tree.prototype.forEachImmediateDescendantWithValue = function (action) {\n        this.forEachChild(function (child) {\n            if (child.getValue() !== null)\n                action(child);\n            else\n                child.forEachImmediateDescendantWithValue(action);\n        });\n    };\n    /**\n     * @return {!Path} The path of this tree node, as a Path.\n     */\n    Tree.prototype.path = function () {\n        return new Path(this.parent_ === null\n            ? this.name_\n            : this.parent_.path() + '/' + this.name_);\n    };\n    /**\n     * @return {string} The name of the tree node.\n     */\n    Tree.prototype.name = function () {\n        return this.name_;\n    };\n    /**\n     * @return {?Tree} The parent tree node, or null if this is the root of the tree.\n     */\n    Tree.prototype.parent = function () {\n        return this.parent_;\n    };\n    /**\n     * Adds or removes this child from its parent based on whether it's empty or not.\n     *\n     * @private\n     */\n    Tree.prototype.updateParents_ = function () {\n        if (this.parent_ !== null)\n            this.parent_.updateChild_(this.name_, this);\n    };\n    /**\n     * Adds or removes the passed child to this tree node, depending on whether it's empty.\n     *\n     * @param {string} childName The name of the child to update.\n     * @param {!Tree.<T>} child The child to update.\n     * @private\n     */\n    Tree.prototype.updateChild_ = function (childName, child) {\n        var childEmpty = child.isEmpty();\n        var childExists = contains(this.node_.children, childName);\n        if (childEmpty && childExists) {\n            delete this.node_.children[childName];\n            this.node_.childCount--;\n            this.updateParents_();\n        }\n        else if (!childEmpty && !childExists) {\n            this.node_.children[childName] = child.node_;\n            this.node_.childCount++;\n            this.updateParents_();\n        }\n    };\n    return Tree;\n}());\nexport { Tree };\n\n\n"]}