{"version":3,"sources":["database/core/src/database/core/util/libs/parser.ts"],"names":["decodePath","pathString","pathStringDecoded","pieces","split","i","length","piece","decodeURIComponent","replace","e","parseRepoInfo","dataURL","parsedUrl","parseURL","namespace","subdomain","domain","host","secure","webSocketOnly","scheme","repoInfo","path","port","colonInd","indexOf","substring","slashInd","parts","toLowerCase","parseInt"],"mappings":"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","file":"parser.js","sourcesContent":["/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\nimport { Path } from '../Path';\nimport { RepoInfo } from '../../RepoInfo';\nimport { warnIfPageIsSecure, fatal } from '../util';\n\n/**\n * @param {!string} pathString\n * @return {string}\n */\nfunction decodePath(pathString: string): string {\n  let pathStringDecoded = '';\n  const pieces = pathString.split('/');\n  for (let i = 0; i < pieces.length; i++) {\n    if (pieces[i].length > 0) {\n      let piece = pieces[i];\n      try {\n        piece = decodeURIComponent(piece.replace(/\\+/g, ' '));\n      } catch (e) {}\n      pathStringDecoded += '/' + piece;\n    }\n  }\n  return pathStringDecoded;\n}\n\n/**\n *\n * @param {!string} dataURL\n * @return {{repoInfo: !RepoInfo, path: !Path}}\n */\nexport const parseRepoInfo = function(\n  dataURL: string\n): { repoInfo: RepoInfo; path: Path } {\n  const parsedUrl = parseURL(dataURL),\n    namespace = parsedUrl.subdomain;\n\n  if (parsedUrl.domain === 'firebase') {\n    fatal(\n      parsedUrl.host +\n        ' is no longer supported. ' +\n        'Please use <YOUR FIREBASE>.firebaseio.com instead'\n    );\n  }\n\n  // Catch common error of uninitialized namespace value.\n  if (!namespace || namespace == 'undefined') {\n    fatal(\n      'Cannot parse Firebase url. Please use https://<YOUR FIREBASE>.firebaseio.com'\n    );\n  }\n\n  if (!parsedUrl.secure) {\n    warnIfPageIsSecure();\n  }\n\n  const webSocketOnly = parsedUrl.scheme === 'ws' || parsedUrl.scheme === 'wss';\n\n  return {\n    repoInfo: new RepoInfo(\n      parsedUrl.host,\n      parsedUrl.secure,\n      namespace,\n      webSocketOnly\n    ),\n    path: new Path(parsedUrl.pathString)\n  };\n};\n\n/**\n *\n * @param {!string} dataURL\n * @return {{host: string, port: number, domain: string, subdomain: string, secure: boolean, scheme: string, pathString: string}}\n */\nexport const parseURL = function(\n  dataURL: string\n): {\n  host: string;\n  port: number;\n  domain: string;\n  subdomain: string;\n  secure: boolean;\n  scheme: string;\n  pathString: string;\n} {\n  // Default to empty strings in the event of a malformed string.\n  let host = '',\n    domain = '',\n    subdomain = '',\n    pathString = '';\n\n  // Always default to SSL, unless otherwise specified.\n  let secure = true,\n    scheme = 'https',\n    port = 443;\n\n  // Don't do any validation here. The caller is responsible for validating the result of parsing.\n  if (typeof dataURL === 'string') {\n    // Parse scheme.\n    let colonInd = dataURL.indexOf('//');\n    if (colonInd >= 0) {\n      scheme = dataURL.substring(0, colonInd - 1);\n      dataURL = dataURL.substring(colonInd + 2);\n    }\n\n    // Parse host and path.\n    let slashInd = dataURL.indexOf('/');\n    if (slashInd === -1) {\n      slashInd = dataURL.length;\n    }\n    host = dataURL.substring(0, slashInd);\n    pathString = decodePath(dataURL.substring(slashInd));\n\n    const parts = host.split('.');\n    if (parts.length === 3) {\n      // Normalize namespaces to lowercase to share storage / connection.\n      domain = parts[1];\n      subdomain = parts[0].toLowerCase();\n    } else if (parts.length === 2) {\n      domain = parts[0];\n    }\n\n    // If we have a port, use scheme for determining if it's secure.\n    colonInd = host.indexOf(':');\n    if (colonInd >= 0) {\n      secure = scheme === 'https' || scheme === 'wss';\n      port = parseInt(host.substring(colonInd + 1), 10);\n    }\n  }\n\n  return {\n    host,\n    port,\n    domain,\n    subdomain,\n    secure,\n    scheme,\n    pathString\n  };\n};\n"]}