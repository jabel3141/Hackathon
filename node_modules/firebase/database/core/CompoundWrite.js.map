{"version":3,"sources":["src/database/core/CompoundWrite.ts"],"names":["CompoundWrite","writeTree_","prototype","addWrite","path","node","isEmpty","rootmost","findRootMostValueAndPath","rootMostPath","value","relativePath","updateChild","set","subtree","newWriteTree","setTree","addWrites","updates","newWrite","childKey","child","removeWrite","Empty","hasCompleteWrite","getCompleteNode","get","getChild","getCompleteChildren","children","isLeafNode","forEachChild","childName","childNode","push","inorderTraversal","childTree","childCompoundWrite","shadowingNode","apply","applySubtreeWrite_","writeTree","priorityWrite_1"],"mappings":"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","file":"CompoundWrite.js","sourcesContent":["/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\nimport { ImmutableTree } from './util/ImmutableTree';\nimport { Path } from './util/Path';\nimport { forEach } from '../../utils/obj';\nimport { Node, NamedNode } from './snap/Node';\nimport { PRIORITY_INDEX } from './snap/indexes/PriorityIndex';\nimport { assert } from '../../utils/assert';\nimport { ChildrenNode } from './snap/ChildrenNode';\n\n/**\n * This class holds a collection of writes that can be applied to nodes in unison. It abstracts away the logic with\n * dealing with priority writes and multiple nested writes. At any given path there is only allowed to be one write\n * modifying that path. Any write to an existing path or shadowing an existing path will modify that existing write\n * to reflect the write added.\n *\n * @constructor\n * @param {!ImmutableTree.<!Node>} writeTree\n */\nexport class CompoundWrite {\n  constructor(private writeTree_: ImmutableTree<Node>) {}\n  /**\n   * @type {!CompoundWrite}\n   */\n  static Empty = new CompoundWrite(new ImmutableTree(null));\n\n  /**\n   * @param {!Path} path\n   * @param {!Node} node\n   * @return {!CompoundWrite}\n   */\n  addWrite(path: Path, node: Node): CompoundWrite {\n    if (path.isEmpty()) {\n      return new CompoundWrite(new ImmutableTree(node));\n    } else {\n      const rootmost = this.writeTree_.findRootMostValueAndPath(path);\n      if (rootmost != null) {\n        const rootMostPath = rootmost.path;\n        let value = rootmost.value;\n        const relativePath = Path.relativePath(rootMostPath, path);\n        value = value.updateChild(relativePath, node);\n        return new CompoundWrite(this.writeTree_.set(rootMostPath, value));\n      } else {\n        const subtree = new ImmutableTree(node);\n        const newWriteTree = this.writeTree_.setTree(path, subtree);\n        return new CompoundWrite(newWriteTree);\n      }\n    }\n  }\n\n  /**\n   * @param {!Path} path\n   * @param {!Object.<string, !Node>} updates\n   * @return {!CompoundWrite}\n   */\n  addWrites(path: Path, updates: { [name: string]: Node }): CompoundWrite {\n    let newWrite = this as CompoundWrite;\n    forEach(updates, function(childKey: string, node: Node) {\n      newWrite = newWrite.addWrite(path.child(childKey), node);\n    });\n    return newWrite;\n  }\n\n  /**\n   * Will remove a write at the given path and deeper paths. This will <em>not</em> modify a write at a higher\n   * location, which must be removed by calling this method with that path.\n   *\n   * @param {!Path} path The path at which a write and all deeper writes should be removed\n   * @return {!CompoundWrite} The new CompoundWrite with the removed path\n   */\n  removeWrite(path: Path): CompoundWrite {\n    if (path.isEmpty()) {\n      return CompoundWrite.Empty;\n    } else {\n      const newWriteTree = this.writeTree_.setTree(path, ImmutableTree.Empty);\n      return new CompoundWrite(newWriteTree);\n    }\n  }\n\n  /**\n   * Returns whether this CompoundWrite will fully overwrite a node at a given location and can therefore be\n   * considered \"complete\".\n   *\n   * @param {!Path} path The path to check for\n   * @return {boolean} Whether there is a complete write at that path\n   */\n  hasCompleteWrite(path: Path): boolean {\n    return this.getCompleteNode(path) != null;\n  }\n\n  /**\n   * Returns a node for a path if and only if the node is a \"complete\" overwrite at that path. This will not aggregate\n   * writes from deeper paths, but will return child nodes from a more shallow path.\n   *\n   * @param {!Path} path The path to get a complete write\n   * @return {?Node} The node if complete at that path, or null otherwise.\n   */\n  getCompleteNode(path: Path): Node | null {\n    const rootmost = this.writeTree_.findRootMostValueAndPath(path);\n    if (rootmost != null) {\n      return this.writeTree_\n        .get(rootmost.path)\n        .getChild(Path.relativePath(rootmost.path, path));\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * Returns all children that are guaranteed to be a complete overwrite.\n   *\n   * @return {!Array.<NamedNode>} A list of all complete children.\n   */\n  getCompleteChildren(): Array<NamedNode> {\n    const children: NamedNode[] = [];\n    let node = this.writeTree_.value;\n    if (node != null) {\n      // If it's a leaf node, it has no children; so nothing to do.\n      if (!node.isLeafNode()) {\n        (node as ChildrenNode).forEachChild(PRIORITY_INDEX, function(\n          childName,\n          childNode\n        ) {\n          children.push(new NamedNode(childName, childNode));\n        });\n      }\n    } else {\n      this.writeTree_.children.inorderTraversal(function(childName, childTree) {\n        if (childTree.value != null) {\n          children.push(new NamedNode(childName, childTree.value));\n        }\n      });\n    }\n    return children;\n  }\n\n  /**\n   * @param {!Path} path\n   * @return {!CompoundWrite}\n   */\n  childCompoundWrite(path: Path): CompoundWrite {\n    if (path.isEmpty()) {\n      return this;\n    } else {\n      const shadowingNode = this.getCompleteNode(path);\n      if (shadowingNode != null) {\n        return new CompoundWrite(new ImmutableTree(shadowingNode));\n      } else {\n        return new CompoundWrite(this.writeTree_.subtree(path));\n      }\n    }\n  }\n\n  /**\n   * Returns true if this CompoundWrite is empty and therefore does not modify any nodes.\n   * @return {boolean} Whether this CompoundWrite is empty\n   */\n  isEmpty(): boolean {\n    return this.writeTree_.isEmpty();\n  }\n\n  /**\n   * Applies this CompoundWrite to a node. The node is returned with all writes from this CompoundWrite applied to the\n   * node\n   * @param {!Node} node The node to apply this CompoundWrite to\n   * @return {!Node} The node with all writes applied\n   */\n  apply(node: Node): Node {\n    return CompoundWrite.applySubtreeWrite_(Path.Empty, this.writeTree_, node);\n  }\n\n  /**\n   * @param {!Path} relativePath\n   * @param {!ImmutableTree.<!Node>} writeTree\n   * @param {!Node} node\n   * @return {!Node}\n   * @private\n   */\n  private static applySubtreeWrite_ = function(\n    relativePath: Path,\n    writeTree: ImmutableTree<Node>,\n    node: Node\n  ): Node {\n    if (writeTree.value != null) {\n      // Since there a write is always a leaf, we're done here\n      return node.updateChild(relativePath, writeTree.value);\n    } else {\n      let priorityWrite = null;\n      writeTree.children.inorderTraversal(function(childKey, childTree) {\n        if (childKey === '.priority') {\n          // Apply priorities at the end so we don't update priorities for either empty nodes or forget\n          // to apply priorities to empty nodes that are later filled\n          assert(\n            childTree.value !== null,\n            'Priority writes must always be leaf nodes'\n          );\n          priorityWrite = childTree.value;\n        } else {\n          node = CompoundWrite.applySubtreeWrite_(\n            relativePath.child(childKey),\n            childTree,\n            node\n          );\n        }\n      });\n      // If there was a priority write, we only apply it if the node is not empty\n      if (!node.getChild(relativePath).isEmpty() && priorityWrite !== null) {\n        node = node.updateChild(relativePath.child('.priority'), priorityWrite);\n      }\n      return node;\n    }\n  };\n}\n"]}