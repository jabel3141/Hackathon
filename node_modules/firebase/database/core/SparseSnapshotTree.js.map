{"version":3,"sources":["src/database/core/SparseSnapshotTree.ts","database/core/SparseSnapshotTree.js"],"names":["SparseSnapshotTree","value_","children_","prototype","find","path","getChild","isEmpty","childKey","getFront","popFront","contains","childTree","get","remember","data","updateChild","add","child","forget","isLeafNode","value","self_1","forEachChild","key","tree","safeToRemove","remove","forEachTree","prefixPath","func","toString","each"],"mappings":"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","file":"SparseSnapshotTree.js","sourcesContent":["/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\nimport { Path } from './util/Path';\nimport { PRIORITY_INDEX } from './snap/indexes/PriorityIndex';\nimport { CountedSet } from './util/CountedSet';\nimport { Node } from './snap/Node';\n\n/**\n * Helper class to store a sparse set of snapshots.\n *\n * @constructor\n */\nexport class SparseSnapshotTree {\n  /**\n   * @private\n   * @type {Node}\n   */\n  private value_: Node | null = null;\n\n  /**\n   * @private\n   * @type {CountedSet}\n   */\n  private children_: CountedSet<string, SparseSnapshotTree> | null = null;\n\n  /**\n   * Gets the node stored at the given path if one exists.\n   *\n   * @param {!Path} path Path to look up snapshot for.\n   * @return {?Node} The retrieved node, or null.\n   */\n  find(path: Path): Node | null {\n    if (this.value_ != null) {\n      return this.value_.getChild(path);\n    } else if (!path.isEmpty() && this.children_ != null) {\n      const childKey = path.getFront();\n      path = path.popFront();\n      if (this.children_.contains(childKey)) {\n        const childTree = this.children_.get(childKey) as SparseSnapshotTree;\n        return childTree.find(path);\n      } else {\n        return null;\n      }\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * Stores the given node at the specified path. If there is already a node\n   * at a shallower path, it merges the new data into that snapshot node.\n   *\n   * @param {!Path} path Path to look up snapshot for.\n   * @param {!Node} data The new data, or null.\n   */\n  remember(path: Path, data: Node) {\n    if (path.isEmpty()) {\n      this.value_ = data;\n      this.children_ = null;\n    } else if (this.value_ !== null) {\n      this.value_ = this.value_.updateChild(path, data);\n    } else {\n      if (this.children_ == null) {\n        this.children_ = new CountedSet<string, SparseSnapshotTree>();\n      }\n\n      const childKey = path.getFront();\n      if (!this.children_.contains(childKey)) {\n        this.children_.add(childKey, new SparseSnapshotTree());\n      }\n\n      const child = this.children_.get(childKey) as SparseSnapshotTree;\n      path = path.popFront();\n      child.remember(path, data);\n    }\n  }\n\n  /**\n   * Purge the data at path from the cache.\n   *\n   * @param {!Path} path Path to look up snapshot for.\n   * @return {boolean} True if this node should now be removed.\n   */\n  forget(path: Path): boolean {\n    if (path.isEmpty()) {\n      this.value_ = null;\n      this.children_ = null;\n      return true;\n    } else {\n      if (this.value_ !== null) {\n        if (this.value_.isLeafNode()) {\n          // We're trying to forget a node that doesn't exist\n          return false;\n        } else {\n          const value = this.value_;\n          this.value_ = null;\n\n          const self = this;\n          value.forEachChild(PRIORITY_INDEX, function(key, tree) {\n            self.remember(new Path(key), tree);\n          });\n\n          return this.forget(path);\n        }\n      } else if (this.children_ !== null) {\n        const childKey = path.getFront();\n        path = path.popFront();\n        if (this.children_.contains(childKey)) {\n          const safeToRemove = (this.children_.get(\n            childKey\n          ) as SparseSnapshotTree).forget(path);\n          if (safeToRemove) {\n            this.children_.remove(childKey);\n          }\n        }\n\n        if (this.children_.isEmpty()) {\n          this.children_ = null;\n          return true;\n        } else {\n          return false;\n        }\n      } else {\n        return true;\n      }\n    }\n  }\n\n  /**\n   * Recursively iterates through all of the stored tree and calls the\n   * callback on each one.\n   *\n   * @param {!Path} prefixPath Path to look up node for.\n   * @param {!Function} func The function to invoke for each tree.\n   */\n  forEachTree(prefixPath: Path, func: (a: Path, b: Node) => any) {\n    if (this.value_ !== null) {\n      func(prefixPath, this.value_);\n    } else {\n      this.forEachChild((key, tree) => {\n        const path = new Path(prefixPath.toString() + '/' + key);\n        tree.forEachTree(path, func);\n      });\n    }\n  }\n\n  /**\n   * Iterates through each immediate child and triggers the callback.\n   *\n   * @param {!Function} func The function to invoke for each child.\n   */\n  forEachChild(func: (a: string, b: SparseSnapshotTree) => void) {\n    if (this.children_ !== null) {\n      this.children_.each((key, tree) => {\n        func(key, tree);\n      });\n    }\n  }\n}\n","/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\nimport { Path } from './util/Path';\nimport { PRIORITY_INDEX } from './snap/indexes/PriorityIndex';\nimport { CountedSet } from './util/CountedSet';\n/**\n * Helper class to store a sparse set of snapshots.\n *\n * @constructor\n */\nvar SparseSnapshotTree = (function () {\n    function SparseSnapshotTree() {\n        /**\n         * @private\n         * @type {Node}\n         */\n        this.value_ = null;\n        /**\n         * @private\n         * @type {CountedSet}\n         */\n        this.children_ = null;\n    }\n    /**\n     * Gets the node stored at the given path if one exists.\n     *\n     * @param {!Path} path Path to look up snapshot for.\n     * @return {?Node} The retrieved node, or null.\n     */\n    SparseSnapshotTree.prototype.find = function (path) {\n        if (this.value_ != null) {\n            return this.value_.getChild(path);\n        }\n        else if (!path.isEmpty() && this.children_ != null) {\n            var childKey = path.getFront();\n            path = path.popFront();\n            if (this.children_.contains(childKey)) {\n                var childTree = this.children_.get(childKey);\n                return childTree.find(path);\n            }\n            else {\n                return null;\n            }\n        }\n        else {\n            return null;\n        }\n    };\n    /**\n     * Stores the given node at the specified path. If there is already a node\n     * at a shallower path, it merges the new data into that snapshot node.\n     *\n     * @param {!Path} path Path to look up snapshot for.\n     * @param {!Node} data The new data, or null.\n     */\n    SparseSnapshotTree.prototype.remember = function (path, data) {\n        if (path.isEmpty()) {\n            this.value_ = data;\n            this.children_ = null;\n        }\n        else if (this.value_ !== null) {\n            this.value_ = this.value_.updateChild(path, data);\n        }\n        else {\n            if (this.children_ == null) {\n                this.children_ = new CountedSet();\n            }\n            var childKey = path.getFront();\n            if (!this.children_.contains(childKey)) {\n                this.children_.add(childKey, new SparseSnapshotTree());\n            }\n            var child = this.children_.get(childKey);\n            path = path.popFront();\n            child.remember(path, data);\n        }\n    };\n    /**\n     * Purge the data at path from the cache.\n     *\n     * @param {!Path} path Path to look up snapshot for.\n     * @return {boolean} True if this node should now be removed.\n     */\n    SparseSnapshotTree.prototype.forget = function (path) {\n        if (path.isEmpty()) {\n            this.value_ = null;\n            this.children_ = null;\n            return true;\n        }\n        else {\n            if (this.value_ !== null) {\n                if (this.value_.isLeafNode()) {\n                    // We're trying to forget a node that doesn't exist\n                    return false;\n                }\n                else {\n                    var value = this.value_;\n                    this.value_ = null;\n                    var self_1 = this;\n                    value.forEachChild(PRIORITY_INDEX, function (key, tree) {\n                        self_1.remember(new Path(key), tree);\n                    });\n                    return this.forget(path);\n                }\n            }\n            else if (this.children_ !== null) {\n                var childKey = path.getFront();\n                path = path.popFront();\n                if (this.children_.contains(childKey)) {\n                    var safeToRemove = this.children_.get(childKey).forget(path);\n                    if (safeToRemove) {\n                        this.children_.remove(childKey);\n                    }\n                }\n                if (this.children_.isEmpty()) {\n                    this.children_ = null;\n                    return true;\n                }\n                else {\n                    return false;\n                }\n            }\n            else {\n                return true;\n            }\n        }\n    };\n    /**\n     * Recursively iterates through all of the stored tree and calls the\n     * callback on each one.\n     *\n     * @param {!Path} prefixPath Path to look up node for.\n     * @param {!Function} func The function to invoke for each tree.\n     */\n    SparseSnapshotTree.prototype.forEachTree = function (prefixPath, func) {\n        if (this.value_ !== null) {\n            func(prefixPath, this.value_);\n        }\n        else {\n            this.forEachChild(function (key, tree) {\n                var path = new Path(prefixPath.toString() + '/' + key);\n                tree.forEachTree(path, func);\n            });\n        }\n    };\n    /**\n     * Iterates through each immediate child and triggers the callback.\n     *\n     * @param {!Function} func The function to invoke for each child.\n     */\n    SparseSnapshotTree.prototype.forEachChild = function (func) {\n        if (this.children_ !== null) {\n            this.children_.each(function (key, tree) {\n                func(key, tree);\n            });\n        }\n    };\n    return SparseSnapshotTree;\n}());\nexport { SparseSnapshotTree };\n\n\n"]}