{"version":3,"sources":["src/database/core/ReadonlyRestClient.ts","database/core/ReadonlyRestClient.js"],"names":["__extends","extendStatics","Object","setPrototypeOf","__proto__","Array","d","b","p","hasOwnProperty","__","constructor","prototype","create","ReadonlyRestClient","_super","repoInfo_","onDataUpdate_","authTokenProvider_","_this","call","log_","listens_","reportStats","stats","Error","getListenId_","query","tag","undefined","getQueryParams","isDefault","path","toString","listen","currentHashFn","onComplete","pathString","queryIdentifier","listenId","thisListen","queryStringParamaters","toRestQueryStringParameters","restRequest_","error","result","data","status_1","unlisten","refreshAuthToken","token","queryStringParameters","callback","getToken","then","authTokenData","authToken","accessToken","url","secure","host","xhr","XMLHttpRequest","onreadystatechange","readyState","status","responseText","res","e","open","send"],"mappings":"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","file":"ReadonlyRestClient.js","sourcesContent":["/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\nimport { assert } from '../../utils/assert';\nimport { logWrapper, warn } from './util/util';\nimport { jsonEval } from '../../utils/json';\nimport { safeGet } from '../../utils/obj';\nimport { querystring } from '../../utils/util';\nimport { ServerActions } from './ServerActions';\nimport { RepoInfo } from './RepoInfo';\nimport { AuthTokenProvider } from './AuthTokenProvider';\nimport { Query } from '../api/Query';\n\n/**\n * An implementation of ServerActions that communicates with the server via REST requests.\n * This is mostly useful for compatibility with crawlers, where we don't want to spin up a full\n * persistent connection (using WebSockets or long-polling)\n */\nexport class ReadonlyRestClient extends ServerActions {\n  reportStats(stats: { [k: string]: any }): void {\n    throw new Error('Method not implemented.');\n  }\n\n  /** @private {function(...[*])} */\n  private log_: (...args: any[]) => void = logWrapper('p:rest:');\n\n  /**\n   * We don't actually need to track listens, except to prevent us calling an onComplete for a listen\n   * that's been removed. :-/\n   *\n   * @private {!Object.<string, !Object>}\n   */\n  private listens_: { [k: string]: Object } = {};\n\n  /**\n   * @param {!Query} query\n   * @param {?number=} tag\n   * @return {string}\n   * @private\n   */\n  static getListenId_(query: Query, tag?: number | null): string {\n    if (tag !== undefined) {\n      return 'tag$' + tag;\n    } else {\n      assert(\n        query.getQueryParams().isDefault(),\n        \"should have a tag if it's not a default query.\"\n      );\n      return query.path.toString();\n    }\n  }\n\n  /**\n   * @param {!RepoInfo} repoInfo_ Data about the namespace we are connecting to\n   * @param {function(string, *, boolean, ?number)} onDataUpdate_ A callback for new data from the server\n   * @param {AuthTokenProvider} authTokenProvider_\n   * @implements {ServerActions}\n   */\n  constructor(\n    private repoInfo_: RepoInfo,\n    private onDataUpdate_: (\n      a: string,\n      b: any,\n      c: boolean,\n      d: number | null\n    ) => void,\n    private authTokenProvider_: AuthTokenProvider\n  ) {\n    super();\n  }\n\n  /** @inheritDoc */\n  listen(\n    query: Query,\n    currentHashFn: () => string,\n    tag: number | null,\n    onComplete: (a: string, b: any) => void\n  ) {\n    const pathString = query.path.toString();\n    this.log_(\n      'Listen called for ' + pathString + ' ' + query.queryIdentifier()\n    );\n\n    // Mark this listener so we can tell if it's removed.\n    const listenId = ReadonlyRestClient.getListenId_(query, tag);\n    const thisListen = {};\n    this.listens_[listenId] = thisListen;\n\n    const queryStringParamaters = query\n      .getQueryParams()\n      .toRestQueryStringParameters();\n\n    this.restRequest_(\n      pathString + '.json',\n      queryStringParamaters,\n      (error, result) => {\n        let data = result;\n\n        if (error === 404) {\n          data = null;\n          error = null;\n        }\n\n        if (error === null) {\n          this.onDataUpdate_(pathString, data, /*isMerge=*/ false, tag);\n        }\n\n        if (safeGet(this.listens_, listenId) === thisListen) {\n          let status;\n          if (!error) {\n            status = 'ok';\n          } else if (error == 401) {\n            status = 'permission_denied';\n          } else {\n            status = 'rest_error:' + error;\n          }\n\n          onComplete(status, null);\n        }\n      }\n    );\n  }\n\n  /** @inheritDoc */\n  unlisten(query: Query, tag: number | null) {\n    const listenId = ReadonlyRestClient.getListenId_(query, tag);\n    delete this.listens_[listenId];\n  }\n\n  /** @inheritDoc */\n  refreshAuthToken(token: string) {\n    // no-op since we just always call getToken.\n  }\n\n  /**\n   * Performs a REST request to the given path, with the provided query string parameters,\n   * and any auth credentials we have.\n   *\n   * @param {!string} pathString\n   * @param {!Object.<string, *>} queryStringParameters\n   * @param {?function(?number, *=)} callback\n   * @private\n   */\n  private restRequest_(\n    pathString: string,\n    queryStringParameters: { [k: string]: any } = {},\n    callback: ((a: number | null, b?: any) => void) | null\n  ) {\n    queryStringParameters['format'] = 'export';\n\n    this.authTokenProvider_\n      .getToken(/*forceRefresh=*/ false)\n      .then(authTokenData => {\n        const authToken = authTokenData && authTokenData.accessToken;\n        if (authToken) {\n          queryStringParameters['auth'] = authToken;\n        }\n\n        const url =\n          (this.repoInfo_.secure ? 'https://' : 'http://') +\n          this.repoInfo_.host +\n          pathString +\n          '?' +\n          querystring(queryStringParameters);\n\n        this.log_('Sending REST request for ' + url);\n        const xhr = new XMLHttpRequest();\n        xhr.onreadystatechange = () => {\n          if (callback && xhr.readyState === 4) {\n            this.log_(\n              'REST Response for ' + url + ' received. status:',\n              xhr.status,\n              'response:',\n              xhr.responseText\n            );\n            let res = null;\n            if (xhr.status >= 200 && xhr.status < 300) {\n              try {\n                res = jsonEval(xhr.responseText);\n              } catch (e) {\n                warn(\n                  'Failed to parse JSON response for ' +\n                    url +\n                    ': ' +\n                    xhr.responseText\n                );\n              }\n              callback(null, res);\n            } else {\n              // 401 and 404 are expected.\n              if (xhr.status !== 401 && xhr.status !== 404) {\n                warn(\n                  'Got unsuccessful REST response for ' +\n                    url +\n                    ' Status: ' +\n                    xhr.status\n                );\n              }\n              callback(xhr.status);\n            }\n            callback = null;\n          }\n        };\n\n        xhr.open('GET', url, /*asynchronous=*/ true);\n        xhr.send();\n      });\n  }\n}\n","/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { assert } from '../../utils/assert';\nimport { logWrapper, warn } from './util/util';\nimport { jsonEval } from '../../utils/json';\nimport { safeGet } from '../../utils/obj';\nimport { querystring } from '../../utils/util';\nimport { ServerActions } from './ServerActions';\n/**\n * An implementation of ServerActions that communicates with the server via REST requests.\n * This is mostly useful for compatibility with crawlers, where we don't want to spin up a full\n * persistent connection (using WebSockets or long-polling)\n */\nvar ReadonlyRestClient = (function (_super) {\n    __extends(ReadonlyRestClient, _super);\n    /**\n     * @param {!RepoInfo} repoInfo_ Data about the namespace we are connecting to\n     * @param {function(string, *, boolean, ?number)} onDataUpdate_ A callback for new data from the server\n     * @param {AuthTokenProvider} authTokenProvider_\n     * @implements {ServerActions}\n     */\n    function ReadonlyRestClient(repoInfo_, onDataUpdate_, authTokenProvider_) {\n        var _this = _super.call(this) || this;\n        _this.repoInfo_ = repoInfo_;\n        _this.onDataUpdate_ = onDataUpdate_;\n        _this.authTokenProvider_ = authTokenProvider_;\n        /** @private {function(...[*])} */\n        _this.log_ = logWrapper('p:rest:');\n        /**\n         * We don't actually need to track listens, except to prevent us calling an onComplete for a listen\n         * that's been removed. :-/\n         *\n         * @private {!Object.<string, !Object>}\n         */\n        _this.listens_ = {};\n        return _this;\n    }\n    ReadonlyRestClient.prototype.reportStats = function (stats) {\n        throw new Error('Method not implemented.');\n    };\n    /**\n     * @param {!Query} query\n     * @param {?number=} tag\n     * @return {string}\n     * @private\n     */\n    ReadonlyRestClient.getListenId_ = function (query, tag) {\n        if (tag !== undefined) {\n            return 'tag$' + tag;\n        }\n        else {\n            assert(query.getQueryParams().isDefault(), \"should have a tag if it's not a default query.\");\n            return query.path.toString();\n        }\n    };\n    /** @inheritDoc */\n    ReadonlyRestClient.prototype.listen = function (query, currentHashFn, tag, onComplete) {\n        var _this = this;\n        var pathString = query.path.toString();\n        this.log_('Listen called for ' + pathString + ' ' + query.queryIdentifier());\n        // Mark this listener so we can tell if it's removed.\n        var listenId = ReadonlyRestClient.getListenId_(query, tag);\n        var thisListen = {};\n        this.listens_[listenId] = thisListen;\n        var queryStringParamaters = query\n            .getQueryParams()\n            .toRestQueryStringParameters();\n        this.restRequest_(pathString + '.json', queryStringParamaters, function (error, result) {\n            var data = result;\n            if (error === 404) {\n                data = null;\n                error = null;\n            }\n            if (error === null) {\n                _this.onDataUpdate_(pathString, data, /*isMerge=*/ false, tag);\n            }\n            if (safeGet(_this.listens_, listenId) === thisListen) {\n                var status_1;\n                if (!error) {\n                    status_1 = 'ok';\n                }\n                else if (error == 401) {\n                    status_1 = 'permission_denied';\n                }\n                else {\n                    status_1 = 'rest_error:' + error;\n                }\n                onComplete(status_1, null);\n            }\n        });\n    };\n    /** @inheritDoc */\n    ReadonlyRestClient.prototype.unlisten = function (query, tag) {\n        var listenId = ReadonlyRestClient.getListenId_(query, tag);\n        delete this.listens_[listenId];\n    };\n    /** @inheritDoc */\n    ReadonlyRestClient.prototype.refreshAuthToken = function (token) {\n        // no-op since we just always call getToken.\n    };\n    /**\n     * Performs a REST request to the given path, with the provided query string parameters,\n     * and any auth credentials we have.\n     *\n     * @param {!string} pathString\n     * @param {!Object.<string, *>} queryStringParameters\n     * @param {?function(?number, *=)} callback\n     * @private\n     */\n    ReadonlyRestClient.prototype.restRequest_ = function (pathString, queryStringParameters, callback) {\n        var _this = this;\n        if (queryStringParameters === void 0) { queryStringParameters = {}; }\n        queryStringParameters['format'] = 'export';\n        this.authTokenProvider_\n            .getToken(/*forceRefresh=*/ false)\n            .then(function (authTokenData) {\n            var authToken = authTokenData && authTokenData.accessToken;\n            if (authToken) {\n                queryStringParameters['auth'] = authToken;\n            }\n            var url = (_this.repoInfo_.secure ? 'https://' : 'http://') +\n                _this.repoInfo_.host +\n                pathString +\n                '?' +\n                querystring(queryStringParameters);\n            _this.log_('Sending REST request for ' + url);\n            var xhr = new XMLHttpRequest();\n            xhr.onreadystatechange = function () {\n                if (callback && xhr.readyState === 4) {\n                    _this.log_('REST Response for ' + url + ' received. status:', xhr.status, 'response:', xhr.responseText);\n                    var res = null;\n                    if (xhr.status >= 200 && xhr.status < 300) {\n                        try {\n                            res = jsonEval(xhr.responseText);\n                        }\n                        catch (e) {\n                            warn('Failed to parse JSON response for ' +\n                                url +\n                                ': ' +\n                                xhr.responseText);\n                        }\n                        callback(null, res);\n                    }\n                    else {\n                        // 401 and 404 are expected.\n                        if (xhr.status !== 401 && xhr.status !== 404) {\n                            warn('Got unsuccessful REST response for ' +\n                                url +\n                                ' Status: ' +\n                                xhr.status);\n                        }\n                        callback(xhr.status);\n                    }\n                    callback = null;\n                }\n            };\n            xhr.open('GET', url, /*asynchronous=*/ true);\n            xhr.send();\n        });\n    };\n    return ReadonlyRestClient;\n}(ServerActions));\nexport { ReadonlyRestClient };\n\n\n"]}