{"version":3,"sources":["database/src/database/core/view/EventRegistration.ts","database/core/view/EventRegistration.js"],"names":["ValueEventRegistration","callback_","cancelCallback_","context_","prototype","respondsTo","eventType","createEvent","change","query","index","getQueryParams","getIndex","snapshotNode","getRef","getEventRunner","eventData","ctx","getEventType","cancelCB_1","call","error","cb_1","snapshot","createCancelEvent","path","matches","other","hasAnyCallback","ChildEventRegistration","callbacks_","eventToCheck","childName","ref","child","type","prevName","cancelCB_2","cb_2","otherCount","thisCount","otherKey","thisKey","cb"],"mappings":"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","file":"EventRegistration.js","sourcesContent":["/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\nimport { DataSnapshot } from '../../api/DataSnapshot';\nimport { DataEvent, CancelEvent, Event } from './Event';\nimport { contains, getCount, getAnyKey, every } from '../../../utils/obj';\nimport { assert } from '../../../utils/assert';\nimport { Path } from '../util/Path';\nimport { Change } from './Change';\nimport { Query } from '../../api/Query';\n\n/**\n * An EventRegistration is basically an event type ('value', 'child_added', etc.) and a callback\n * to be notified of that type of event.\n *\n * That said, it can also contain a cancel callback to be notified if the event is canceled.  And\n * currently, this code is organized around the idea that you would register multiple child_ callbacks\n * together, as a single EventRegistration.  Though currently we don't do that.\n */\nexport interface EventRegistration {\n  /**\n   * True if this container has a callback to trigger for this event type\n   * @param {!string} eventType\n   * @return {boolean}\n   */\n  respondsTo(eventType: string): boolean;\n\n  /**\n   * @param {!Change} change\n   * @param {!Query} query\n   * @return {!Event}\n   */\n  createEvent(change: Change, query: Query): Event;\n\n  /**\n   * Given event data, return a function to trigger the user's callback\n   * @param {!Event} eventData\n   * @return {function()}\n   */\n  getEventRunner(eventData: Event): () => void;\n\n  /**\n   * @param {!Error} error\n   * @param {!Path} path\n   * @return {?CancelEvent}\n   */\n  createCancelEvent(error: Error, path: Path): CancelEvent | null;\n\n  /**\n   * @param {!EventRegistration} other\n   * @return {boolean}\n   */\n  matches(other: EventRegistration): boolean;\n\n  /**\n   * False basically means this is a \"dummy\" callback container being used as a sentinel\n   * to remove all callback containers of a particular type.  (e.g. if the user does\n   * ref.off('value') without specifying a specific callback).\n   *\n   * (TODO: Rework this, since it's hacky)\n   *\n   * @return {boolean}\n   */\n  hasAnyCallback(): boolean;\n}\n\n/**\n * Represents registration for 'value' events.\n */\nexport class ValueEventRegistration implements EventRegistration {\n  /**\n   * @param {?function(!DataSnapshot)} callback_\n   * @param {?function(Error)} cancelCallback_\n   * @param {?Object} context_\n   */\n  constructor(\n    private callback_: ((d: DataSnapshot) => void) | null,\n    private cancelCallback_: ((e: Error) => void) | null,\n    private context_: Object | null\n  ) {}\n\n  /**\n   * @inheritDoc\n   */\n  respondsTo(eventType: string): boolean {\n    return eventType === 'value';\n  }\n\n  /**\n   * @inheritDoc\n   */\n  createEvent(change: Change, query: Query): DataEvent {\n    const index = query.getQueryParams().getIndex();\n    return new DataEvent(\n      'value',\n      this,\n      new DataSnapshot(change.snapshotNode, query.getRef(), index)\n    );\n  }\n\n  /**\n   * @inheritDoc\n   */\n  getEventRunner(eventData: CancelEvent | DataEvent): () => void {\n    const ctx = this.context_;\n    if (eventData.getEventType() === 'cancel') {\n      assert(\n        this.cancelCallback_,\n        'Raising a cancel event on a listener with no cancel callback'\n      );\n      const cancelCB = this.cancelCallback_;\n      return function() {\n        // We know that error exists, we checked above that this is a cancel event\n        cancelCB.call(ctx, (eventData as CancelEvent).error);\n      };\n    } else {\n      const cb = this.callback_;\n      return function() {\n        cb.call(ctx, (eventData as DataEvent).snapshot);\n      };\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  createCancelEvent(error: Error, path: Path): CancelEvent | null {\n    if (this.cancelCallback_) {\n      return new CancelEvent(this, error, path);\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  matches(other: EventRegistration): boolean {\n    if (!(other instanceof ValueEventRegistration)) {\n      return false;\n    } else if (!other.callback_ || !this.callback_) {\n      // If no callback specified, we consider it to match any callback.\n      return true;\n    } else {\n      return (\n        other.callback_ === this.callback_ && other.context_ === this.context_\n      );\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  hasAnyCallback(): boolean {\n    return this.callback_ !== null;\n  }\n}\n\n/**\n * Represents the registration of 1 or more child_xxx events.\n *\n * Currently, it is always exactly 1 child_xxx event, but the idea is we might let you\n * register a group of callbacks together in the future.\n *\n * @constructor\n * @implements {EventRegistration}\n */\nexport class ChildEventRegistration implements EventRegistration {\n  /**\n   * @param {?Object.<string, function(!DataSnapshot, ?string=)>} callbacks_\n   * @param {?function(Error)} cancelCallback_\n   * @param {Object=} context_\n   */\n  constructor(\n    private callbacks_:\n      | ({ [k: string]: (d: DataSnapshot, s?: string | null) => void })\n      | null,\n    private cancelCallback_: ((e: Error) => void) | null,\n    private context_?: Object\n  ) {}\n\n  /**\n   * @inheritDoc\n   */\n  respondsTo(eventType: string): boolean {\n    let eventToCheck =\n      eventType === 'children_added' ? 'child_added' : eventType;\n    eventToCheck =\n      eventToCheck === 'children_removed' ? 'child_removed' : eventToCheck;\n    return contains(this.callbacks_, eventToCheck);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  createCancelEvent(error: Error, path: Path): CancelEvent | null {\n    if (this.cancelCallback_) {\n      return new CancelEvent(this, error, path);\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  createEvent(change: Change, query: Query): DataEvent {\n    assert(change.childName != null, 'Child events should have a childName.');\n    const ref = query.getRef().child /** @type {!string} */(change.childName);\n    const index = query.getQueryParams().getIndex();\n    return new DataEvent(\n      change.type as any,\n      this,\n      new DataSnapshot(change.snapshotNode, ref, index as any),\n      change.prevName\n    );\n  }\n\n  /**\n   * @inheritDoc\n   */\n  getEventRunner(eventData: CancelEvent | DataEvent): () => void {\n    const ctx = this.context_;\n    if (eventData.getEventType() === 'cancel') {\n      assert(\n        this.cancelCallback_,\n        'Raising a cancel event on a listener with no cancel callback'\n      );\n      const cancelCB = this.cancelCallback_;\n      return function() {\n        // We know that error exists, we checked above that this is a cancel event\n        cancelCB.call(ctx, (eventData as CancelEvent).error);\n      };\n    } else {\n      const cb = this.callbacks_[(eventData as DataEvent).eventType];\n      return function() {\n        cb.call(\n          ctx,\n          (eventData as DataEvent).snapshot,\n          (eventData as DataEvent).prevName\n        );\n      };\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  matches(other: EventRegistration): boolean {\n    if (other instanceof ChildEventRegistration) {\n      if (!this.callbacks_ || !other.callbacks_) {\n        return true;\n      } else if (this.context_ === other.context_) {\n        const otherCount = getCount(other.callbacks_);\n        const thisCount = getCount(this.callbacks_);\n        if (otherCount === thisCount) {\n          // If count is 1, do an exact match on eventType, if either is defined but null, it's a match.\n          //  If event types don't match, not a match\n          // If count is not 1, exact match across all\n\n          if (otherCount === 1) {\n            const otherKey /** @type {!string} */ = getAnyKey(other.callbacks_);\n            const thisKey /** @type {!string} */ = getAnyKey(this.callbacks_);\n            return (\n              thisKey === otherKey &&\n              (!other.callbacks_[otherKey] ||\n                !this.callbacks_[thisKey] ||\n                other.callbacks_[otherKey] === this.callbacks_[thisKey])\n            );\n          } else {\n            // Exact match on each key.\n            return every(\n              this.callbacks_,\n              (eventType, cb) => other.callbacks_[eventType] === cb\n            );\n          }\n        }\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  hasAnyCallback(): boolean {\n    return this.callbacks_ !== null;\n  }\n}\n","/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\nimport { DataSnapshot } from '../../api/DataSnapshot';\nimport { DataEvent, CancelEvent } from './Event';\nimport { contains, getCount, getAnyKey, every } from '../../../utils/obj';\nimport { assert } from '../../../utils/assert';\n/**\n * Represents registration for 'value' events.\n */\nvar ValueEventRegistration = (function () {\n    /**\n     * @param {?function(!DataSnapshot)} callback_\n     * @param {?function(Error)} cancelCallback_\n     * @param {?Object} context_\n     */\n    function ValueEventRegistration(callback_, cancelCallback_, context_) {\n        this.callback_ = callback_;\n        this.cancelCallback_ = cancelCallback_;\n        this.context_ = context_;\n    }\n    /**\n     * @inheritDoc\n     */\n    ValueEventRegistration.prototype.respondsTo = function (eventType) {\n        return eventType === 'value';\n    };\n    /**\n     * @inheritDoc\n     */\n    ValueEventRegistration.prototype.createEvent = function (change, query) {\n        var index = query.getQueryParams().getIndex();\n        return new DataEvent('value', this, new DataSnapshot(change.snapshotNode, query.getRef(), index));\n    };\n    /**\n     * @inheritDoc\n     */\n    ValueEventRegistration.prototype.getEventRunner = function (eventData) {\n        var ctx = this.context_;\n        if (eventData.getEventType() === 'cancel') {\n            assert(this.cancelCallback_, 'Raising a cancel event on a listener with no cancel callback');\n            var cancelCB_1 = this.cancelCallback_;\n            return function () {\n                // We know that error exists, we checked above that this is a cancel event\n                cancelCB_1.call(ctx, eventData.error);\n            };\n        }\n        else {\n            var cb_1 = this.callback_;\n            return function () {\n                cb_1.call(ctx, eventData.snapshot);\n            };\n        }\n    };\n    /**\n     * @inheritDoc\n     */\n    ValueEventRegistration.prototype.createCancelEvent = function (error, path) {\n        if (this.cancelCallback_) {\n            return new CancelEvent(this, error, path);\n        }\n        else {\n            return null;\n        }\n    };\n    /**\n     * @inheritDoc\n     */\n    ValueEventRegistration.prototype.matches = function (other) {\n        if (!(other instanceof ValueEventRegistration)) {\n            return false;\n        }\n        else if (!other.callback_ || !this.callback_) {\n            // If no callback specified, we consider it to match any callback.\n            return true;\n        }\n        else {\n            return (other.callback_ === this.callback_ && other.context_ === this.context_);\n        }\n    };\n    /**\n     * @inheritDoc\n     */\n    ValueEventRegistration.prototype.hasAnyCallback = function () {\n        return this.callback_ !== null;\n    };\n    return ValueEventRegistration;\n}());\nexport { ValueEventRegistration };\n/**\n * Represents the registration of 1 or more child_xxx events.\n *\n * Currently, it is always exactly 1 child_xxx event, but the idea is we might let you\n * register a group of callbacks together in the future.\n *\n * @constructor\n * @implements {EventRegistration}\n */\nvar ChildEventRegistration = (function () {\n    /**\n     * @param {?Object.<string, function(!DataSnapshot, ?string=)>} callbacks_\n     * @param {?function(Error)} cancelCallback_\n     * @param {Object=} context_\n     */\n    function ChildEventRegistration(callbacks_, cancelCallback_, context_) {\n        this.callbacks_ = callbacks_;\n        this.cancelCallback_ = cancelCallback_;\n        this.context_ = context_;\n    }\n    /**\n     * @inheritDoc\n     */\n    ChildEventRegistration.prototype.respondsTo = function (eventType) {\n        var eventToCheck = eventType === 'children_added' ? 'child_added' : eventType;\n        eventToCheck =\n            eventToCheck === 'children_removed' ? 'child_removed' : eventToCheck;\n        return contains(this.callbacks_, eventToCheck);\n    };\n    /**\n     * @inheritDoc\n     */\n    ChildEventRegistration.prototype.createCancelEvent = function (error, path) {\n        if (this.cancelCallback_) {\n            return new CancelEvent(this, error, path);\n        }\n        else {\n            return null;\n        }\n    };\n    /**\n     * @inheritDoc\n     */\n    ChildEventRegistration.prototype.createEvent = function (change, query) {\n        assert(change.childName != null, 'Child events should have a childName.');\n        var ref = query.getRef().child /** @type {!string} */(change.childName);\n        var index = query.getQueryParams().getIndex();\n        return new DataEvent(change.type, this, new DataSnapshot(change.snapshotNode, ref, index), change.prevName);\n    };\n    /**\n     * @inheritDoc\n     */\n    ChildEventRegistration.prototype.getEventRunner = function (eventData) {\n        var ctx = this.context_;\n        if (eventData.getEventType() === 'cancel') {\n            assert(this.cancelCallback_, 'Raising a cancel event on a listener with no cancel callback');\n            var cancelCB_2 = this.cancelCallback_;\n            return function () {\n                // We know that error exists, we checked above that this is a cancel event\n                cancelCB_2.call(ctx, eventData.error);\n            };\n        }\n        else {\n            var cb_2 = this.callbacks_[eventData.eventType];\n            return function () {\n                cb_2.call(ctx, eventData.snapshot, eventData.prevName);\n            };\n        }\n    };\n    /**\n     * @inheritDoc\n     */\n    ChildEventRegistration.prototype.matches = function (other) {\n        if (other instanceof ChildEventRegistration) {\n            if (!this.callbacks_ || !other.callbacks_) {\n                return true;\n            }\n            else if (this.context_ === other.context_) {\n                var otherCount = getCount(other.callbacks_);\n                var thisCount = getCount(this.callbacks_);\n                if (otherCount === thisCount) {\n                    // If count is 1, do an exact match on eventType, if either is defined but null, it's a match.\n                    //  If event types don't match, not a match\n                    // If count is not 1, exact match across all\n                    if (otherCount === 1) {\n                        var otherKey /** @type {!string} */ = getAnyKey(other.callbacks_);\n                        var thisKey /** @type {!string} */ = getAnyKey(this.callbacks_);\n                        return (thisKey === otherKey &&\n                            (!other.callbacks_[otherKey] ||\n                                !this.callbacks_[thisKey] ||\n                                other.callbacks_[otherKey] === this.callbacks_[thisKey]));\n                    }\n                    else {\n                        // Exact match on each key.\n                        return every(this.callbacks_, function (eventType, cb) { return other.callbacks_[eventType] === cb; });\n                    }\n                }\n            }\n        }\n        return false;\n    };\n    /**\n     * @inheritDoc\n     */\n    ChildEventRegistration.prototype.hasAnyCallback = function () {\n        return this.callbacks_ !== null;\n    };\n    return ChildEventRegistration;\n}());\nexport { ChildEventRegistration };\n\n\n"]}