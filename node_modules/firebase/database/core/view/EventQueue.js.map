{"version":3,"sources":["database/src/database/core/view/EventQueue.ts","database/core/view/EventQueue.js"],"names":["EventQueue","eventLists_","recursionDepth_","prototype","queueEvents","eventDataList","currList","i","length","eventData","eventPath","getPath","equals","push","EventList","add","raiseEventsAtPath","path","raiseQueuedEventsMatchingPredicate_","raiseEventsForChangedPath","changedPath","contains","predicate","sentAll","eventList","raise","path_","events_","eventFn","getEventRunner","toString"],"mappings":"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","file":"EventQueue.js","sourcesContent":["/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\nimport { Path } from '../util/Path';\nimport { log, logger, exceptionGuard } from '../util/util';\nimport { Event } from './Event';\n\n/**\n * The event queue serves a few purposes:\n * 1. It ensures we maintain event order in the face of event callbacks doing operations that result in more\n *    events being queued.\n * 2. raiseQueuedEvents() handles being called reentrantly nicely.  That is, if in the course of raising events,\n *    raiseQueuedEvents() is called again, the \"inner\" call will pick up raising events where the \"outer\" call\n *    left off, ensuring that the events are still raised synchronously and in order.\n * 3. You can use raiseEventsAtPath and raiseEventsForChangedPath to ensure only relevant previously-queued\n *    events are raised synchronously.\n *\n * NOTE: This can all go away if/when we move to async events.\n *\n * @constructor\n */\nexport class EventQueue {\n  /**\n   * @private\n   * @type {!Array.<EventList>}\n   */\n  private eventLists_: EventList[] = [];\n\n  /**\n   * Tracks recursion depth of raiseQueuedEvents_, for debugging purposes.\n   * @private\n   * @type {!number}\n   */\n  private recursionDepth_ = 0;\n\n  /**\n   * @param {!Array.<Event>} eventDataList The new events to queue.\n   */\n  queueEvents(eventDataList: Event[]) {\n    // We group events by path, storing them in a single EventList, to make it easier to skip over them quickly.\n    let currList = null;\n    for (let i = 0; i < eventDataList.length; i++) {\n      const eventData = eventDataList[i];\n      const eventPath = eventData.getPath();\n      if (currList !== null && !eventPath.equals(currList.getPath())) {\n        this.eventLists_.push(currList);\n        currList = null;\n      }\n\n      if (currList === null) {\n        currList = new EventList(eventPath);\n      }\n\n      currList.add(eventData);\n    }\n    if (currList) {\n      this.eventLists_.push(currList);\n    }\n  }\n\n  /**\n   * Queues the specified events and synchronously raises all events (including previously queued ones)\n   * for the specified path.\n   *\n   * It is assumed that the new events are all for the specified path.\n   *\n   * @param {!Path} path The path to raise events for.\n   * @param {!Array.<Event>} eventDataList The new events to raise.\n   */\n  raiseEventsAtPath(path: Path, eventDataList: Event[]) {\n    this.queueEvents(eventDataList);\n    this.raiseQueuedEventsMatchingPredicate_((eventPath: Path) =>\n      eventPath.equals(path)\n    );\n  }\n\n  /**\n   * Queues the specified events and synchronously raises all events (including previously queued ones) for\n   * locations related to the specified change path (i.e. all ancestors and descendants).\n   *\n   * It is assumed that the new events are all related (ancestor or descendant) to the specified path.\n   *\n   * @param {!Path} changedPath The path to raise events for.\n   * @param {!Array.<!Event>} eventDataList The events to raise\n   */\n  raiseEventsForChangedPath(changedPath: Path, eventDataList: Event[]) {\n    this.queueEvents(eventDataList);\n\n    this.raiseQueuedEventsMatchingPredicate_((eventPath: Path) => {\n      return eventPath.contains(changedPath) || changedPath.contains(eventPath);\n    });\n  }\n\n  /**\n   * @param {!function(!Path):boolean} predicate\n   * @private\n   */\n  private raiseQueuedEventsMatchingPredicate_(\n    predicate: (path: Path) => boolean\n  ) {\n    this.recursionDepth_++;\n\n    let sentAll = true;\n    for (let i = 0; i < this.eventLists_.length; i++) {\n      const eventList = this.eventLists_[i];\n      if (eventList) {\n        const eventPath = eventList.getPath();\n        if (predicate(eventPath)) {\n          this.eventLists_[i].raise();\n          this.eventLists_[i] = null;\n        } else {\n          sentAll = false;\n        }\n      }\n    }\n\n    if (sentAll) {\n      this.eventLists_ = [];\n    }\n\n    this.recursionDepth_--;\n  }\n}\n\n/**\n * @param {!Path} path\n * @constructor\n */\nexport class EventList {\n  /**\n   * @type {!Array.<Event>}\n   * @private\n   */\n  private events_: Event[] = [];\n\n  constructor(private readonly path_: Path) {}\n\n  /**\n   * @param {!Event} eventData\n   */\n  add(eventData: Event) {\n    this.events_.push(eventData);\n  }\n\n  /**\n   * Iterates through the list and raises each event\n   */\n  raise() {\n    for (let i = 0; i < this.events_.length; i++) {\n      const eventData = this.events_[i];\n      if (eventData !== null) {\n        this.events_[i] = null;\n        const eventFn = eventData.getEventRunner();\n        if (logger) {\n          log('event: ' + eventData.toString());\n        }\n        exceptionGuard(eventFn);\n      }\n    }\n  }\n\n  /**\n   * @return {!Path}\n   */\n  getPath(): Path {\n    return this.path_;\n  }\n}\n","/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\nimport { log, logger, exceptionGuard } from '../util/util';\n/**\n * The event queue serves a few purposes:\n * 1. It ensures we maintain event order in the face of event callbacks doing operations that result in more\n *    events being queued.\n * 2. raiseQueuedEvents() handles being called reentrantly nicely.  That is, if in the course of raising events,\n *    raiseQueuedEvents() is called again, the \"inner\" call will pick up raising events where the \"outer\" call\n *    left off, ensuring that the events are still raised synchronously and in order.\n * 3. You can use raiseEventsAtPath and raiseEventsForChangedPath to ensure only relevant previously-queued\n *    events are raised synchronously.\n *\n * NOTE: This can all go away if/when we move to async events.\n *\n * @constructor\n */\nvar EventQueue = (function () {\n    function EventQueue() {\n        /**\n         * @private\n         * @type {!Array.<EventList>}\n         */\n        this.eventLists_ = [];\n        /**\n         * Tracks recursion depth of raiseQueuedEvents_, for debugging purposes.\n         * @private\n         * @type {!number}\n         */\n        this.recursionDepth_ = 0;\n    }\n    /**\n     * @param {!Array.<Event>} eventDataList The new events to queue.\n     */\n    EventQueue.prototype.queueEvents = function (eventDataList) {\n        // We group events by path, storing them in a single EventList, to make it easier to skip over them quickly.\n        var currList = null;\n        for (var i = 0; i < eventDataList.length; i++) {\n            var eventData = eventDataList[i];\n            var eventPath = eventData.getPath();\n            if (currList !== null && !eventPath.equals(currList.getPath())) {\n                this.eventLists_.push(currList);\n                currList = null;\n            }\n            if (currList === null) {\n                currList = new EventList(eventPath);\n            }\n            currList.add(eventData);\n        }\n        if (currList) {\n            this.eventLists_.push(currList);\n        }\n    };\n    /**\n     * Queues the specified events and synchronously raises all events (including previously queued ones)\n     * for the specified path.\n     *\n     * It is assumed that the new events are all for the specified path.\n     *\n     * @param {!Path} path The path to raise events for.\n     * @param {!Array.<Event>} eventDataList The new events to raise.\n     */\n    EventQueue.prototype.raiseEventsAtPath = function (path, eventDataList) {\n        this.queueEvents(eventDataList);\n        this.raiseQueuedEventsMatchingPredicate_(function (eventPath) {\n            return eventPath.equals(path);\n        });\n    };\n    /**\n     * Queues the specified events and synchronously raises all events (including previously queued ones) for\n     * locations related to the specified change path (i.e. all ancestors and descendants).\n     *\n     * It is assumed that the new events are all related (ancestor or descendant) to the specified path.\n     *\n     * @param {!Path} changedPath The path to raise events for.\n     * @param {!Array.<!Event>} eventDataList The events to raise\n     */\n    EventQueue.prototype.raiseEventsForChangedPath = function (changedPath, eventDataList) {\n        this.queueEvents(eventDataList);\n        this.raiseQueuedEventsMatchingPredicate_(function (eventPath) {\n            return eventPath.contains(changedPath) || changedPath.contains(eventPath);\n        });\n    };\n    /**\n     * @param {!function(!Path):boolean} predicate\n     * @private\n     */\n    EventQueue.prototype.raiseQueuedEventsMatchingPredicate_ = function (predicate) {\n        this.recursionDepth_++;\n        var sentAll = true;\n        for (var i = 0; i < this.eventLists_.length; i++) {\n            var eventList = this.eventLists_[i];\n            if (eventList) {\n                var eventPath = eventList.getPath();\n                if (predicate(eventPath)) {\n                    this.eventLists_[i].raise();\n                    this.eventLists_[i] = null;\n                }\n                else {\n                    sentAll = false;\n                }\n            }\n        }\n        if (sentAll) {\n            this.eventLists_ = [];\n        }\n        this.recursionDepth_--;\n    };\n    return EventQueue;\n}());\nexport { EventQueue };\n/**\n * @param {!Path} path\n * @constructor\n */\nvar EventList = (function () {\n    function EventList(path_) {\n        this.path_ = path_;\n        /**\n         * @type {!Array.<Event>}\n         * @private\n         */\n        this.events_ = [];\n    }\n    /**\n     * @param {!Event} eventData\n     */\n    EventList.prototype.add = function (eventData) {\n        this.events_.push(eventData);\n    };\n    /**\n     * Iterates through the list and raises each event\n     */\n    EventList.prototype.raise = function () {\n        for (var i = 0; i < this.events_.length; i++) {\n            var eventData = this.events_[i];\n            if (eventData !== null) {\n                this.events_[i] = null;\n                var eventFn = eventData.getEventRunner();\n                if (logger) {\n                    log('event: ' + eventData.toString());\n                }\n                exceptionGuard(eventFn);\n            }\n        }\n    };\n    /**\n     * @return {!Path}\n     */\n    EventList.prototype.getPath = function () {\n        return this.path_;\n    };\n    return EventList;\n}());\nexport { EventList };\n\n\n"]}