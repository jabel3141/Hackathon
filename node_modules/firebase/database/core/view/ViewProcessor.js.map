{"version":3,"sources":["database/src/database/core/view/ViewProcessor.ts","database/core/view/ViewProcessor.js"],"names":["ProcessorResult","viewCache","changes","ViewProcessor","filter_","prototype","assertIndexed","getEventCache","getNode","isIndexed","getIndex","getServerCache","applyOperation","oldViewCache","operation","writesCache","completeCache","accumulator","newViewCache","filterServerNode","type","OVERWRITE","overwrite","source","fromUser","applyUserOverwrite_","path","snap","fromServer","tagged","isFiltered","isEmpty","applyServerOverwrite_","MERGE","merge","applyUserMerge_","children","applyServerMerge_","ACK_USER_WRITE","ackUserWrite","revert","ackUserWrite_","affectedTree","revertUserWrite_","LISTEN_COMPLETE","listenComplete_","getChanges","maybeAddValueEvent_","eventSnap","isFullyInitialized","isLeafOrEmpty","isLeafNode","oldCompleteSnap","getCompleteEventSnap","length","equals","getPriority","push","valueChange","generateEventCacheAfterServerEvent_","changePath","oldEventSnap","shadowingWrite","newEventCache","serverNode","serverCache","getCompleteServerSnap","completeChildren","EMPTY_NODE","completeEventChildren","calcCompleteEventChildren","updateFullNode","completeNode","calcCompleteEventCache","childKey","getFront","getLength","oldEventNode","updatedPriority","calcEventCacheAfterServerOverwrite","updatePriority","childChangePath","popFront","newEventChild","isCompleteForChild","eventChildUpdate","getImmediateChild","updateChild","calcCompleteChild","updateEventSnap","filtersNodes","changedSnap","oldServerSnap","newServerCache","serverFilter","getIndexedFilter","newServerNode","isCompleteForPath","childNode","newChildNode","updateServerSnap","oldChild","newChild","getCompleteChild","getBack","getChild","parent","newEventSnap","cacheHasChild_","changedChildren","_this","curViewCache","foreach","relativePath","writePath","child","applyMerge_","node","viewMergeTree","Empty","setTree","inorderTraversal","childTree","hasChild","serverChild","childMergeTree","isUnknownDeepMerge","value","ackPath","changedChildren_1","forEachChild","name","set","changedChildren_2","mergePath","serverCachePath","oldServerNode","completeServerCache","complete","oldEventCache","newNode","serverChildren"],"mappings":"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","file":"ViewProcessor.js","sourcesContent":["/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\nimport { Operation, OperationType } from '../operation/Operation';\nimport { assert, assertionError } from '../../../utils/assert';\nimport { ChildChangeAccumulator } from './ChildChangeAccumulator';\nimport { Change } from './Change';\nimport { ChildrenNode } from '../snap/ChildrenNode';\nimport { KEY_INDEX } from '../snap/indexes/KeyIndex';\nimport { ImmutableTree } from '../util/ImmutableTree';\nimport { Path } from '../util/Path';\nimport {\n  WriteTreeCompleteChildSource,\n  NO_COMPLETE_CHILD_SOURCE,\n  CompleteChildSource\n} from './CompleteChildSource';\nimport { ViewCache } from './ViewCache';\nimport { NodeFilter } from './filter/NodeFilter';\nimport { WriteTreeRef } from '../WriteTree';\nimport { Overwrite } from '../operation/Overwrite';\nimport { Merge } from '../operation/Merge';\nimport { AckUserWrite } from '../operation/AckUserWrite';\nimport { Node } from '../snap/Node';\n\n/**\n * @constructor\n * @struct\n */\nexport class ProcessorResult {\n  /**\n   * @param {!ViewCache} viewCache\n   * @param {!Array.<!Change>} changes\n   */\n  constructor(\n    public readonly viewCache: ViewCache,\n    public readonly changes: Change[]\n  ) {}\n}\n\n/**\n * @constructor\n */\nexport class ViewProcessor {\n  /**\n   * @param {!NodeFilter} filter_\n   */\n  constructor(private readonly filter_: NodeFilter) {}\n\n  /**\n   * @param {!ViewCache} viewCache\n   */\n  assertIndexed(viewCache: ViewCache) {\n    assert(\n      viewCache.getEventCache().getNode().isIndexed(this.filter_.getIndex()),\n      'Event snap not indexed'\n    );\n    assert(\n      viewCache.getServerCache().getNode().isIndexed(this.filter_.getIndex()),\n      'Server snap not indexed'\n    );\n  }\n\n  /**\n   * @param {!ViewCache} oldViewCache\n   * @param {!Operation} operation\n   * @param {!WriteTreeRef} writesCache\n   * @param {?Node} completeCache\n   * @return {!ProcessorResult}\n   */\n  applyOperation(\n    oldViewCache: ViewCache,\n    operation: Operation,\n    writesCache: WriteTreeRef,\n    completeCache: Node | null\n  ): ProcessorResult {\n    const accumulator = new ChildChangeAccumulator();\n    let newViewCache, filterServerNode;\n    if (operation.type === OperationType.OVERWRITE) {\n      const overwrite = operation as Overwrite;\n      if (overwrite.source.fromUser) {\n        newViewCache = this.applyUserOverwrite_(\n          oldViewCache,\n          overwrite.path,\n          overwrite.snap,\n          writesCache,\n          completeCache,\n          accumulator\n        );\n      } else {\n        assert(overwrite.source.fromServer, 'Unknown source.');\n        // We filter the node if it's a tagged update or the node has been previously filtered  and the\n        // update is not at the root in which case it is ok (and necessary) to mark the node unfiltered\n        // again\n        filterServerNode =\n          overwrite.source.tagged ||\n          (oldViewCache.getServerCache().isFiltered() &&\n            !overwrite.path.isEmpty());\n        newViewCache = this.applyServerOverwrite_(\n          oldViewCache,\n          overwrite.path,\n          overwrite.snap,\n          writesCache,\n          completeCache,\n          filterServerNode,\n          accumulator\n        );\n      }\n    } else if (operation.type === OperationType.MERGE) {\n      const merge = operation as Merge;\n      if (merge.source.fromUser) {\n        newViewCache = this.applyUserMerge_(\n          oldViewCache,\n          merge.path,\n          merge.children,\n          writesCache,\n          completeCache,\n          accumulator\n        );\n      } else {\n        assert(merge.source.fromServer, 'Unknown source.');\n        // We filter the node if it's a tagged update or the node has been previously filtered\n        filterServerNode =\n          merge.source.tagged || oldViewCache.getServerCache().isFiltered();\n        newViewCache = this.applyServerMerge_(\n          oldViewCache,\n          merge.path,\n          merge.children,\n          writesCache,\n          completeCache,\n          filterServerNode,\n          accumulator\n        );\n      }\n    } else if (operation.type === OperationType.ACK_USER_WRITE) {\n      const ackUserWrite = operation as AckUserWrite;\n      if (!ackUserWrite.revert) {\n        newViewCache = this.ackUserWrite_(\n          oldViewCache,\n          ackUserWrite.path,\n          ackUserWrite.affectedTree,\n          writesCache,\n          completeCache,\n          accumulator\n        );\n      } else {\n        newViewCache = this.revertUserWrite_(\n          oldViewCache,\n          ackUserWrite.path,\n          writesCache,\n          completeCache,\n          accumulator\n        );\n      }\n    } else if (operation.type === OperationType.LISTEN_COMPLETE) {\n      newViewCache = this.listenComplete_(\n        oldViewCache,\n        operation.path,\n        writesCache,\n        accumulator\n      );\n    } else {\n      throw assertionError('Unknown operation type: ' + operation.type);\n    }\n    const changes = accumulator.getChanges();\n    ViewProcessor.maybeAddValueEvent_(oldViewCache, newViewCache, changes);\n    return new ProcessorResult(newViewCache, changes);\n  }\n\n  /**\n   * @param {!ViewCache} oldViewCache\n   * @param {!ViewCache} newViewCache\n   * @param {!Array.<!Change>} accumulator\n   * @private\n   */\n  private static maybeAddValueEvent_(\n    oldViewCache: ViewCache,\n    newViewCache: ViewCache,\n    accumulator: Change[]\n  ) {\n    const eventSnap = newViewCache.getEventCache();\n    if (eventSnap.isFullyInitialized()) {\n      const isLeafOrEmpty =\n        eventSnap.getNode().isLeafNode() || eventSnap.getNode().isEmpty();\n      const oldCompleteSnap = oldViewCache.getCompleteEventSnap();\n      if (\n        accumulator.length > 0 ||\n        !oldViewCache.getEventCache().isFullyInitialized() ||\n        (isLeafOrEmpty &&\n          !eventSnap.getNode().equals /** @type {!Node} */(oldCompleteSnap)) ||\n        !eventSnap.getNode().getPriority().equals(oldCompleteSnap.getPriority())\n      ) {\n        accumulator.push(\n          Change.valueChange(\n            /** @type {!Node} */ newViewCache.getCompleteEventSnap()\n          )\n        );\n      }\n    }\n  }\n\n  /**\n   * @param {!ViewCache} viewCache\n   * @param {!Path} changePath\n   * @param {!WriteTreeRef} writesCache\n   * @param {!CompleteChildSource} source\n   * @param {!ChildChangeAccumulator} accumulator\n   * @return {!ViewCache}\n   * @private\n   */\n  private generateEventCacheAfterServerEvent_(\n    viewCache: ViewCache,\n    changePath: Path,\n    writesCache: WriteTreeRef,\n    source: CompleteChildSource,\n    accumulator: ChildChangeAccumulator\n  ): ViewCache {\n    const oldEventSnap = viewCache.getEventCache();\n    if (writesCache.shadowingWrite(changePath) != null) {\n      // we have a shadowing write, ignore changes\n      return viewCache;\n    } else {\n      let newEventCache, serverNode;\n      if (changePath.isEmpty()) {\n        // TODO: figure out how this plays with \"sliding ack windows\"\n        assert(\n          viewCache.getServerCache().isFullyInitialized(),\n          'If change path is empty, we must have complete server data'\n        );\n        if (viewCache.getServerCache().isFiltered()) {\n          // We need to special case this, because we need to only apply writes to complete children, or\n          // we might end up raising events for incomplete children. If the server data is filtered deep\n          // writes cannot be guaranteed to be complete\n          const serverCache = viewCache.getCompleteServerSnap();\n          const completeChildren =\n            serverCache instanceof ChildrenNode\n              ? serverCache\n              : ChildrenNode.EMPTY_NODE;\n          const completeEventChildren = writesCache.calcCompleteEventChildren(\n            completeChildren\n          );\n          newEventCache = this.filter_.updateFullNode(\n            viewCache.getEventCache().getNode(),\n            completeEventChildren,\n            accumulator\n          );\n        } else {\n          const completeNode = writesCache.calcCompleteEventCache(\n            viewCache.getCompleteServerSnap()\n          );\n          newEventCache = this.filter_.updateFullNode(\n            viewCache.getEventCache().getNode(),\n            completeNode,\n            accumulator\n          );\n        }\n      } else {\n        const childKey = changePath.getFront();\n        if (childKey == '.priority') {\n          assert(\n            changePath.getLength() == 1,\n            \"Can't have a priority with additional path components\"\n          );\n          const oldEventNode = oldEventSnap.getNode();\n          serverNode = viewCache.getServerCache().getNode();\n          // we might have overwrites for this priority\n          const updatedPriority = writesCache.calcEventCacheAfterServerOverwrite(\n            changePath,\n            oldEventNode,\n            serverNode\n          );\n          if (updatedPriority != null) {\n            newEventCache = this.filter_.updatePriority(\n              oldEventNode,\n              updatedPriority\n            );\n          } else {\n            // priority didn't change, keep old node\n            newEventCache = oldEventSnap.getNode();\n          }\n        } else {\n          const childChangePath = changePath.popFront();\n          // update child\n          let newEventChild;\n          if (oldEventSnap.isCompleteForChild(childKey)) {\n            serverNode = viewCache.getServerCache().getNode();\n            const eventChildUpdate = writesCache.calcEventCacheAfterServerOverwrite(\n              changePath,\n              oldEventSnap.getNode(),\n              serverNode\n            );\n            if (eventChildUpdate != null) {\n              newEventChild = oldEventSnap\n                .getNode()\n                .getImmediateChild(childKey)\n                .updateChild(childChangePath, eventChildUpdate);\n            } else {\n              // Nothing changed, just keep the old child\n              newEventChild = oldEventSnap\n                .getNode()\n                .getImmediateChild(childKey);\n            }\n          } else {\n            newEventChild = writesCache.calcCompleteChild(\n              childKey,\n              viewCache.getServerCache()\n            );\n          }\n          if (newEventChild != null) {\n            newEventCache = this.filter_.updateChild(\n              oldEventSnap.getNode(),\n              childKey,\n              newEventChild,\n              childChangePath,\n              source,\n              accumulator\n            );\n          } else {\n            // no complete child available or no change\n            newEventCache = oldEventSnap.getNode();\n          }\n        }\n      }\n      return viewCache.updateEventSnap(\n        newEventCache,\n        oldEventSnap.isFullyInitialized() || changePath.isEmpty(),\n        this.filter_.filtersNodes()\n      );\n    }\n  }\n\n  /**\n   * @param {!ViewCache} oldViewCache\n   * @param {!Path} changePath\n   * @param {!Node} changedSnap\n   * @param {!WriteTreeRef} writesCache\n   * @param {?Node} completeCache\n   * @param {boolean} filterServerNode\n   * @param {!ChildChangeAccumulator} accumulator\n   * @return {!ViewCache}\n   * @private\n   */\n  applyServerOverwrite_(\n    oldViewCache: ViewCache,\n    changePath: Path,\n    changedSnap: Node,\n    writesCache: WriteTreeRef,\n    completeCache: Node | null,\n    filterServerNode: boolean,\n    accumulator: ChildChangeAccumulator\n  ): ViewCache {\n    const oldServerSnap = oldViewCache.getServerCache();\n    let newServerCache;\n    const serverFilter = filterServerNode\n      ? this.filter_\n      : this.filter_.getIndexedFilter();\n    if (changePath.isEmpty()) {\n      newServerCache = serverFilter.updateFullNode(\n        oldServerSnap.getNode(),\n        changedSnap,\n        null\n      );\n    } else if (serverFilter.filtersNodes() && !oldServerSnap.isFiltered()) {\n      // we want to filter the server node, but we didn't filter the server node yet, so simulate a full update\n      const newServerNode = oldServerSnap\n        .getNode()\n        .updateChild(changePath, changedSnap);\n      newServerCache = serverFilter.updateFullNode(\n        oldServerSnap.getNode(),\n        newServerNode,\n        null\n      );\n    } else {\n      const childKey = changePath.getFront();\n      if (\n        !oldServerSnap.isCompleteForPath(changePath) &&\n        changePath.getLength() > 1\n      ) {\n        // We don't update incomplete nodes with updates intended for other listeners\n        return oldViewCache;\n      }\n      const childChangePath = changePath.popFront();\n      const childNode = oldServerSnap.getNode().getImmediateChild(childKey);\n      const newChildNode = childNode.updateChild(childChangePath, changedSnap);\n      if (childKey == '.priority') {\n        newServerCache = serverFilter.updatePriority(\n          oldServerSnap.getNode(),\n          newChildNode\n        );\n      } else {\n        newServerCache = serverFilter.updateChild(\n          oldServerSnap.getNode(),\n          childKey,\n          newChildNode,\n          childChangePath,\n          NO_COMPLETE_CHILD_SOURCE,\n          null\n        );\n      }\n    }\n    const newViewCache = oldViewCache.updateServerSnap(\n      newServerCache,\n      oldServerSnap.isFullyInitialized() || changePath.isEmpty(),\n      serverFilter.filtersNodes()\n    );\n    const source = new WriteTreeCompleteChildSource(\n      writesCache,\n      newViewCache,\n      completeCache\n    );\n    return this.generateEventCacheAfterServerEvent_(\n      newViewCache,\n      changePath,\n      writesCache,\n      source,\n      accumulator\n    );\n  }\n\n  /**\n   * @param {!ViewCache} oldViewCache\n   * @param {!Path} changePath\n   * @param {!Node} changedSnap\n   * @param {!WriteTreeRef} writesCache\n   * @param {?Node} completeCache\n   * @param {!ChildChangeAccumulator} accumulator\n   * @return {!ViewCache}\n   * @private\n   */\n  applyUserOverwrite_(\n    oldViewCache: ViewCache,\n    changePath: Path,\n    changedSnap: Node,\n    writesCache: WriteTreeRef,\n    completeCache: Node | null,\n    accumulator: ChildChangeAccumulator\n  ): ViewCache {\n    const oldEventSnap = oldViewCache.getEventCache();\n    let newViewCache, newEventCache;\n    const source = new WriteTreeCompleteChildSource(\n      writesCache,\n      oldViewCache,\n      completeCache\n    );\n    if (changePath.isEmpty()) {\n      newEventCache = this.filter_.updateFullNode(\n        oldViewCache.getEventCache().getNode(),\n        changedSnap,\n        accumulator\n      );\n      newViewCache = oldViewCache.updateEventSnap(\n        newEventCache,\n        true,\n        this.filter_.filtersNodes()\n      );\n    } else {\n      const childKey = changePath.getFront();\n      if (childKey === '.priority') {\n        newEventCache = this.filter_.updatePriority(\n          oldViewCache.getEventCache().getNode(),\n          changedSnap\n        );\n        newViewCache = oldViewCache.updateEventSnap(\n          newEventCache,\n          oldEventSnap.isFullyInitialized(),\n          oldEventSnap.isFiltered()\n        );\n      } else {\n        const childChangePath = changePath.popFront();\n        const oldChild = oldEventSnap.getNode().getImmediateChild(childKey);\n        let newChild;\n        if (childChangePath.isEmpty()) {\n          // Child overwrite, we can replace the child\n          newChild = changedSnap;\n        } else {\n          const childNode = source.getCompleteChild(childKey);\n          if (childNode != null) {\n            if (\n              childChangePath.getBack() === '.priority' &&\n              childNode.getChild(childChangePath.parent()).isEmpty()\n            ) {\n              // This is a priority update on an empty node. If this node exists on the server, the\n              // server will send down the priority in the update, so ignore for now\n              newChild = childNode;\n            } else {\n              newChild = childNode.updateChild(childChangePath, changedSnap);\n            }\n          } else {\n            // There is no complete child node available\n            newChild = ChildrenNode.EMPTY_NODE;\n          }\n        }\n        if (!oldChild.equals(newChild)) {\n          const newEventSnap = this.filter_.updateChild(\n            oldEventSnap.getNode(),\n            childKey,\n            newChild,\n            childChangePath,\n            source,\n            accumulator\n          );\n          newViewCache = oldViewCache.updateEventSnap(\n            newEventSnap,\n            oldEventSnap.isFullyInitialized(),\n            this.filter_.filtersNodes()\n          );\n        } else {\n          newViewCache = oldViewCache;\n        }\n      }\n    }\n    return newViewCache;\n  }\n\n  /**\n   * @param {!ViewCache} viewCache\n   * @param {string} childKey\n   * @return {boolean}\n   * @private\n   */\n  private static cacheHasChild_(\n    viewCache: ViewCache,\n    childKey: string\n  ): boolean {\n    return viewCache.getEventCache().isCompleteForChild(childKey);\n  }\n\n  /**\n   * @param {!ViewCache} viewCache\n   * @param {!Path} path\n   * @param {ImmutableTree.<!Node>} changedChildren\n   * @param {!WriteTreeRef} writesCache\n   * @param {?Node} serverCache\n   * @param {!ChildChangeAccumulator} accumulator\n   * @return {!ViewCache}\n   * @private\n   */\n  private applyUserMerge_(\n    viewCache: ViewCache,\n    path: Path,\n    changedChildren: ImmutableTree<Node>,\n    writesCache: WriteTreeRef,\n    serverCache: Node | null,\n    accumulator: ChildChangeAccumulator\n  ): ViewCache {\n    // HACK: In the case of a limit query, there may be some changes that bump things out of the\n    // window leaving room for new items.  It's important we process these changes first, so we\n    // iterate the changes twice, first processing any that affect items currently in view.\n    // TODO: I consider an item \"in view\" if cacheHasChild is true, which checks both the server\n    // and event snap.  I'm not sure if this will result in edge cases when a child is in one but\n    // not the other.\n    let curViewCache = viewCache;\n    changedChildren.foreach((relativePath, childNode) => {\n      const writePath = path.child(relativePath);\n      if (ViewProcessor.cacheHasChild_(viewCache, writePath.getFront())) {\n        curViewCache = this.applyUserOverwrite_(\n          curViewCache,\n          writePath,\n          childNode,\n          writesCache,\n          serverCache,\n          accumulator\n        );\n      }\n    });\n\n    changedChildren.foreach((relativePath, childNode) => {\n      const writePath = path.child(relativePath);\n      if (!ViewProcessor.cacheHasChild_(viewCache, writePath.getFront())) {\n        curViewCache = this.applyUserOverwrite_(\n          curViewCache,\n          writePath,\n          childNode,\n          writesCache,\n          serverCache,\n          accumulator\n        );\n      }\n    });\n\n    return curViewCache;\n  }\n\n  /**\n   * @param {!Node} node\n   * @param {ImmutableTree.<!Node>} merge\n   * @return {!Node}\n   * @private\n   */\n  private applyMerge_(node: Node, merge: ImmutableTree<Node>): Node {\n    merge.foreach(function(relativePath, childNode) {\n      node = node.updateChild(relativePath, childNode);\n    });\n    return node;\n  }\n\n  /**\n   * @param {!ViewCache} viewCache\n   * @param {!Path} path\n   * @param {!ImmutableTree.<!Node>} changedChildren\n   * @param {!WriteTreeRef} writesCache\n   * @param {?Node} serverCache\n   * @param {boolean} filterServerNode\n   * @param {!ChildChangeAccumulator} accumulator\n   * @return {!ViewCache}\n   * @private\n   */\n  private applyServerMerge_(\n    viewCache: ViewCache,\n    path: Path,\n    changedChildren: ImmutableTree<Node>,\n    writesCache: WriteTreeRef,\n    serverCache: Node | null,\n    filterServerNode: boolean,\n    accumulator: ChildChangeAccumulator\n  ): ViewCache {\n    // If we don't have a cache yet, this merge was intended for a previously listen in the same location. Ignore it and\n    // wait for the complete data update coming soon.\n    if (\n      viewCache.getServerCache().getNode().isEmpty() &&\n      !viewCache.getServerCache().isFullyInitialized()\n    ) {\n      return viewCache;\n    }\n\n    // HACK: In the case of a limit query, there may be some changes that bump things out of the\n    // window leaving room for new items.  It's important we process these changes first, so we\n    // iterate the changes twice, first processing any that affect items currently in view.\n    // TODO: I consider an item \"in view\" if cacheHasChild is true, which checks both the server\n    // and event snap.  I'm not sure if this will result in edge cases when a child is in one but\n    // not the other.\n    let curViewCache = viewCache;\n    let viewMergeTree;\n    if (path.isEmpty()) {\n      viewMergeTree = changedChildren;\n    } else {\n      viewMergeTree = ImmutableTree.Empty.setTree(path, changedChildren);\n    }\n    const serverNode = viewCache.getServerCache().getNode();\n    viewMergeTree.children.inorderTraversal((childKey, childTree) => {\n      if (serverNode.hasChild(childKey)) {\n        const serverChild = viewCache\n          .getServerCache()\n          .getNode()\n          .getImmediateChild(childKey);\n        const newChild = this.applyMerge_(serverChild, childTree);\n        curViewCache = this.applyServerOverwrite_(\n          curViewCache,\n          new Path(childKey),\n          newChild,\n          writesCache,\n          serverCache,\n          filterServerNode,\n          accumulator\n        );\n      }\n    });\n    viewMergeTree.children.inorderTraversal((childKey, childMergeTree) => {\n      const isUnknownDeepMerge =\n        !viewCache.getServerCache().isCompleteForChild(childKey) &&\n        childMergeTree.value == null;\n      if (!serverNode.hasChild(childKey) && !isUnknownDeepMerge) {\n        const serverChild = viewCache\n          .getServerCache()\n          .getNode()\n          .getImmediateChild(childKey);\n        const newChild = this.applyMerge_(serverChild, childMergeTree);\n        curViewCache = this.applyServerOverwrite_(\n          curViewCache,\n          new Path(childKey),\n          newChild,\n          writesCache,\n          serverCache,\n          filterServerNode,\n          accumulator\n        );\n      }\n    });\n\n    return curViewCache;\n  }\n\n  /**\n   * @param {!ViewCache} viewCache\n   * @param {!Path} ackPath\n   * @param {!ImmutableTree<!boolean>} affectedTree\n   * @param {!WriteTreeRef} writesCache\n   * @param {?Node} completeCache\n   * @param {!ChildChangeAccumulator} accumulator\n   * @return {!ViewCache}\n   * @private\n   */\n  private ackUserWrite_(\n    viewCache: ViewCache,\n    ackPath: Path,\n    affectedTree: ImmutableTree<boolean>,\n    writesCache: WriteTreeRef,\n    completeCache: Node | null,\n    accumulator: ChildChangeAccumulator\n  ): ViewCache {\n    if (writesCache.shadowingWrite(ackPath) != null) {\n      return viewCache;\n    }\n\n    // Only filter server node if it is currently filtered\n    const filterServerNode = viewCache.getServerCache().isFiltered();\n\n    // Essentially we'll just get our existing server cache for the affected paths and re-apply it as a server update\n    // now that it won't be shadowed.\n    const serverCache = viewCache.getServerCache();\n    if (affectedTree.value != null) {\n      // This is an overwrite.\n      if (\n        (ackPath.isEmpty() && serverCache.isFullyInitialized()) ||\n        serverCache.isCompleteForPath(ackPath)\n      ) {\n        return this.applyServerOverwrite_(\n          viewCache,\n          ackPath,\n          serverCache.getNode().getChild(ackPath),\n          writesCache,\n          completeCache,\n          filterServerNode,\n          accumulator\n        );\n      } else if (ackPath.isEmpty()) {\n        // This is a goofy edge case where we are acking data at this location but don't have full data.  We\n        // should just re-apply whatever we have in our cache as a merge.\n        let changedChildren = ImmutableTree.Empty;\n        serverCache.getNode().forEachChild(KEY_INDEX, function(name, node) {\n          changedChildren = changedChildren.set(new Path(name), node);\n        });\n        return this.applyServerMerge_(\n          viewCache,\n          ackPath,\n          changedChildren,\n          writesCache,\n          completeCache,\n          filterServerNode,\n          accumulator\n        );\n      } else {\n        return viewCache;\n      }\n    } else {\n      // This is a merge.\n      let changedChildren = ImmutableTree.Empty;\n      affectedTree.foreach(function(mergePath, value) {\n        const serverCachePath = ackPath.child(mergePath);\n        if (serverCache.isCompleteForPath(serverCachePath)) {\n          changedChildren = changedChildren.set(\n            mergePath,\n            serverCache.getNode().getChild(serverCachePath)\n          );\n        }\n      });\n      return this.applyServerMerge_(\n        viewCache,\n        ackPath,\n        changedChildren,\n        writesCache,\n        completeCache,\n        filterServerNode,\n        accumulator\n      );\n    }\n  }\n\n  /**\n   * @param {!ViewCache} viewCache\n   * @param {!Path} path\n   * @param {!WriteTreeRef} writesCache\n   * @param {!ChildChangeAccumulator} accumulator\n   * @return {!ViewCache}\n   * @private\n   */\n  private listenComplete_(\n    viewCache: ViewCache,\n    path: Path,\n    writesCache: WriteTreeRef,\n    accumulator: ChildChangeAccumulator\n  ): ViewCache {\n    const oldServerNode = viewCache.getServerCache();\n    const newViewCache = viewCache.updateServerSnap(\n      oldServerNode.getNode(),\n      oldServerNode.isFullyInitialized() || path.isEmpty(),\n      oldServerNode.isFiltered()\n    );\n    return this.generateEventCacheAfterServerEvent_(\n      newViewCache,\n      path,\n      writesCache,\n      NO_COMPLETE_CHILD_SOURCE,\n      accumulator\n    );\n  }\n\n  /**\n   * @param {!ViewCache} viewCache\n   * @param {!Path} path\n   * @param {!WriteTreeRef} writesCache\n   * @param {?Node} completeServerCache\n   * @param {!ChildChangeAccumulator} accumulator\n   * @return {!ViewCache}\n   * @private\n   */\n  private revertUserWrite_(\n    viewCache: ViewCache,\n    path: Path,\n    writesCache: WriteTreeRef,\n    completeServerCache: Node | null,\n    accumulator: ChildChangeAccumulator\n  ): ViewCache {\n    let complete;\n    if (writesCache.shadowingWrite(path) != null) {\n      return viewCache;\n    } else {\n      const source = new WriteTreeCompleteChildSource(\n        writesCache,\n        viewCache,\n        completeServerCache\n      );\n      const oldEventCache = viewCache.getEventCache().getNode();\n      let newEventCache;\n      if (path.isEmpty() || path.getFront() === '.priority') {\n        let newNode;\n        if (viewCache.getServerCache().isFullyInitialized()) {\n          newNode = writesCache.calcCompleteEventCache(\n            viewCache.getCompleteServerSnap()\n          );\n        } else {\n          const serverChildren = viewCache.getServerCache().getNode();\n          assert(\n            serverChildren instanceof ChildrenNode,\n            'serverChildren would be complete if leaf node'\n          );\n          newNode = writesCache.calcCompleteEventChildren(\n            serverChildren as ChildrenNode\n          );\n        }\n        newNode = newNode as Node;\n        newEventCache = this.filter_.updateFullNode(\n          oldEventCache,\n          newNode,\n          accumulator\n        );\n      } else {\n        const childKey = path.getFront();\n        let newChild = writesCache.calcCompleteChild(\n          childKey,\n          viewCache.getServerCache()\n        );\n        if (\n          newChild == null &&\n          viewCache.getServerCache().isCompleteForChild(childKey)\n        ) {\n          newChild = oldEventCache.getImmediateChild(childKey);\n        }\n        if (newChild != null) {\n          newEventCache = this.filter_.updateChild(\n            oldEventCache,\n            childKey,\n            newChild,\n            path.popFront(),\n            source,\n            accumulator\n          );\n        } else if (viewCache.getEventCache().getNode().hasChild(childKey)) {\n          // No complete child available, delete the existing one, if any\n          newEventCache = this.filter_.updateChild(\n            oldEventCache,\n            childKey,\n            ChildrenNode.EMPTY_NODE,\n            path.popFront(),\n            source,\n            accumulator\n          );\n        } else {\n          newEventCache = oldEventCache;\n        }\n        if (\n          newEventCache.isEmpty() &&\n          viewCache.getServerCache().isFullyInitialized()\n        ) {\n          // We might have reverted all child writes. Maybe the old event was a leaf node\n          complete = writesCache.calcCompleteEventCache(\n            viewCache.getCompleteServerSnap()\n          );\n          if (complete.isLeafNode()) {\n            newEventCache = this.filter_.updateFullNode(\n              newEventCache,\n              complete,\n              accumulator\n            );\n          }\n        }\n      }\n      complete =\n        viewCache.getServerCache().isFullyInitialized() ||\n        writesCache.shadowingWrite(Path.Empty) != null;\n      return viewCache.updateEventSnap(\n        newEventCache,\n        complete,\n        this.filter_.filtersNodes()\n      );\n    }\n  }\n}\n","/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\nimport { OperationType } from '../operation/Operation';\nimport { assert, assertionError } from '../../../utils/assert';\nimport { ChildChangeAccumulator } from './ChildChangeAccumulator';\nimport { Change } from './Change';\nimport { ChildrenNode } from '../snap/ChildrenNode';\nimport { KEY_INDEX } from '../snap/indexes/KeyIndex';\nimport { ImmutableTree } from '../util/ImmutableTree';\nimport { Path } from '../util/Path';\nimport { WriteTreeCompleteChildSource, NO_COMPLETE_CHILD_SOURCE } from './CompleteChildSource';\n/**\n * @constructor\n * @struct\n */\nvar ProcessorResult = (function () {\n    /**\n     * @param {!ViewCache} viewCache\n     * @param {!Array.<!Change>} changes\n     */\n    function ProcessorResult(viewCache, changes) {\n        this.viewCache = viewCache;\n        this.changes = changes;\n    }\n    return ProcessorResult;\n}());\nexport { ProcessorResult };\n/**\n * @constructor\n */\nvar ViewProcessor = (function () {\n    /**\n     * @param {!NodeFilter} filter_\n     */\n    function ViewProcessor(filter_) {\n        this.filter_ = filter_;\n    }\n    /**\n     * @param {!ViewCache} viewCache\n     */\n    ViewProcessor.prototype.assertIndexed = function (viewCache) {\n        assert(viewCache.getEventCache().getNode().isIndexed(this.filter_.getIndex()), 'Event snap not indexed');\n        assert(viewCache.getServerCache().getNode().isIndexed(this.filter_.getIndex()), 'Server snap not indexed');\n    };\n    /**\n     * @param {!ViewCache} oldViewCache\n     * @param {!Operation} operation\n     * @param {!WriteTreeRef} writesCache\n     * @param {?Node} completeCache\n     * @return {!ProcessorResult}\n     */\n    ViewProcessor.prototype.applyOperation = function (oldViewCache, operation, writesCache, completeCache) {\n        var accumulator = new ChildChangeAccumulator();\n        var newViewCache, filterServerNode;\n        if (operation.type === OperationType.OVERWRITE) {\n            var overwrite = operation;\n            if (overwrite.source.fromUser) {\n                newViewCache = this.applyUserOverwrite_(oldViewCache, overwrite.path, overwrite.snap, writesCache, completeCache, accumulator);\n            }\n            else {\n                assert(overwrite.source.fromServer, 'Unknown source.');\n                // We filter the node if it's a tagged update or the node has been previously filtered  and the\n                // update is not at the root in which case it is ok (and necessary) to mark the node unfiltered\n                // again\n                filterServerNode =\n                    overwrite.source.tagged ||\n                        (oldViewCache.getServerCache().isFiltered() &&\n                            !overwrite.path.isEmpty());\n                newViewCache = this.applyServerOverwrite_(oldViewCache, overwrite.path, overwrite.snap, writesCache, completeCache, filterServerNode, accumulator);\n            }\n        }\n        else if (operation.type === OperationType.MERGE) {\n            var merge = operation;\n            if (merge.source.fromUser) {\n                newViewCache = this.applyUserMerge_(oldViewCache, merge.path, merge.children, writesCache, completeCache, accumulator);\n            }\n            else {\n                assert(merge.source.fromServer, 'Unknown source.');\n                // We filter the node if it's a tagged update or the node has been previously filtered\n                filterServerNode =\n                    merge.source.tagged || oldViewCache.getServerCache().isFiltered();\n                newViewCache = this.applyServerMerge_(oldViewCache, merge.path, merge.children, writesCache, completeCache, filterServerNode, accumulator);\n            }\n        }\n        else if (operation.type === OperationType.ACK_USER_WRITE) {\n            var ackUserWrite = operation;\n            if (!ackUserWrite.revert) {\n                newViewCache = this.ackUserWrite_(oldViewCache, ackUserWrite.path, ackUserWrite.affectedTree, writesCache, completeCache, accumulator);\n            }\n            else {\n                newViewCache = this.revertUserWrite_(oldViewCache, ackUserWrite.path, writesCache, completeCache, accumulator);\n            }\n        }\n        else if (operation.type === OperationType.LISTEN_COMPLETE) {\n            newViewCache = this.listenComplete_(oldViewCache, operation.path, writesCache, accumulator);\n        }\n        else {\n            throw assertionError('Unknown operation type: ' + operation.type);\n        }\n        var changes = accumulator.getChanges();\n        ViewProcessor.maybeAddValueEvent_(oldViewCache, newViewCache, changes);\n        return new ProcessorResult(newViewCache, changes);\n    };\n    /**\n     * @param {!ViewCache} oldViewCache\n     * @param {!ViewCache} newViewCache\n     * @param {!Array.<!Change>} accumulator\n     * @private\n     */\n    ViewProcessor.maybeAddValueEvent_ = function (oldViewCache, newViewCache, accumulator) {\n        var eventSnap = newViewCache.getEventCache();\n        if (eventSnap.isFullyInitialized()) {\n            var isLeafOrEmpty = eventSnap.getNode().isLeafNode() || eventSnap.getNode().isEmpty();\n            var oldCompleteSnap = oldViewCache.getCompleteEventSnap();\n            if (accumulator.length > 0 ||\n                !oldViewCache.getEventCache().isFullyInitialized() ||\n                (isLeafOrEmpty &&\n                    !eventSnap.getNode().equals /** @type {!Node} */(oldCompleteSnap)) ||\n                !eventSnap.getNode().getPriority().equals(oldCompleteSnap.getPriority())) {\n                accumulator.push(Change.valueChange(\n                /** @type {!Node} */ newViewCache.getCompleteEventSnap()));\n            }\n        }\n    };\n    /**\n     * @param {!ViewCache} viewCache\n     * @param {!Path} changePath\n     * @param {!WriteTreeRef} writesCache\n     * @param {!CompleteChildSource} source\n     * @param {!ChildChangeAccumulator} accumulator\n     * @return {!ViewCache}\n     * @private\n     */\n    ViewProcessor.prototype.generateEventCacheAfterServerEvent_ = function (viewCache, changePath, writesCache, source, accumulator) {\n        var oldEventSnap = viewCache.getEventCache();\n        if (writesCache.shadowingWrite(changePath) != null) {\n            // we have a shadowing write, ignore changes\n            return viewCache;\n        }\n        else {\n            var newEventCache = void 0, serverNode = void 0;\n            if (changePath.isEmpty()) {\n                // TODO: figure out how this plays with \"sliding ack windows\"\n                assert(viewCache.getServerCache().isFullyInitialized(), 'If change path is empty, we must have complete server data');\n                if (viewCache.getServerCache().isFiltered()) {\n                    // We need to special case this, because we need to only apply writes to complete children, or\n                    // we might end up raising events for incomplete children. If the server data is filtered deep\n                    // writes cannot be guaranteed to be complete\n                    var serverCache = viewCache.getCompleteServerSnap();\n                    var completeChildren = serverCache instanceof ChildrenNode\n                        ? serverCache\n                        : ChildrenNode.EMPTY_NODE;\n                    var completeEventChildren = writesCache.calcCompleteEventChildren(completeChildren);\n                    newEventCache = this.filter_.updateFullNode(viewCache.getEventCache().getNode(), completeEventChildren, accumulator);\n                }\n                else {\n                    var completeNode = writesCache.calcCompleteEventCache(viewCache.getCompleteServerSnap());\n                    newEventCache = this.filter_.updateFullNode(viewCache.getEventCache().getNode(), completeNode, accumulator);\n                }\n            }\n            else {\n                var childKey = changePath.getFront();\n                if (childKey == '.priority') {\n                    assert(changePath.getLength() == 1, \"Can't have a priority with additional path components\");\n                    var oldEventNode = oldEventSnap.getNode();\n                    serverNode = viewCache.getServerCache().getNode();\n                    // we might have overwrites for this priority\n                    var updatedPriority = writesCache.calcEventCacheAfterServerOverwrite(changePath, oldEventNode, serverNode);\n                    if (updatedPriority != null) {\n                        newEventCache = this.filter_.updatePriority(oldEventNode, updatedPriority);\n                    }\n                    else {\n                        // priority didn't change, keep old node\n                        newEventCache = oldEventSnap.getNode();\n                    }\n                }\n                else {\n                    var childChangePath = changePath.popFront();\n                    // update child\n                    var newEventChild = void 0;\n                    if (oldEventSnap.isCompleteForChild(childKey)) {\n                        serverNode = viewCache.getServerCache().getNode();\n                        var eventChildUpdate = writesCache.calcEventCacheAfterServerOverwrite(changePath, oldEventSnap.getNode(), serverNode);\n                        if (eventChildUpdate != null) {\n                            newEventChild = oldEventSnap\n                                .getNode()\n                                .getImmediateChild(childKey)\n                                .updateChild(childChangePath, eventChildUpdate);\n                        }\n                        else {\n                            // Nothing changed, just keep the old child\n                            newEventChild = oldEventSnap\n                                .getNode()\n                                .getImmediateChild(childKey);\n                        }\n                    }\n                    else {\n                        newEventChild = writesCache.calcCompleteChild(childKey, viewCache.getServerCache());\n                    }\n                    if (newEventChild != null) {\n                        newEventCache = this.filter_.updateChild(oldEventSnap.getNode(), childKey, newEventChild, childChangePath, source, accumulator);\n                    }\n                    else {\n                        // no complete child available or no change\n                        newEventCache = oldEventSnap.getNode();\n                    }\n                }\n            }\n            return viewCache.updateEventSnap(newEventCache, oldEventSnap.isFullyInitialized() || changePath.isEmpty(), this.filter_.filtersNodes());\n        }\n    };\n    /**\n     * @param {!ViewCache} oldViewCache\n     * @param {!Path} changePath\n     * @param {!Node} changedSnap\n     * @param {!WriteTreeRef} writesCache\n     * @param {?Node} completeCache\n     * @param {boolean} filterServerNode\n     * @param {!ChildChangeAccumulator} accumulator\n     * @return {!ViewCache}\n     * @private\n     */\n    ViewProcessor.prototype.applyServerOverwrite_ = function (oldViewCache, changePath, changedSnap, writesCache, completeCache, filterServerNode, accumulator) {\n        var oldServerSnap = oldViewCache.getServerCache();\n        var newServerCache;\n        var serverFilter = filterServerNode\n            ? this.filter_\n            : this.filter_.getIndexedFilter();\n        if (changePath.isEmpty()) {\n            newServerCache = serverFilter.updateFullNode(oldServerSnap.getNode(), changedSnap, null);\n        }\n        else if (serverFilter.filtersNodes() && !oldServerSnap.isFiltered()) {\n            // we want to filter the server node, but we didn't filter the server node yet, so simulate a full update\n            var newServerNode = oldServerSnap\n                .getNode()\n                .updateChild(changePath, changedSnap);\n            newServerCache = serverFilter.updateFullNode(oldServerSnap.getNode(), newServerNode, null);\n        }\n        else {\n            var childKey = changePath.getFront();\n            if (!oldServerSnap.isCompleteForPath(changePath) &&\n                changePath.getLength() > 1) {\n                // We don't update incomplete nodes with updates intended for other listeners\n                return oldViewCache;\n            }\n            var childChangePath = changePath.popFront();\n            var childNode = oldServerSnap.getNode().getImmediateChild(childKey);\n            var newChildNode = childNode.updateChild(childChangePath, changedSnap);\n            if (childKey == '.priority') {\n                newServerCache = serverFilter.updatePriority(oldServerSnap.getNode(), newChildNode);\n            }\n            else {\n                newServerCache = serverFilter.updateChild(oldServerSnap.getNode(), childKey, newChildNode, childChangePath, NO_COMPLETE_CHILD_SOURCE, null);\n            }\n        }\n        var newViewCache = oldViewCache.updateServerSnap(newServerCache, oldServerSnap.isFullyInitialized() || changePath.isEmpty(), serverFilter.filtersNodes());\n        var source = new WriteTreeCompleteChildSource(writesCache, newViewCache, completeCache);\n        return this.generateEventCacheAfterServerEvent_(newViewCache, changePath, writesCache, source, accumulator);\n    };\n    /**\n     * @param {!ViewCache} oldViewCache\n     * @param {!Path} changePath\n     * @param {!Node} changedSnap\n     * @param {!WriteTreeRef} writesCache\n     * @param {?Node} completeCache\n     * @param {!ChildChangeAccumulator} accumulator\n     * @return {!ViewCache}\n     * @private\n     */\n    ViewProcessor.prototype.applyUserOverwrite_ = function (oldViewCache, changePath, changedSnap, writesCache, completeCache, accumulator) {\n        var oldEventSnap = oldViewCache.getEventCache();\n        var newViewCache, newEventCache;\n        var source = new WriteTreeCompleteChildSource(writesCache, oldViewCache, completeCache);\n        if (changePath.isEmpty()) {\n            newEventCache = this.filter_.updateFullNode(oldViewCache.getEventCache().getNode(), changedSnap, accumulator);\n            newViewCache = oldViewCache.updateEventSnap(newEventCache, true, this.filter_.filtersNodes());\n        }\n        else {\n            var childKey = changePath.getFront();\n            if (childKey === '.priority') {\n                newEventCache = this.filter_.updatePriority(oldViewCache.getEventCache().getNode(), changedSnap);\n                newViewCache = oldViewCache.updateEventSnap(newEventCache, oldEventSnap.isFullyInitialized(), oldEventSnap.isFiltered());\n            }\n            else {\n                var childChangePath = changePath.popFront();\n                var oldChild = oldEventSnap.getNode().getImmediateChild(childKey);\n                var newChild = void 0;\n                if (childChangePath.isEmpty()) {\n                    // Child overwrite, we can replace the child\n                    newChild = changedSnap;\n                }\n                else {\n                    var childNode = source.getCompleteChild(childKey);\n                    if (childNode != null) {\n                        if (childChangePath.getBack() === '.priority' &&\n                            childNode.getChild(childChangePath.parent()).isEmpty()) {\n                            // This is a priority update on an empty node. If this node exists on the server, the\n                            // server will send down the priority in the update, so ignore for now\n                            newChild = childNode;\n                        }\n                        else {\n                            newChild = childNode.updateChild(childChangePath, changedSnap);\n                        }\n                    }\n                    else {\n                        // There is no complete child node available\n                        newChild = ChildrenNode.EMPTY_NODE;\n                    }\n                }\n                if (!oldChild.equals(newChild)) {\n                    var newEventSnap = this.filter_.updateChild(oldEventSnap.getNode(), childKey, newChild, childChangePath, source, accumulator);\n                    newViewCache = oldViewCache.updateEventSnap(newEventSnap, oldEventSnap.isFullyInitialized(), this.filter_.filtersNodes());\n                }\n                else {\n                    newViewCache = oldViewCache;\n                }\n            }\n        }\n        return newViewCache;\n    };\n    /**\n     * @param {!ViewCache} viewCache\n     * @param {string} childKey\n     * @return {boolean}\n     * @private\n     */\n    ViewProcessor.cacheHasChild_ = function (viewCache, childKey) {\n        return viewCache.getEventCache().isCompleteForChild(childKey);\n    };\n    /**\n     * @param {!ViewCache} viewCache\n     * @param {!Path} path\n     * @param {ImmutableTree.<!Node>} changedChildren\n     * @param {!WriteTreeRef} writesCache\n     * @param {?Node} serverCache\n     * @param {!ChildChangeAccumulator} accumulator\n     * @return {!ViewCache}\n     * @private\n     */\n    ViewProcessor.prototype.applyUserMerge_ = function (viewCache, path, changedChildren, writesCache, serverCache, accumulator) {\n        var _this = this;\n        // HACK: In the case of a limit query, there may be some changes that bump things out of the\n        // window leaving room for new items.  It's important we process these changes first, so we\n        // iterate the changes twice, first processing any that affect items currently in view.\n        // TODO: I consider an item \"in view\" if cacheHasChild is true, which checks both the server\n        // and event snap.  I'm not sure if this will result in edge cases when a child is in one but\n        // not the other.\n        var curViewCache = viewCache;\n        changedChildren.foreach(function (relativePath, childNode) {\n            var writePath = path.child(relativePath);\n            if (ViewProcessor.cacheHasChild_(viewCache, writePath.getFront())) {\n                curViewCache = _this.applyUserOverwrite_(curViewCache, writePath, childNode, writesCache, serverCache, accumulator);\n            }\n        });\n        changedChildren.foreach(function (relativePath, childNode) {\n            var writePath = path.child(relativePath);\n            if (!ViewProcessor.cacheHasChild_(viewCache, writePath.getFront())) {\n                curViewCache = _this.applyUserOverwrite_(curViewCache, writePath, childNode, writesCache, serverCache, accumulator);\n            }\n        });\n        return curViewCache;\n    };\n    /**\n     * @param {!Node} node\n     * @param {ImmutableTree.<!Node>} merge\n     * @return {!Node}\n     * @private\n     */\n    ViewProcessor.prototype.applyMerge_ = function (node, merge) {\n        merge.foreach(function (relativePath, childNode) {\n            node = node.updateChild(relativePath, childNode);\n        });\n        return node;\n    };\n    /**\n     * @param {!ViewCache} viewCache\n     * @param {!Path} path\n     * @param {!ImmutableTree.<!Node>} changedChildren\n     * @param {!WriteTreeRef} writesCache\n     * @param {?Node} serverCache\n     * @param {boolean} filterServerNode\n     * @param {!ChildChangeAccumulator} accumulator\n     * @return {!ViewCache}\n     * @private\n     */\n    ViewProcessor.prototype.applyServerMerge_ = function (viewCache, path, changedChildren, writesCache, serverCache, filterServerNode, accumulator) {\n        var _this = this;\n        // If we don't have a cache yet, this merge was intended for a previously listen in the same location. Ignore it and\n        // wait for the complete data update coming soon.\n        if (viewCache.getServerCache().getNode().isEmpty() &&\n            !viewCache.getServerCache().isFullyInitialized()) {\n            return viewCache;\n        }\n        // HACK: In the case of a limit query, there may be some changes that bump things out of the\n        // window leaving room for new items.  It's important we process these changes first, so we\n        // iterate the changes twice, first processing any that affect items currently in view.\n        // TODO: I consider an item \"in view\" if cacheHasChild is true, which checks both the server\n        // and event snap.  I'm not sure if this will result in edge cases when a child is in one but\n        // not the other.\n        var curViewCache = viewCache;\n        var viewMergeTree;\n        if (path.isEmpty()) {\n            viewMergeTree = changedChildren;\n        }\n        else {\n            viewMergeTree = ImmutableTree.Empty.setTree(path, changedChildren);\n        }\n        var serverNode = viewCache.getServerCache().getNode();\n        viewMergeTree.children.inorderTraversal(function (childKey, childTree) {\n            if (serverNode.hasChild(childKey)) {\n                var serverChild = viewCache\n                    .getServerCache()\n                    .getNode()\n                    .getImmediateChild(childKey);\n                var newChild = _this.applyMerge_(serverChild, childTree);\n                curViewCache = _this.applyServerOverwrite_(curViewCache, new Path(childKey), newChild, writesCache, serverCache, filterServerNode, accumulator);\n            }\n        });\n        viewMergeTree.children.inorderTraversal(function (childKey, childMergeTree) {\n            var isUnknownDeepMerge = !viewCache.getServerCache().isCompleteForChild(childKey) &&\n                childMergeTree.value == null;\n            if (!serverNode.hasChild(childKey) && !isUnknownDeepMerge) {\n                var serverChild = viewCache\n                    .getServerCache()\n                    .getNode()\n                    .getImmediateChild(childKey);\n                var newChild = _this.applyMerge_(serverChild, childMergeTree);\n                curViewCache = _this.applyServerOverwrite_(curViewCache, new Path(childKey), newChild, writesCache, serverCache, filterServerNode, accumulator);\n            }\n        });\n        return curViewCache;\n    };\n    /**\n     * @param {!ViewCache} viewCache\n     * @param {!Path} ackPath\n     * @param {!ImmutableTree<!boolean>} affectedTree\n     * @param {!WriteTreeRef} writesCache\n     * @param {?Node} completeCache\n     * @param {!ChildChangeAccumulator} accumulator\n     * @return {!ViewCache}\n     * @private\n     */\n    ViewProcessor.prototype.ackUserWrite_ = function (viewCache, ackPath, affectedTree, writesCache, completeCache, accumulator) {\n        if (writesCache.shadowingWrite(ackPath) != null) {\n            return viewCache;\n        }\n        // Only filter server node if it is currently filtered\n        var filterServerNode = viewCache.getServerCache().isFiltered();\n        // Essentially we'll just get our existing server cache for the affected paths and re-apply it as a server update\n        // now that it won't be shadowed.\n        var serverCache = viewCache.getServerCache();\n        if (affectedTree.value != null) {\n            // This is an overwrite.\n            if ((ackPath.isEmpty() && serverCache.isFullyInitialized()) ||\n                serverCache.isCompleteForPath(ackPath)) {\n                return this.applyServerOverwrite_(viewCache, ackPath, serverCache.getNode().getChild(ackPath), writesCache, completeCache, filterServerNode, accumulator);\n            }\n            else if (ackPath.isEmpty()) {\n                // This is a goofy edge case where we are acking data at this location but don't have full data.  We\n                // should just re-apply whatever we have in our cache as a merge.\n                var changedChildren_1 = ImmutableTree.Empty;\n                serverCache.getNode().forEachChild(KEY_INDEX, function (name, node) {\n                    changedChildren_1 = changedChildren_1.set(new Path(name), node);\n                });\n                return this.applyServerMerge_(viewCache, ackPath, changedChildren_1, writesCache, completeCache, filterServerNode, accumulator);\n            }\n            else {\n                return viewCache;\n            }\n        }\n        else {\n            // This is a merge.\n            var changedChildren_2 = ImmutableTree.Empty;\n            affectedTree.foreach(function (mergePath, value) {\n                var serverCachePath = ackPath.child(mergePath);\n                if (serverCache.isCompleteForPath(serverCachePath)) {\n                    changedChildren_2 = changedChildren_2.set(mergePath, serverCache.getNode().getChild(serverCachePath));\n                }\n            });\n            return this.applyServerMerge_(viewCache, ackPath, changedChildren_2, writesCache, completeCache, filterServerNode, accumulator);\n        }\n    };\n    /**\n     * @param {!ViewCache} viewCache\n     * @param {!Path} path\n     * @param {!WriteTreeRef} writesCache\n     * @param {!ChildChangeAccumulator} accumulator\n     * @return {!ViewCache}\n     * @private\n     */\n    ViewProcessor.prototype.listenComplete_ = function (viewCache, path, writesCache, accumulator) {\n        var oldServerNode = viewCache.getServerCache();\n        var newViewCache = viewCache.updateServerSnap(oldServerNode.getNode(), oldServerNode.isFullyInitialized() || path.isEmpty(), oldServerNode.isFiltered());\n        return this.generateEventCacheAfterServerEvent_(newViewCache, path, writesCache, NO_COMPLETE_CHILD_SOURCE, accumulator);\n    };\n    /**\n     * @param {!ViewCache} viewCache\n     * @param {!Path} path\n     * @param {!WriteTreeRef} writesCache\n     * @param {?Node} completeServerCache\n     * @param {!ChildChangeAccumulator} accumulator\n     * @return {!ViewCache}\n     * @private\n     */\n    ViewProcessor.prototype.revertUserWrite_ = function (viewCache, path, writesCache, completeServerCache, accumulator) {\n        var complete;\n        if (writesCache.shadowingWrite(path) != null) {\n            return viewCache;\n        }\n        else {\n            var source = new WriteTreeCompleteChildSource(writesCache, viewCache, completeServerCache);\n            var oldEventCache = viewCache.getEventCache().getNode();\n            var newEventCache = void 0;\n            if (path.isEmpty() || path.getFront() === '.priority') {\n                var newNode = void 0;\n                if (viewCache.getServerCache().isFullyInitialized()) {\n                    newNode = writesCache.calcCompleteEventCache(viewCache.getCompleteServerSnap());\n                }\n                else {\n                    var serverChildren = viewCache.getServerCache().getNode();\n                    assert(serverChildren instanceof ChildrenNode, 'serverChildren would be complete if leaf node');\n                    newNode = writesCache.calcCompleteEventChildren(serverChildren);\n                }\n                newNode = newNode;\n                newEventCache = this.filter_.updateFullNode(oldEventCache, newNode, accumulator);\n            }\n            else {\n                var childKey = path.getFront();\n                var newChild = writesCache.calcCompleteChild(childKey, viewCache.getServerCache());\n                if (newChild == null &&\n                    viewCache.getServerCache().isCompleteForChild(childKey)) {\n                    newChild = oldEventCache.getImmediateChild(childKey);\n                }\n                if (newChild != null) {\n                    newEventCache = this.filter_.updateChild(oldEventCache, childKey, newChild, path.popFront(), source, accumulator);\n                }\n                else if (viewCache.getEventCache().getNode().hasChild(childKey)) {\n                    // No complete child available, delete the existing one, if any\n                    newEventCache = this.filter_.updateChild(oldEventCache, childKey, ChildrenNode.EMPTY_NODE, path.popFront(), source, accumulator);\n                }\n                else {\n                    newEventCache = oldEventCache;\n                }\n                if (newEventCache.isEmpty() &&\n                    viewCache.getServerCache().isFullyInitialized()) {\n                    // We might have reverted all child writes. Maybe the old event was a leaf node\n                    complete = writesCache.calcCompleteEventCache(viewCache.getCompleteServerSnap());\n                    if (complete.isLeafNode()) {\n                        newEventCache = this.filter_.updateFullNode(newEventCache, complete, accumulator);\n                    }\n                }\n            }\n            complete =\n                viewCache.getServerCache().isFullyInitialized() ||\n                    writesCache.shadowingWrite(Path.Empty) != null;\n            return viewCache.updateEventSnap(newEventCache, complete, this.filter_.filtersNodes());\n        }\n    };\n    return ViewProcessor;\n}());\nexport { ViewProcessor };\n\n\n"]}