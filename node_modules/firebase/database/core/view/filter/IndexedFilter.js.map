{"version":3,"sources":["database/core/src/database/core/view/filter/IndexedFilter.ts","database/core/view/filter/IndexedFilter.js"],"names":["IndexedFilter","index_","prototype","updateChild","snap","key","newChild","affectedPath","source","optChangeAccumulator","isIndexed","oldChild","getImmediateChild","getChild","equals","isEmpty","hasChild","trackChildChange","childRemovedChange","isLeafNode","childAddedChange","childChangedChange","updateImmediateChild","withIndex","updateFullNode","oldSnap","newSnap","forEachChild","childNode","updatePriority","newPriority","EMPTY_NODE","filtersNodes","getIndexedFilter","getIndex"],"mappings":"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","file":"IndexedFilter.js","sourcesContent":["/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\nimport { assert } from '../../../../utils/assert';\nimport { Change } from '../Change';\nimport { ChildrenNode } from '../../snap/ChildrenNode';\nimport { PRIORITY_INDEX } from '../../snap/indexes/PriorityIndex';\nimport { NodeFilter } from './NodeFilter';\nimport { Index } from '../../snap/indexes/Index';\nimport { Path } from '../../util/Path';\nimport { CompleteChildSource } from '../CompleteChildSource';\nimport { ChildChangeAccumulator } from '../ChildChangeAccumulator';\nimport { Node } from '../../snap/Node';\n\n/**\n * Doesn't really filter nodes but applies an index to the node and keeps track of any changes\n *\n * @constructor\n * @implements {NodeFilter}\n * @param {!Index} index\n */\nexport class IndexedFilter implements NodeFilter {\n  constructor(private readonly index_: Index) {}\n\n  updateChild(\n    snap: Node,\n    key: string,\n    newChild: Node,\n    affectedPath: Path,\n    source: CompleteChildSource,\n    optChangeAccumulator: ChildChangeAccumulator | null\n  ): Node {\n    assert(\n      snap.isIndexed(this.index_),\n      'A node must be indexed if only a child is updated'\n    );\n    const oldChild = snap.getImmediateChild(key);\n    // Check if anything actually changed.\n    if (\n      oldChild.getChild(affectedPath).equals(newChild.getChild(affectedPath))\n    ) {\n      // There's an edge case where a child can enter or leave the view because affectedPath was set to null.\n      // In this case, affectedPath will appear null in both the old and new snapshots.  So we need\n      // to avoid treating these cases as \"nothing changed.\"\n      if (oldChild.isEmpty() == newChild.isEmpty()) {\n        // Nothing changed.\n\n        // This assert should be valid, but it's expensive (can dominate perf testing) so don't actually do it.\n        //assert(oldChild.equals(newChild), 'Old and new snapshots should be equal.');\n        return snap;\n      }\n    }\n\n    if (optChangeAccumulator != null) {\n      if (newChild.isEmpty()) {\n        if (snap.hasChild(key)) {\n          optChangeAccumulator.trackChildChange(\n            Change.childRemovedChange(key, oldChild)\n          );\n        } else {\n          assert(\n            snap.isLeafNode(),\n            'A child remove without an old child only makes sense on a leaf node'\n          );\n        }\n      } else if (oldChild.isEmpty()) {\n        optChangeAccumulator.trackChildChange(\n          Change.childAddedChange(key, newChild)\n        );\n      } else {\n        optChangeAccumulator.trackChildChange(\n          Change.childChangedChange(key, newChild, oldChild)\n        );\n      }\n    }\n    if (snap.isLeafNode() && newChild.isEmpty()) {\n      return snap;\n    } else {\n      // Make sure the node is indexed\n      return snap.updateImmediateChild(key, newChild).withIndex(this.index_);\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  updateFullNode(\n    oldSnap: Node,\n    newSnap: Node,\n    optChangeAccumulator: ChildChangeAccumulator | null\n  ): Node {\n    if (optChangeAccumulator != null) {\n      if (!oldSnap.isLeafNode()) {\n        oldSnap.forEachChild(PRIORITY_INDEX, function(key, childNode) {\n          if (!newSnap.hasChild(key)) {\n            optChangeAccumulator.trackChildChange(\n              Change.childRemovedChange(key, childNode)\n            );\n          }\n        });\n      }\n      if (!newSnap.isLeafNode()) {\n        newSnap.forEachChild(PRIORITY_INDEX, function(key, childNode) {\n          if (oldSnap.hasChild(key)) {\n            const oldChild = oldSnap.getImmediateChild(key);\n            if (!oldChild.equals(childNode)) {\n              optChangeAccumulator.trackChildChange(\n                Change.childChangedChange(key, childNode, oldChild)\n              );\n            }\n          } else {\n            optChangeAccumulator.trackChildChange(\n              Change.childAddedChange(key, childNode)\n            );\n          }\n        });\n      }\n    }\n    return newSnap.withIndex(this.index_);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  updatePriority(oldSnap: Node, newPriority: Node): Node {\n    if (oldSnap.isEmpty()) {\n      return ChildrenNode.EMPTY_NODE;\n    } else {\n      return oldSnap.updatePriority(newPriority);\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  filtersNodes(): boolean {\n    return false;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  getIndexedFilter(): IndexedFilter {\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  getIndex(): Index {\n    return this.index_;\n  }\n}\n","/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\nimport { assert } from '../../../../utils/assert';\nimport { Change } from '../Change';\nimport { ChildrenNode } from '../../snap/ChildrenNode';\nimport { PRIORITY_INDEX } from '../../snap/indexes/PriorityIndex';\n/**\n * Doesn't really filter nodes but applies an index to the node and keeps track of any changes\n *\n * @constructor\n * @implements {NodeFilter}\n * @param {!Index} index\n */\nvar IndexedFilter = (function () {\n    function IndexedFilter(index_) {\n        this.index_ = index_;\n    }\n    IndexedFilter.prototype.updateChild = function (snap, key, newChild, affectedPath, source, optChangeAccumulator) {\n        assert(snap.isIndexed(this.index_), 'A node must be indexed if only a child is updated');\n        var oldChild = snap.getImmediateChild(key);\n        // Check if anything actually changed.\n        if (oldChild.getChild(affectedPath).equals(newChild.getChild(affectedPath))) {\n            // There's an edge case where a child can enter or leave the view because affectedPath was set to null.\n            // In this case, affectedPath will appear null in both the old and new snapshots.  So we need\n            // to avoid treating these cases as \"nothing changed.\"\n            if (oldChild.isEmpty() == newChild.isEmpty()) {\n                // Nothing changed.\n                // This assert should be valid, but it's expensive (can dominate perf testing) so don't actually do it.\n                //assert(oldChild.equals(newChild), 'Old and new snapshots should be equal.');\n                return snap;\n            }\n        }\n        if (optChangeAccumulator != null) {\n            if (newChild.isEmpty()) {\n                if (snap.hasChild(key)) {\n                    optChangeAccumulator.trackChildChange(Change.childRemovedChange(key, oldChild));\n                }\n                else {\n                    assert(snap.isLeafNode(), 'A child remove without an old child only makes sense on a leaf node');\n                }\n            }\n            else if (oldChild.isEmpty()) {\n                optChangeAccumulator.trackChildChange(Change.childAddedChange(key, newChild));\n            }\n            else {\n                optChangeAccumulator.trackChildChange(Change.childChangedChange(key, newChild, oldChild));\n            }\n        }\n        if (snap.isLeafNode() && newChild.isEmpty()) {\n            return snap;\n        }\n        else {\n            // Make sure the node is indexed\n            return snap.updateImmediateChild(key, newChild).withIndex(this.index_);\n        }\n    };\n    /**\n     * @inheritDoc\n     */\n    IndexedFilter.prototype.updateFullNode = function (oldSnap, newSnap, optChangeAccumulator) {\n        if (optChangeAccumulator != null) {\n            if (!oldSnap.isLeafNode()) {\n                oldSnap.forEachChild(PRIORITY_INDEX, function (key, childNode) {\n                    if (!newSnap.hasChild(key)) {\n                        optChangeAccumulator.trackChildChange(Change.childRemovedChange(key, childNode));\n                    }\n                });\n            }\n            if (!newSnap.isLeafNode()) {\n                newSnap.forEachChild(PRIORITY_INDEX, function (key, childNode) {\n                    if (oldSnap.hasChild(key)) {\n                        var oldChild = oldSnap.getImmediateChild(key);\n                        if (!oldChild.equals(childNode)) {\n                            optChangeAccumulator.trackChildChange(Change.childChangedChange(key, childNode, oldChild));\n                        }\n                    }\n                    else {\n                        optChangeAccumulator.trackChildChange(Change.childAddedChange(key, childNode));\n                    }\n                });\n            }\n        }\n        return newSnap.withIndex(this.index_);\n    };\n    /**\n     * @inheritDoc\n     */\n    IndexedFilter.prototype.updatePriority = function (oldSnap, newPriority) {\n        if (oldSnap.isEmpty()) {\n            return ChildrenNode.EMPTY_NODE;\n        }\n        else {\n            return oldSnap.updatePriority(newPriority);\n        }\n    };\n    /**\n     * @inheritDoc\n     */\n    IndexedFilter.prototype.filtersNodes = function () {\n        return false;\n    };\n    /**\n     * @inheritDoc\n     */\n    IndexedFilter.prototype.getIndexedFilter = function () {\n        return this;\n    };\n    /**\n     * @inheritDoc\n     */\n    IndexedFilter.prototype.getIndex = function () {\n        return this.index_;\n    };\n    return IndexedFilter;\n}());\nexport { IndexedFilter };\n\n\n"]}