{"version":3,"sources":["database/core/src/database/core/view/filter/LimitedFilter.ts","database/core/view/filter/LimitedFilter.js"],"names":["LimitedFilter","params","rangedFilter_","index_","getIndex","limit_","getLimit","reverse_","isViewFromLeft","prototype","updateChild","snap","key","newChild","affectedPath","source","optChangeAccumulator","matches","EMPTY_NODE","getImmediateChild","equals","numChildren","getIndexedFilter","fullLimitUpdateChild_","updateFullNode","oldSnap","newSnap","filtered","isLeafNode","isEmpty","withIndex","isIndexed","iterator","getReverseIteratorFrom","getEndPost","getIteratorFrom","getStartPost","count","hasNext","next","getNext","inRange","compare","updateImmediateChild","name","node","updatePriority","startPost","endPost","cmp","getReverseIterator","indexCompare_1","getCompare","a","b","getIterator","foundStartPost","newPriority","filtersNodes","childKey","childSnap","changeAccumulator","indexCmp_1","oldEventCache","newChildNamedNode","windowBoundary","getFirstChild","getLastChild","hasChild","oldChildSnap","nextChild","getChildAfterChild","compareNext","remainsInWindow","trackChildChange","childChangedChange","childRemovedChange","newEventCache","nextChildInRange","childAddedChange"],"mappings":"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","file":"LimitedFilter.js","sourcesContent":["/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\nimport { RangedFilter } from './RangedFilter';\nimport { ChildrenNode } from '../../snap/ChildrenNode';\nimport { Node, NamedNode } from '../../snap/Node';\nimport { assert } from '../../../../utils/assert';\nimport { Change } from '../Change';\nimport { NodeFilter } from './NodeFilter';\nimport { Index } from '../../snap/indexes/Index';\nimport { IndexedFilter } from './IndexedFilter';\nimport { QueryParams } from '../QueryParams';\nimport { Path } from '../../util/Path';\nimport { CompleteChildSource } from '../CompleteChildSource';\nimport { ChildChangeAccumulator } from '../ChildChangeAccumulator';\n\n/**\n * Applies a limit and a range to a node and uses RangedFilter to do the heavy lifting where possible\n *\n * @constructor\n * @implements {NodeFilter}\n */\nexport class LimitedFilter implements NodeFilter {\n  /**\n   * @const\n   * @type {RangedFilter}\n   * @private\n   */\n  private readonly rangedFilter_: RangedFilter;\n\n  /**\n   * @const\n   * @type {!Index}\n   * @private\n   */\n  private readonly index_: Index;\n\n  /**\n   * @const\n   * @type {number}\n   * @private\n   */\n  private readonly limit_: number;\n\n  /**\n   * @const\n   * @type {boolean}\n   * @private\n   */\n  private readonly reverse_: boolean;\n\n  /**\n   * @param {!QueryParams} params\n   */\n  constructor(params: QueryParams) {\n    this.rangedFilter_ = new RangedFilter(params);\n    this.index_ = params.getIndex();\n    this.limit_ = params.getLimit();\n    this.reverse_ = !params.isViewFromLeft();\n  }\n\n  /**\n   * @inheritDoc\n   */\n  updateChild(\n    snap: Node,\n    key: string,\n    newChild: Node,\n    affectedPath: Path,\n    source: CompleteChildSource,\n    optChangeAccumulator: ChildChangeAccumulator | null\n  ): Node {\n    if (!this.rangedFilter_.matches(new NamedNode(key, newChild))) {\n      newChild = ChildrenNode.EMPTY_NODE;\n    }\n    if (snap.getImmediateChild(key).equals(newChild)) {\n      // No change\n      return snap;\n    } else if (snap.numChildren() < this.limit_) {\n      return this.rangedFilter_\n        .getIndexedFilter()\n        .updateChild(\n          snap,\n          key,\n          newChild,\n          affectedPath,\n          source,\n          optChangeAccumulator\n        );\n    } else {\n      return this.fullLimitUpdateChild_(\n        snap,\n        key,\n        newChild,\n        source,\n        optChangeAccumulator\n      );\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  updateFullNode(\n    oldSnap: Node,\n    newSnap: Node,\n    optChangeAccumulator: ChildChangeAccumulator | null\n  ): Node {\n    let filtered;\n    if (newSnap.isLeafNode() || newSnap.isEmpty()) {\n      // Make sure we have a children node with the correct index, not a leaf node;\n      filtered = ChildrenNode.EMPTY_NODE.withIndex(this.index_);\n    } else {\n      if (\n        this.limit_ * 2 < newSnap.numChildren() &&\n        newSnap.isIndexed(this.index_)\n      ) {\n        // Easier to build up a snapshot, since what we're given has more than twice the elements we want\n        filtered = ChildrenNode.EMPTY_NODE.withIndex(this.index_);\n        // anchor to the startPost, endPost, or last element as appropriate\n        let iterator;\n        if (this.reverse_) {\n          iterator = (newSnap as ChildrenNode).getReverseIteratorFrom(\n            this.rangedFilter_.getEndPost(),\n            this.index_\n          );\n        } else {\n          iterator = (newSnap as ChildrenNode).getIteratorFrom(\n            this.rangedFilter_.getStartPost(),\n            this.index_\n          );\n        }\n        let count = 0;\n        while (iterator.hasNext() && count < this.limit_) {\n          const next = iterator.getNext();\n          let inRange;\n          if (this.reverse_) {\n            inRange =\n              this.index_.compare(this.rangedFilter_.getStartPost(), next) <= 0;\n          } else {\n            inRange =\n              this.index_.compare(next, this.rangedFilter_.getEndPost()) <= 0;\n          }\n          if (inRange) {\n            filtered = filtered.updateImmediateChild(next.name, next.node);\n            count++;\n          } else {\n            // if we have reached the end post, we cannot keep adding elemments\n            break;\n          }\n        }\n      } else {\n        // The snap contains less than twice the limit. Faster to delete from the snap than build up a new one\n        filtered = newSnap.withIndex(this.index_);\n        // Don't support priorities on queries\n        filtered = filtered.updatePriority(\n          ChildrenNode.EMPTY_NODE\n        ) as ChildrenNode;\n        let startPost;\n        let endPost;\n        let cmp;\n        let iterator;\n        if (this.reverse_) {\n          iterator = filtered.getReverseIterator(this.index_);\n          startPost = this.rangedFilter_.getEndPost();\n          endPost = this.rangedFilter_.getStartPost();\n          const indexCompare = this.index_.getCompare();\n          cmp = (a: NamedNode, b: NamedNode) => indexCompare(b, a);\n        } else {\n          iterator = filtered.getIterator(this.index_);\n          startPost = this.rangedFilter_.getStartPost();\n          endPost = this.rangedFilter_.getEndPost();\n          cmp = this.index_.getCompare();\n        }\n\n        let count = 0;\n        let foundStartPost = false;\n        while (iterator.hasNext()) {\n          let next = iterator.getNext();\n          if (!foundStartPost && cmp(startPost, next) <= 0) {\n            // start adding\n            foundStartPost = true;\n          }\n          let inRange =\n            foundStartPost && count < this.limit_ && cmp(next, endPost) <= 0;\n          if (inRange) {\n            count++;\n          } else {\n            filtered = filtered.updateImmediateChild(\n              next.name,\n              ChildrenNode.EMPTY_NODE\n            );\n          }\n        }\n      }\n    }\n    return this.rangedFilter_\n      .getIndexedFilter()\n      .updateFullNode(oldSnap, filtered, optChangeAccumulator);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  updatePriority(oldSnap: Node, newPriority: Node): Node {\n    // Don't support priorities on queries\n    return oldSnap;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  filtersNodes(): boolean {\n    return true;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  getIndexedFilter(): IndexedFilter {\n    return this.rangedFilter_.getIndexedFilter();\n  }\n\n  /**\n   * @inheritDoc\n   */\n  getIndex(): Index {\n    return this.index_;\n  }\n\n  /**\n   * @param {!Node} snap\n   * @param {string} childKey\n   * @param {!Node} childSnap\n   * @param {!CompleteChildSource} source\n   * @param {?ChildChangeAccumulator} changeAccumulator\n   * @return {!Node}\n   * @private\n   */\n  private fullLimitUpdateChild_(\n    snap: Node,\n    childKey: string,\n    childSnap: Node,\n    source: CompleteChildSource,\n    changeAccumulator: ChildChangeAccumulator | null\n  ): Node {\n    // TODO: rename all cache stuff etc to general snap terminology\n    let cmp;\n    if (this.reverse_) {\n      const indexCmp = this.index_.getCompare();\n      cmp = (a: NamedNode, b: NamedNode) => indexCmp(b, a);\n    } else {\n      cmp = this.index_.getCompare();\n    }\n    const oldEventCache = snap as ChildrenNode;\n    assert(oldEventCache.numChildren() == this.limit_, '');\n    const newChildNamedNode = new NamedNode(childKey, childSnap);\n    const windowBoundary = this.reverse_\n      ? oldEventCache.getFirstChild(this.index_)\n      : oldEventCache.getLastChild(this.index_) as NamedNode;\n    const inRange = this.rangedFilter_.matches(newChildNamedNode);\n    if (oldEventCache.hasChild(childKey)) {\n      const oldChildSnap = oldEventCache.getImmediateChild(childKey);\n      let nextChild = source.getChildAfterChild(\n        this.index_,\n        windowBoundary,\n        this.reverse_\n      );\n      while (\n        nextChild != null &&\n        (nextChild.name == childKey || oldEventCache.hasChild(nextChild.name))\n      ) {\n        // There is a weird edge case where a node is updated as part of a merge in the write tree, but hasn't\n        // been applied to the limited filter yet. Ignore this next child which will be updated later in\n        // the limited filter...\n        nextChild = source.getChildAfterChild(\n          this.index_,\n          nextChild,\n          this.reverse_\n        );\n      }\n      const compareNext =\n        nextChild == null ? 1 : cmp(nextChild, newChildNamedNode);\n      const remainsInWindow =\n        inRange && !childSnap.isEmpty() && compareNext >= 0;\n      if (remainsInWindow) {\n        if (changeAccumulator != null) {\n          changeAccumulator.trackChildChange(\n            Change.childChangedChange(childKey, childSnap, oldChildSnap)\n          );\n        }\n        return oldEventCache.updateImmediateChild(childKey, childSnap);\n      } else {\n        if (changeAccumulator != null) {\n          changeAccumulator.trackChildChange(\n            Change.childRemovedChange(childKey, oldChildSnap)\n          );\n        }\n        const newEventCache = oldEventCache.updateImmediateChild(\n          childKey,\n          ChildrenNode.EMPTY_NODE\n        );\n        const nextChildInRange =\n          nextChild != null && this.rangedFilter_.matches(nextChild);\n        if (nextChildInRange) {\n          if (changeAccumulator != null) {\n            changeAccumulator.trackChildChange(\n              Change.childAddedChange(nextChild.name, nextChild.node)\n            );\n          }\n          return newEventCache.updateImmediateChild(\n            nextChild.name,\n            nextChild.node\n          );\n        } else {\n          return newEventCache;\n        }\n      }\n    } else if (childSnap.isEmpty()) {\n      // we're deleting a node, but it was not in the window, so ignore it\n      return snap;\n    } else if (inRange) {\n      if (cmp(windowBoundary, newChildNamedNode) >= 0) {\n        if (changeAccumulator != null) {\n          changeAccumulator.trackChildChange(\n            Change.childRemovedChange(windowBoundary.name, windowBoundary.node)\n          );\n          changeAccumulator.trackChildChange(\n            Change.childAddedChange(childKey, childSnap)\n          );\n        }\n        return oldEventCache\n          .updateImmediateChild(childKey, childSnap)\n          .updateImmediateChild(windowBoundary.name, ChildrenNode.EMPTY_NODE);\n      } else {\n        return snap;\n      }\n    } else {\n      return snap;\n    }\n  }\n}\n","/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\nimport { RangedFilter } from './RangedFilter';\nimport { ChildrenNode } from '../../snap/ChildrenNode';\nimport { NamedNode } from '../../snap/Node';\nimport { assert } from '../../../../utils/assert';\nimport { Change } from '../Change';\n/**\n * Applies a limit and a range to a node and uses RangedFilter to do the heavy lifting where possible\n *\n * @constructor\n * @implements {NodeFilter}\n */\nvar LimitedFilter = (function () {\n    /**\n     * @param {!QueryParams} params\n     */\n    function LimitedFilter(params) {\n        this.rangedFilter_ = new RangedFilter(params);\n        this.index_ = params.getIndex();\n        this.limit_ = params.getLimit();\n        this.reverse_ = !params.isViewFromLeft();\n    }\n    /**\n     * @inheritDoc\n     */\n    LimitedFilter.prototype.updateChild = function (snap, key, newChild, affectedPath, source, optChangeAccumulator) {\n        if (!this.rangedFilter_.matches(new NamedNode(key, newChild))) {\n            newChild = ChildrenNode.EMPTY_NODE;\n        }\n        if (snap.getImmediateChild(key).equals(newChild)) {\n            // No change\n            return snap;\n        }\n        else if (snap.numChildren() < this.limit_) {\n            return this.rangedFilter_\n                .getIndexedFilter()\n                .updateChild(snap, key, newChild, affectedPath, source, optChangeAccumulator);\n        }\n        else {\n            return this.fullLimitUpdateChild_(snap, key, newChild, source, optChangeAccumulator);\n        }\n    };\n    /**\n     * @inheritDoc\n     */\n    LimitedFilter.prototype.updateFullNode = function (oldSnap, newSnap, optChangeAccumulator) {\n        var filtered;\n        if (newSnap.isLeafNode() || newSnap.isEmpty()) {\n            // Make sure we have a children node with the correct index, not a leaf node;\n            filtered = ChildrenNode.EMPTY_NODE.withIndex(this.index_);\n        }\n        else {\n            if (this.limit_ * 2 < newSnap.numChildren() &&\n                newSnap.isIndexed(this.index_)) {\n                // Easier to build up a snapshot, since what we're given has more than twice the elements we want\n                filtered = ChildrenNode.EMPTY_NODE.withIndex(this.index_);\n                // anchor to the startPost, endPost, or last element as appropriate\n                var iterator = void 0;\n                if (this.reverse_) {\n                    iterator = newSnap.getReverseIteratorFrom(this.rangedFilter_.getEndPost(), this.index_);\n                }\n                else {\n                    iterator = newSnap.getIteratorFrom(this.rangedFilter_.getStartPost(), this.index_);\n                }\n                var count = 0;\n                while (iterator.hasNext() && count < this.limit_) {\n                    var next = iterator.getNext();\n                    var inRange = void 0;\n                    if (this.reverse_) {\n                        inRange =\n                            this.index_.compare(this.rangedFilter_.getStartPost(), next) <= 0;\n                    }\n                    else {\n                        inRange =\n                            this.index_.compare(next, this.rangedFilter_.getEndPost()) <= 0;\n                    }\n                    if (inRange) {\n                        filtered = filtered.updateImmediateChild(next.name, next.node);\n                        count++;\n                    }\n                    else {\n                        // if we have reached the end post, we cannot keep adding elemments\n                        break;\n                    }\n                }\n            }\n            else {\n                // The snap contains less than twice the limit. Faster to delete from the snap than build up a new one\n                filtered = newSnap.withIndex(this.index_);\n                // Don't support priorities on queries\n                filtered = filtered.updatePriority(ChildrenNode.EMPTY_NODE);\n                var startPost = void 0;\n                var endPost = void 0;\n                var cmp = void 0;\n                var iterator = void 0;\n                if (this.reverse_) {\n                    iterator = filtered.getReverseIterator(this.index_);\n                    startPost = this.rangedFilter_.getEndPost();\n                    endPost = this.rangedFilter_.getStartPost();\n                    var indexCompare_1 = this.index_.getCompare();\n                    cmp = function (a, b) { return indexCompare_1(b, a); };\n                }\n                else {\n                    iterator = filtered.getIterator(this.index_);\n                    startPost = this.rangedFilter_.getStartPost();\n                    endPost = this.rangedFilter_.getEndPost();\n                    cmp = this.index_.getCompare();\n                }\n                var count = 0;\n                var foundStartPost = false;\n                while (iterator.hasNext()) {\n                    var next = iterator.getNext();\n                    if (!foundStartPost && cmp(startPost, next) <= 0) {\n                        // start adding\n                        foundStartPost = true;\n                    }\n                    var inRange = foundStartPost && count < this.limit_ && cmp(next, endPost) <= 0;\n                    if (inRange) {\n                        count++;\n                    }\n                    else {\n                        filtered = filtered.updateImmediateChild(next.name, ChildrenNode.EMPTY_NODE);\n                    }\n                }\n            }\n        }\n        return this.rangedFilter_\n            .getIndexedFilter()\n            .updateFullNode(oldSnap, filtered, optChangeAccumulator);\n    };\n    /**\n     * @inheritDoc\n     */\n    LimitedFilter.prototype.updatePriority = function (oldSnap, newPriority) {\n        // Don't support priorities on queries\n        return oldSnap;\n    };\n    /**\n     * @inheritDoc\n     */\n    LimitedFilter.prototype.filtersNodes = function () {\n        return true;\n    };\n    /**\n     * @inheritDoc\n     */\n    LimitedFilter.prototype.getIndexedFilter = function () {\n        return this.rangedFilter_.getIndexedFilter();\n    };\n    /**\n     * @inheritDoc\n     */\n    LimitedFilter.prototype.getIndex = function () {\n        return this.index_;\n    };\n    /**\n     * @param {!Node} snap\n     * @param {string} childKey\n     * @param {!Node} childSnap\n     * @param {!CompleteChildSource} source\n     * @param {?ChildChangeAccumulator} changeAccumulator\n     * @return {!Node}\n     * @private\n     */\n    LimitedFilter.prototype.fullLimitUpdateChild_ = function (snap, childKey, childSnap, source, changeAccumulator) {\n        // TODO: rename all cache stuff etc to general snap terminology\n        var cmp;\n        if (this.reverse_) {\n            var indexCmp_1 = this.index_.getCompare();\n            cmp = function (a, b) { return indexCmp_1(b, a); };\n        }\n        else {\n            cmp = this.index_.getCompare();\n        }\n        var oldEventCache = snap;\n        assert(oldEventCache.numChildren() == this.limit_, '');\n        var newChildNamedNode = new NamedNode(childKey, childSnap);\n        var windowBoundary = this.reverse_\n            ? oldEventCache.getFirstChild(this.index_)\n            : oldEventCache.getLastChild(this.index_);\n        var inRange = this.rangedFilter_.matches(newChildNamedNode);\n        if (oldEventCache.hasChild(childKey)) {\n            var oldChildSnap = oldEventCache.getImmediateChild(childKey);\n            var nextChild = source.getChildAfterChild(this.index_, windowBoundary, this.reverse_);\n            while (nextChild != null &&\n                (nextChild.name == childKey || oldEventCache.hasChild(nextChild.name))) {\n                // There is a weird edge case where a node is updated as part of a merge in the write tree, but hasn't\n                // been applied to the limited filter yet. Ignore this next child which will be updated later in\n                // the limited filter...\n                nextChild = source.getChildAfterChild(this.index_, nextChild, this.reverse_);\n            }\n            var compareNext = nextChild == null ? 1 : cmp(nextChild, newChildNamedNode);\n            var remainsInWindow = inRange && !childSnap.isEmpty() && compareNext >= 0;\n            if (remainsInWindow) {\n                if (changeAccumulator != null) {\n                    changeAccumulator.trackChildChange(Change.childChangedChange(childKey, childSnap, oldChildSnap));\n                }\n                return oldEventCache.updateImmediateChild(childKey, childSnap);\n            }\n            else {\n                if (changeAccumulator != null) {\n                    changeAccumulator.trackChildChange(Change.childRemovedChange(childKey, oldChildSnap));\n                }\n                var newEventCache = oldEventCache.updateImmediateChild(childKey, ChildrenNode.EMPTY_NODE);\n                var nextChildInRange = nextChild != null && this.rangedFilter_.matches(nextChild);\n                if (nextChildInRange) {\n                    if (changeAccumulator != null) {\n                        changeAccumulator.trackChildChange(Change.childAddedChange(nextChild.name, nextChild.node));\n                    }\n                    return newEventCache.updateImmediateChild(nextChild.name, nextChild.node);\n                }\n                else {\n                    return newEventCache;\n                }\n            }\n        }\n        else if (childSnap.isEmpty()) {\n            // we're deleting a node, but it was not in the window, so ignore it\n            return snap;\n        }\n        else if (inRange) {\n            if (cmp(windowBoundary, newChildNamedNode) >= 0) {\n                if (changeAccumulator != null) {\n                    changeAccumulator.trackChildChange(Change.childRemovedChange(windowBoundary.name, windowBoundary.node));\n                    changeAccumulator.trackChildChange(Change.childAddedChange(childKey, childSnap));\n                }\n                return oldEventCache\n                    .updateImmediateChild(childKey, childSnap)\n                    .updateImmediateChild(windowBoundary.name, ChildrenNode.EMPTY_NODE);\n            }\n            else {\n                return snap;\n            }\n        }\n        else {\n            return snap;\n        }\n    };\n    return LimitedFilter;\n}());\nexport { LimitedFilter };\n\n\n"]}