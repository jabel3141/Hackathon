{"version":3,"sources":["database/core/src/database/core/view/filter/RangedFilter.ts","database/core/view/filter/RangedFilter.js"],"names":["RangedFilter","params","indexedFilter_","getIndex","index_","startPost_","getStartPost_","endPost_","getEndPost_","prototype","getStartPost","getEndPost","matches","node","compare","updateChild","snap","key","newChild","affectedPath","source","optChangeAccumulator","EMPTY_NODE","updateFullNode","oldSnap","newSnap","isLeafNode","filtered","withIndex","updatePriority","self","forEachChild","childNode","updateImmediateChild","newPriority","filtersNodes","getIndexedFilter","hasStart","startName","getIndexStartName","makePost","getIndexStartValue","minPost","hasEnd","endName","getIndexEndName","getIndexEndValue","maxPost"],"mappings":"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","file":"RangedFilter.js","sourcesContent":["/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\nimport { IndexedFilter } from './IndexedFilter';\nimport { PRIORITY_INDEX } from '../../snap/indexes/PriorityIndex';\nimport { NamedNode, Node } from '../../../core/snap/Node';\nimport { ChildrenNode } from '../../snap/ChildrenNode';\nimport { NodeFilter } from './NodeFilter';\nimport { QueryParams } from '../QueryParams';\nimport { Index } from '../../snap/indexes/Index';\nimport { Path } from '../../util/Path';\nimport { CompleteChildSource } from '../CompleteChildSource';\nimport { ChildChangeAccumulator } from '../ChildChangeAccumulator';\n\n/**\n * Filters nodes by range and uses an IndexFilter to track any changes after filtering the node\n *\n * @constructor\n * @implements {NodeFilter}\n */\nexport class RangedFilter implements NodeFilter {\n  /**\n   * @type {!IndexedFilter}\n   * @const\n   * @private\n   */\n  private indexedFilter_: IndexedFilter;\n\n  /**\n   * @const\n   * @type {!Index}\n   * @private\n   */\n  private index_: Index;\n\n  /**\n   * @const\n   * @type {!NamedNode}\n   * @private\n   */\n  private startPost_: NamedNode;\n\n  /**\n   * @const\n   * @type {!NamedNode}\n   * @private\n   */\n  private endPost_: NamedNode;\n\n  /**\n   * @param {!QueryParams} params\n   */\n  constructor(params: QueryParams) {\n    this.indexedFilter_ = new IndexedFilter(params.getIndex());\n    this.index_ = params.getIndex();\n    this.startPost_ = RangedFilter.getStartPost_(params);\n    this.endPost_ = RangedFilter.getEndPost_(params);\n  }\n\n  /**\n   * @return {!NamedNode}\n   */\n  getStartPost(): NamedNode {\n    return this.startPost_;\n  }\n\n  /**\n   * @return {!NamedNode}\n   */\n  getEndPost(): NamedNode {\n    return this.endPost_;\n  }\n\n  /**\n   * @param {!NamedNode} node\n   * @return {boolean}\n   */\n  matches(node: NamedNode): boolean {\n    return (\n      this.index_.compare(this.getStartPost(), node) <= 0 &&\n      this.index_.compare(node, this.getEndPost()) <= 0\n    );\n  }\n\n  /**\n   * @inheritDoc\n   */\n  updateChild(\n    snap: Node,\n    key: string,\n    newChild: Node,\n    affectedPath: Path,\n    source: CompleteChildSource,\n    optChangeAccumulator: ChildChangeAccumulator | null\n  ): Node {\n    if (!this.matches(new NamedNode(key, newChild))) {\n      newChild = ChildrenNode.EMPTY_NODE;\n    }\n    return this.indexedFilter_.updateChild(\n      snap,\n      key,\n      newChild,\n      affectedPath,\n      source,\n      optChangeAccumulator\n    );\n  }\n\n  /**\n   * @inheritDoc\n   */\n  updateFullNode(\n    oldSnap: Node,\n    newSnap: Node,\n    optChangeAccumulator: ChildChangeAccumulator | null\n  ): Node {\n    if (newSnap.isLeafNode()) {\n      // Make sure we have a children node with the correct index, not a leaf node;\n      newSnap = ChildrenNode.EMPTY_NODE;\n    }\n    let filtered = newSnap.withIndex(this.index_);\n    // Don't support priorities on queries\n    filtered = filtered.updatePriority(ChildrenNode.EMPTY_NODE);\n    const self = this;\n    newSnap.forEachChild(PRIORITY_INDEX, function(key, childNode) {\n      if (!self.matches(new NamedNode(key, childNode))) {\n        filtered = filtered.updateImmediateChild(key, ChildrenNode.EMPTY_NODE);\n      }\n    });\n    return this.indexedFilter_.updateFullNode(\n      oldSnap,\n      filtered,\n      optChangeAccumulator\n    );\n  }\n\n  /**\n   * @inheritDoc\n   */\n  updatePriority(oldSnap: Node, newPriority: Node): Node {\n    // Don't support priorities on queries\n    return oldSnap;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  filtersNodes(): boolean {\n    return true;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  getIndexedFilter(): IndexedFilter {\n    return this.indexedFilter_;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  getIndex(): Index {\n    return this.index_;\n  }\n\n  /**\n   * @param {!QueryParams} params\n   * @return {!NamedNode}\n   * @private\n   */\n  private static getStartPost_(params: QueryParams): NamedNode {\n    if (params.hasStart()) {\n      const startName = params.getIndexStartName();\n      return params.getIndex().makePost(params.getIndexStartValue(), startName);\n    } else {\n      return params.getIndex().minPost();\n    }\n  }\n\n  /**\n   * @param {!QueryParams} params\n   * @return {!NamedNode}\n   * @private\n   */\n  private static getEndPost_(params: QueryParams): NamedNode {\n    if (params.hasEnd()) {\n      const endName = params.getIndexEndName();\n      return params.getIndex().makePost(params.getIndexEndValue(), endName);\n    } else {\n      return params.getIndex().maxPost();\n    }\n  }\n}\n","/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\nimport { IndexedFilter } from './IndexedFilter';\nimport { PRIORITY_INDEX } from '../../snap/indexes/PriorityIndex';\nimport { NamedNode } from '../../../core/snap/Node';\nimport { ChildrenNode } from '../../snap/ChildrenNode';\n/**\n * Filters nodes by range and uses an IndexFilter to track any changes after filtering the node\n *\n * @constructor\n * @implements {NodeFilter}\n */\nvar RangedFilter = (function () {\n    /**\n     * @param {!QueryParams} params\n     */\n    function RangedFilter(params) {\n        this.indexedFilter_ = new IndexedFilter(params.getIndex());\n        this.index_ = params.getIndex();\n        this.startPost_ = RangedFilter.getStartPost_(params);\n        this.endPost_ = RangedFilter.getEndPost_(params);\n    }\n    /**\n     * @return {!NamedNode}\n     */\n    RangedFilter.prototype.getStartPost = function () {\n        return this.startPost_;\n    };\n    /**\n     * @return {!NamedNode}\n     */\n    RangedFilter.prototype.getEndPost = function () {\n        return this.endPost_;\n    };\n    /**\n     * @param {!NamedNode} node\n     * @return {boolean}\n     */\n    RangedFilter.prototype.matches = function (node) {\n        return (this.index_.compare(this.getStartPost(), node) <= 0 &&\n            this.index_.compare(node, this.getEndPost()) <= 0);\n    };\n    /**\n     * @inheritDoc\n     */\n    RangedFilter.prototype.updateChild = function (snap, key, newChild, affectedPath, source, optChangeAccumulator) {\n        if (!this.matches(new NamedNode(key, newChild))) {\n            newChild = ChildrenNode.EMPTY_NODE;\n        }\n        return this.indexedFilter_.updateChild(snap, key, newChild, affectedPath, source, optChangeAccumulator);\n    };\n    /**\n     * @inheritDoc\n     */\n    RangedFilter.prototype.updateFullNode = function (oldSnap, newSnap, optChangeAccumulator) {\n        if (newSnap.isLeafNode()) {\n            // Make sure we have a children node with the correct index, not a leaf node;\n            newSnap = ChildrenNode.EMPTY_NODE;\n        }\n        var filtered = newSnap.withIndex(this.index_);\n        // Don't support priorities on queries\n        filtered = filtered.updatePriority(ChildrenNode.EMPTY_NODE);\n        var self = this;\n        newSnap.forEachChild(PRIORITY_INDEX, function (key, childNode) {\n            if (!self.matches(new NamedNode(key, childNode))) {\n                filtered = filtered.updateImmediateChild(key, ChildrenNode.EMPTY_NODE);\n            }\n        });\n        return this.indexedFilter_.updateFullNode(oldSnap, filtered, optChangeAccumulator);\n    };\n    /**\n     * @inheritDoc\n     */\n    RangedFilter.prototype.updatePriority = function (oldSnap, newPriority) {\n        // Don't support priorities on queries\n        return oldSnap;\n    };\n    /**\n     * @inheritDoc\n     */\n    RangedFilter.prototype.filtersNodes = function () {\n        return true;\n    };\n    /**\n     * @inheritDoc\n     */\n    RangedFilter.prototype.getIndexedFilter = function () {\n        return this.indexedFilter_;\n    };\n    /**\n     * @inheritDoc\n     */\n    RangedFilter.prototype.getIndex = function () {\n        return this.index_;\n    };\n    /**\n     * @param {!QueryParams} params\n     * @return {!NamedNode}\n     * @private\n     */\n    RangedFilter.getStartPost_ = function (params) {\n        if (params.hasStart()) {\n            var startName = params.getIndexStartName();\n            return params.getIndex().makePost(params.getIndexStartValue(), startName);\n        }\n        else {\n            return params.getIndex().minPost();\n        }\n    };\n    /**\n     * @param {!QueryParams} params\n     * @return {!NamedNode}\n     * @private\n     */\n    RangedFilter.getEndPost_ = function (params) {\n        if (params.hasEnd()) {\n            var endName = params.getIndexEndName();\n            return params.getIndex().makePost(params.getIndexEndValue(), endName);\n        }\n        else {\n            return params.getIndex().maxPost();\n        }\n    };\n    return RangedFilter;\n}());\nexport { RangedFilter };\n\n\n"]}