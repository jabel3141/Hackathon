{"version":3,"sources":["src/database/core/Repo_transaction.ts"],"names":["TransactionStatus","MAX_TRANSACTION_RETRIES_","prototype","transactions_init_","transactionQueueTree_","startTransaction","path","transactionUpdate","onComplete","applyLocally","log_","valueCallback","watchRef","on","unwatcher","off","transaction","update","status","order","retryCount","abortReason","currentWriteId","currentInputSnapshot","currentOutputSnapshotRaw","currentOutputSnapshotResolved","currentState","getLatestState_","newVal","val","undefined","snapshot","RUN","queueNode","subTree","nodeQueue","getValue","push","setValue","priorityForNode","currentNode","serverSyncTree_","calcCompleteEventCache","EMPTY_NODE","getPriority","serverValues","generateServerValues","newNodeUnresolved","newNode","getNextWriteId_","events","applyUserOverwrite","eventQueue_","raiseEventsForChangedPath","sendReadyTransactions_","excludeSets","node","_this","pruneCompletedTransactionsBelowNode_","queue","buildTransactionQueue_","length","allRun","every","sendTransactionQueue_","hasChildren","forEachChild","childNode","setsToIgnore","map","txn","latestState","snapToSend","latestHash","hash","i","SENT","relativePath","updateChild","dataToSend","pathToSend","server_","put","toString","callbacks","COMPLETED","concat","ackUserWrite","ref","bind","SENT_NEEDS_ABORT","NEEDS_ABORT","rerunTransactions_","changedPath","rootMostTransactionNode","getAncestorTransactionNode_","rerunTransactionQueue_","txnsToRerun","filter","q","abortTransaction","newData","newDataNode","hasExplicitPriority","updatePriority","oldWriteId","newNodeResolved","splice","indexOf","setTimeout","Math","floor","lastInput","Error","front","transactionNode","getFront","popFront","transactionQueue","aggregateTransactionQueuesForNode_","sort","a","b","child","to","from","abortTransactions_","affectedPath","forEachAncestor","abortTransactionsOnNode_","forEachDescendant","lastSent"],"mappings":"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","file":"Repo_transaction.js","sourcesContent":["/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\nimport { assert } from '../../utils/assert';\nimport { Reference } from '../api/Reference';\nimport { DataSnapshot } from '../api/DataSnapshot';\nimport { Path } from './util/Path';\nimport { Tree } from './util/Tree';\nimport { PRIORITY_INDEX } from './snap/indexes/PriorityIndex';\nimport { Node } from './snap/Node';\nimport { LUIDGenerator, warn, exceptionGuard } from './util/util';\nimport { resolveDeferredValueSnapshot } from './util/ServerValues';\nimport { isValidPriority, validateFirebaseData } from './util/validation';\nimport { contains, safeGet } from '../../utils/obj';\nimport { nodeFromJSON } from './snap/nodeFromJSON';\nimport { ChildrenNode } from './snap/ChildrenNode';\nimport { Repo } from './Repo';\nimport { Event } from './view/Event';\n\n// TODO: This is pretty messy.  Ideally, a lot of this would move into FirebaseData, or a transaction-specific\n// component used by FirebaseData, but it has ties to user callbacks (transaction update and onComplete) as well\n// as the realtime connection (to send transactions to the server).  So that all needs to be decoupled first.\n// For now it's part of Repo, but in its own file.\n\n/**\n * @enum {number}\n */\nexport enum TransactionStatus {\n  // We've run the transaction and updated transactionResultData_ with the result, but it isn't currently sent to the\n  // server. A transaction will go from RUN -> SENT -> RUN if it comes back from the server as rejected due to\n  // mismatched hash.\n  RUN,\n\n  // We've run the transaction and sent it to the server and it's currently outstanding (hasn't come back as accepted\n  // or rejected yet).\n  SENT,\n\n  // Temporary state used to mark completed transactions (whether successful or aborted).  The transaction will be\n  // removed when we get a chance to prune completed ones.\n  COMPLETED,\n\n  // Used when an already-sent transaction needs to be aborted (e.g. due to a conflicting set() call that was made).\n  // If it comes back as unsuccessful, we'll abort it.\n  SENT_NEEDS_ABORT,\n\n  // Temporary state used to mark transactions that need to be aborted.\n  NEEDS_ABORT\n}\n\n/**\n * If a transaction does not succeed after 25 retries, we abort it.  Among other things this ensure that if there's\n * ever a bug causing a mismatch between client / server hashes for some data, we won't retry indefinitely.\n * @type {number}\n * @const\n * @private\n */\n(Repo as any).MAX_TRANSACTION_RETRIES_ = 25;\n\n/**\n * @typedef {{\n *   path: !Path,\n *   update: function(*):*,\n *   onComplete: ?function(?Error, boolean, ?DataSnapshot),\n *   status: ?TransactionStatus,\n *   order: !number,\n *   applyLocally: boolean,\n *   retryCount: !number,\n *   unwatcher: function(),\n *   abortReason: ?string,\n *   currentWriteId: !number,\n *   currentInputSnapshot: ?Node,\n *   currentOutputSnapshotRaw: ?Node,\n *   currentOutputSnapshotResolved: ?Node\n * }}\n */\ntype Transaction = {\n  path: Path;\n  update: (a: any) => any;\n  onComplete: (a: Error | null, b: boolean, c: DataSnapshot | null) => void;\n  status: TransactionStatus;\n  order: number;\n  applyLocally: boolean;\n  retryCount: number;\n  unwatcher: () => void;\n  abortReason: string | null;\n  currentWriteId: number;\n  currentInputSnapshot: Node | null;\n  currentOutputSnapshotRaw: Node | null;\n  currentOutputSnapshotResolved: Node | null;\n};\n\n/**\n * Setup the transaction data structures\n * @private\n */\n(Repo.prototype as any).transactions_init_ = function() {\n  /**\n   * Stores queues of outstanding transactions for Firebase locations.\n   *\n   * @type {!Tree.<Array.<!Transaction>>}\n   * @private\n   */\n  this.transactionQueueTree_ = new Tree<Transaction[]>();\n};\n\ndeclare module './Repo' {\n  interface Repo {\n    startTransaction(\n      path: Path,\n      transactionUpdate: (a: any) => void,\n      onComplete: ((a: Error, b: boolean, c: DataSnapshot) => void) | null,\n      applyLocally: boolean\n    ): void;\n  }\n}\n\n/**\n * Creates a new transaction, adds it to the transactions we're tracking, and sends it to the server if possible.\n *\n * @param {!Path} path Path at which to do transaction.\n * @param {function(*):*} transactionUpdate Update callback.\n * @param {?function(?Error, boolean, ?DataSnapshot)} onComplete Completion callback.\n * @param {boolean} applyLocally Whether or not to make intermediate results visible\n */\nRepo.prototype.startTransaction = function(\n  path: Path,\n  transactionUpdate: (a: any) => any,\n  onComplete: ((a: Error, b: boolean, c: DataSnapshot) => void) | null,\n  applyLocally: boolean\n) {\n  this.log_('transaction on ' + path);\n\n  // Add a watch to make sure we get server updates.\n  const valueCallback = function() {};\n  const watchRef = new Reference(this, path);\n  watchRef.on('value', valueCallback);\n  const unwatcher = function() {\n    watchRef.off('value', valueCallback);\n  };\n\n  // Initialize transaction.\n  const transaction: Transaction = {\n    path,\n    update: transactionUpdate,\n    onComplete,\n\n    // One of TransactionStatus enums.\n    status: null,\n\n    // Used when combining transactions at different locations to figure out which one goes first.\n    order: LUIDGenerator(),\n\n    // Whether to raise local events for this transaction.\n    applyLocally: applyLocally,\n\n    // Count of how many times we've retried the transaction.\n    retryCount: 0,\n\n    // Function to call to clean up our .on() listener.\n    unwatcher,\n\n    // Stores why a transaction was aborted.\n    abortReason: null,\n\n    currentWriteId: null,\n\n    currentInputSnapshot: null,\n\n    currentOutputSnapshotRaw: null,\n\n    currentOutputSnapshotResolved: null\n  };\n\n  // Run transaction initially.\n  const currentState = this.getLatestState_(path);\n  transaction.currentInputSnapshot = currentState;\n  const newVal = transaction.update(currentState.val());\n  if (newVal === undefined) {\n    // Abort transaction.\n    transaction.unwatcher();\n    transaction.currentOutputSnapshotRaw = null;\n    transaction.currentOutputSnapshotResolved = null;\n    if (transaction.onComplete) {\n      // We just set the input snapshot, so this cast should be safe\n      const snapshot = new DataSnapshot(\n        transaction.currentInputSnapshot,\n        new Reference(this, transaction.path),\n        PRIORITY_INDEX\n      );\n      transaction.onComplete(null, false, snapshot);\n    }\n  } else {\n    validateFirebaseData(\n      'transaction failed: Data returned ',\n      newVal,\n      transaction.path\n    );\n\n    // Mark as run and add to our queue.\n    transaction.status = TransactionStatus.RUN;\n    const queueNode = this.transactionQueueTree_.subTree(path);\n    const nodeQueue = queueNode.getValue() || [];\n    nodeQueue.push(transaction);\n\n    queueNode.setValue(nodeQueue);\n\n    // Update visibleData and raise events\n    // Note: We intentionally raise events after updating all of our transaction state, since the user could\n    // start new transactions from the event callbacks.\n    let priorityForNode;\n    if (\n      typeof newVal === 'object' &&\n      newVal !== null &&\n      contains(newVal, '.priority')\n    ) {\n      priorityForNode = safeGet(newVal, '.priority');\n      assert(\n        isValidPriority(priorityForNode),\n        'Invalid priority returned by transaction. ' +\n          'Priority must be a valid string, finite number, server value, or null.'\n      );\n    } else {\n      const currentNode =\n        this.serverSyncTree_.calcCompleteEventCache(path) ||\n        ChildrenNode.EMPTY_NODE;\n      priorityForNode = currentNode.getPriority().val();\n    }\n    priorityForNode /** @type {null|number|string} */ = priorityForNode;\n\n    const serverValues = this.generateServerValues();\n    const newNodeUnresolved = nodeFromJSON(newVal, priorityForNode);\n    const newNode = resolveDeferredValueSnapshot(\n      newNodeUnresolved,\n      serverValues\n    );\n    transaction.currentOutputSnapshotRaw = newNodeUnresolved;\n    transaction.currentOutputSnapshotResolved = newNode;\n    transaction.currentWriteId = this.getNextWriteId_();\n\n    const events = this.serverSyncTree_.applyUserOverwrite(\n      path,\n      newNode,\n      transaction.currentWriteId,\n      transaction.applyLocally\n    );\n    this.eventQueue_.raiseEventsForChangedPath(path, events);\n\n    this.sendReadyTransactions_();\n  }\n};\n\n/**\n * @param {!Path} path\n * @param {Array.<number>=} excludeSets A specific set to exclude\n * @return {Node}\n * @private\n */\n(Repo.prototype as any).getLatestState_ = function(\n  path: Path,\n  excludeSets?: number[]\n): Node {\n  return (\n    this.serverSyncTree_.calcCompleteEventCache(path, excludeSets) ||\n    ChildrenNode.EMPTY_NODE\n  );\n};\n\n/**\n * Sends any already-run transactions that aren't waiting for outstanding transactions to\n * complete.\n *\n * Externally it's called with no arguments, but it calls itself recursively with a particular\n * transactionQueueTree node to recurse through the tree.\n *\n * @param {Tree.<Array.<Transaction>>=} node  transactionQueueTree node to start at.\n * @private\n */\n(Repo.prototype as any).sendReadyTransactions_ = function(\n  node: Tree<Transaction[]> = this.transactionQueueTree_\n) {\n  // Before recursing, make sure any completed transactions are removed.\n  if (!node) {\n    this.pruneCompletedTransactionsBelowNode_(node);\n  }\n\n  if (node.getValue() !== null) {\n    const queue = this.buildTransactionQueue_(node);\n    assert(queue.length > 0, 'Sending zero length transaction queue');\n\n    const allRun = queue.every(\n      (transaction: Transaction) => transaction.status === TransactionStatus.RUN\n    );\n\n    // If they're all run (and not sent), we can send them.  Else, we must wait.\n    if (allRun) {\n      this.sendTransactionQueue_(node.path(), queue);\n    }\n  } else if (node.hasChildren()) {\n    node.forEachChild(childNode => {\n      this.sendReadyTransactions_(childNode);\n    });\n  }\n};\n\n/**\n * Given a list of run transactions, send them to the server and then handle the result (success or failure).\n *\n * @param {!Path} path The location of the queue.\n * @param {!Array.<Transaction>} queue Queue of transactions under the specified location.\n * @private\n */\n(Repo.prototype as any).sendTransactionQueue_ = function(\n  path: Path,\n  queue: Array<Transaction>\n) {\n  // Mark transactions as sent and increment retry count!\n  const setsToIgnore = queue.map(function(txn) {\n    return txn.currentWriteId;\n  });\n  const latestState = this.getLatestState_(path, setsToIgnore);\n  let snapToSend = latestState;\n  const latestHash = latestState.hash();\n  for (let i = 0; i < queue.length; i++) {\n    const txn = queue[i];\n    assert(\n      txn.status === TransactionStatus.RUN,\n      'tryToSendTransactionQueue_: items in queue should all be run.'\n    );\n    txn.status = TransactionStatus.SENT;\n    txn.retryCount++;\n    const relativePath = Path.relativePath(path, txn.path);\n    // If we've gotten to this point, the output snapshot must be defined.\n    snapToSend = snapToSend.updateChild(\n      relativePath /**@type {!Node} */,\n      txn.currentOutputSnapshotRaw\n    );\n  }\n\n  const dataToSend = snapToSend.val(true);\n  const pathToSend = path;\n\n  // Send the put.\n  this.server_.put(\n    pathToSend.toString(),\n    dataToSend,\n    (status: string) => {\n      this.log_('transaction put response', {\n        path: pathToSend.toString(),\n        status\n      });\n\n      let events: Event[] = [];\n      if (status === 'ok') {\n        // Queue up the callbacks and fire them after cleaning up all of our transaction state, since\n        // the callback could trigger more transactions or sets.\n        const callbacks = [];\n        for (let i = 0; i < queue.length; i++) {\n          queue[i].status = TransactionStatus.COMPLETED;\n          events = events.concat(\n            this.serverSyncTree_.ackUserWrite(queue[i].currentWriteId)\n          );\n          if (queue[i].onComplete) {\n            // We never unset the output snapshot, and given that this transaction is complete, it should be set\n            const node = queue[i].currentOutputSnapshotResolved as Node;\n            const ref = new Reference(this, queue[i].path);\n            const snapshot = new DataSnapshot(node, ref, PRIORITY_INDEX);\n            callbacks.push(\n              queue[i].onComplete.bind(null, null, true, snapshot)\n            );\n          }\n          queue[i].unwatcher();\n        }\n\n        // Now remove the completed transactions.\n        this.pruneCompletedTransactionsBelowNode_(\n          this.transactionQueueTree_.subTree(path)\n        );\n        // There may be pending transactions that we can now send.\n        this.sendReadyTransactions_();\n\n        this.eventQueue_.raiseEventsForChangedPath(path, events);\n\n        // Finally, trigger onComplete callbacks.\n        for (let i = 0; i < callbacks.length; i++) {\n          exceptionGuard(callbacks[i]);\n        }\n      } else {\n        // transactions are no longer sent.  Update their status appropriately.\n        if (status === 'datastale') {\n          for (let i = 0; i < queue.length; i++) {\n            if (queue[i].status === TransactionStatus.SENT_NEEDS_ABORT)\n              queue[i].status = TransactionStatus.NEEDS_ABORT;\n            else queue[i].status = TransactionStatus.RUN;\n          }\n        } else {\n          warn(\n            'transaction at ' + pathToSend.toString() + ' failed: ' + status\n          );\n          for (let i = 0; i < queue.length; i++) {\n            queue[i].status = TransactionStatus.NEEDS_ABORT;\n            queue[i].abortReason = status;\n          }\n        }\n\n        this.rerunTransactions_(path);\n      }\n    },\n    latestHash\n  );\n};\n\n/**\n * Finds all transactions dependent on the data at changedPath and reruns them.\n *\n * Should be called any time cached data changes.\n *\n * Return the highest path that was affected by rerunning transactions.  This is the path at which events need to\n * be raised for.\n *\n * @param {!Path} changedPath The path in mergedData that changed.\n * @return {!Path} The rootmost path that was affected by rerunning transactions.\n * @private\n */\n(Repo.prototype as any).rerunTransactions_ = function(changedPath: Path): Path {\n  const rootMostTransactionNode = this.getAncestorTransactionNode_(changedPath);\n  const path = rootMostTransactionNode.path();\n\n  const queue = this.buildTransactionQueue_(rootMostTransactionNode);\n  this.rerunTransactionQueue_(queue, path);\n\n  return path;\n};\n\n/**\n * Does all the work of rerunning transactions (as well as cleans up aborted transactions and whatnot).\n *\n * @param {Array.<Transaction>} queue The queue of transactions to run.\n * @param {!Path} path The path the queue is for.\n * @private\n */\n(Repo.prototype as any).rerunTransactionQueue_ = function(\n  queue: Array<Transaction>,\n  path: Path\n) {\n  if (queue.length === 0) {\n    return; // Nothing to do!\n  }\n\n  // Queue up the callbacks and fire them after cleaning up all of our transaction state, since\n  // the callback could trigger more transactions or sets.\n  const callbacks = [];\n  let events: Event[] = [];\n  // Ignore all of the sets we're going to re-run.\n  const txnsToRerun = queue.filter(function(q) {\n    return q.status === TransactionStatus.RUN;\n  });\n  const setsToIgnore = txnsToRerun.map(function(q) {\n    return q.currentWriteId;\n  });\n  for (let i = 0; i < queue.length; i++) {\n    const transaction = queue[i];\n    const relativePath = Path.relativePath(path, transaction.path);\n    let abortTransaction = false,\n      abortReason;\n    assert(\n      relativePath !== null,\n      'rerunTransactionsUnderNode_: relativePath should not be null.'\n    );\n\n    if (transaction.status === TransactionStatus.NEEDS_ABORT) {\n      abortTransaction = true;\n      abortReason = transaction.abortReason;\n      events = events.concat(\n        this.serverSyncTree_.ackUserWrite(transaction.currentWriteId, true)\n      );\n    } else if (transaction.status === TransactionStatus.RUN) {\n      if (transaction.retryCount >= (Repo as any).MAX_TRANSACTION_RETRIES_) {\n        abortTransaction = true;\n        abortReason = 'maxretry';\n        events = events.concat(\n          this.serverSyncTree_.ackUserWrite(transaction.currentWriteId, true)\n        );\n      } else {\n        // This code reruns a transaction\n        const currentNode = this.getLatestState_(\n          transaction.path,\n          setsToIgnore\n        );\n        transaction.currentInputSnapshot = currentNode;\n        const newData = queue[i].update(currentNode.val());\n        if (newData !== undefined) {\n          validateFirebaseData(\n            'transaction failed: Data returned ',\n            newData,\n            transaction.path\n          );\n          let newDataNode = nodeFromJSON(newData);\n          const hasExplicitPriority =\n            typeof newData === 'object' &&\n            newData != null &&\n            contains(newData, '.priority');\n          if (!hasExplicitPriority) {\n            // Keep the old priority if there wasn't a priority explicitly specified.\n            newDataNode = newDataNode.updatePriority(currentNode.getPriority());\n          }\n\n          const oldWriteId = transaction.currentWriteId;\n          const serverValues = this.generateServerValues();\n          const newNodeResolved = resolveDeferredValueSnapshot(\n            newDataNode,\n            serverValues\n          );\n\n          transaction.currentOutputSnapshotRaw = newDataNode;\n          transaction.currentOutputSnapshotResolved = newNodeResolved;\n          transaction.currentWriteId = this.getNextWriteId_();\n          // Mutates setsToIgnore in place\n          setsToIgnore.splice(setsToIgnore.indexOf(oldWriteId), 1);\n          events = events.concat(\n            this.serverSyncTree_.applyUserOverwrite(\n              transaction.path,\n              newNodeResolved,\n              transaction.currentWriteId,\n              transaction.applyLocally\n            )\n          );\n          events = events.concat(\n            this.serverSyncTree_.ackUserWrite(oldWriteId, true)\n          );\n        } else {\n          abortTransaction = true;\n          abortReason = 'nodata';\n          events = events.concat(\n            this.serverSyncTree_.ackUserWrite(transaction.currentWriteId, true)\n          );\n        }\n      }\n    }\n    this.eventQueue_.raiseEventsForChangedPath(path, events);\n    events = [];\n    if (abortTransaction) {\n      // Abort.\n      queue[i].status = TransactionStatus.COMPLETED;\n\n      // Removing a listener can trigger pruning which can muck with mergedData/visibleData (as it prunes data).\n      // So defer the unwatcher until we're done.\n      (function(unwatcher) {\n        setTimeout(unwatcher, Math.floor(0));\n      })(queue[i].unwatcher);\n\n      if (queue[i].onComplete) {\n        if (abortReason === 'nodata') {\n          const ref = new Reference(this, queue[i].path);\n          // We set this field immediately, so it's safe to cast to an actual snapshot\n          const lastInput /** @type {!Node} */ = queue[i].currentInputSnapshot;\n          const snapshot = new DataSnapshot(lastInput, ref, PRIORITY_INDEX);\n          callbacks.push(queue[i].onComplete.bind(null, null, false, snapshot));\n        } else {\n          callbacks.push(\n            queue[i].onComplete.bind(null, new Error(abortReason), false, null)\n          );\n        }\n      }\n    }\n  }\n\n  // Clean up completed transactions.\n  this.pruneCompletedTransactionsBelowNode_(this.transactionQueueTree_);\n\n  // Now fire callbacks, now that we're in a good, known state.\n  for (let i = 0; i < callbacks.length; i++) {\n    exceptionGuard(callbacks[i]);\n  }\n\n  // Try to send the transaction result to the server.\n  this.sendReadyTransactions_();\n};\n\n/**\n * Returns the rootmost ancestor node of the specified path that has a pending transaction on it, or just returns\n * the node for the given path if there are no pending transactions on any ancestor.\n *\n * @param {!Path} path The location to start at.\n * @return {!Tree.<Array.<!Transaction>>} The rootmost node with a transaction.\n * @private\n */\n(Repo.prototype as any).getAncestorTransactionNode_ = function(\n  path: Path\n): Tree<Transaction[]> {\n  let front;\n\n  // Start at the root and walk deeper into the tree towards path until we find a node with pending transactions.\n  let transactionNode = this.transactionQueueTree_;\n  while (\n    (front = path.getFront()) !== null &&\n    transactionNode.getValue() === null\n  ) {\n    transactionNode = transactionNode.subTree(front);\n    path = path.popFront();\n  }\n\n  return transactionNode;\n};\n\n/**\n * Builds the queue of all transactions at or below the specified transactionNode.\n *\n * @param {!Tree.<Array.<Transaction>>} transactionNode\n * @return {Array.<Transaction>} The generated queue.\n * @private\n */\n(Repo.prototype as any).buildTransactionQueue_ = function(\n  transactionNode: Tree<Transaction[]>\n): Array<Transaction> {\n  // Walk any child transaction queues and aggregate them into a single queue.\n  const transactionQueue: Transaction[] = [];\n  this.aggregateTransactionQueuesForNode_(transactionNode, transactionQueue);\n\n  // Sort them by the order the transactions were created.\n  transactionQueue.sort(function(a, b) {\n    return a.order - b.order;\n  });\n\n  return transactionQueue;\n};\n\n/**\n * @param {!Tree.<Array.<Transaction>>} node\n * @param {Array.<Transaction>} queue\n * @private\n */\n(Repo.prototype as any).aggregateTransactionQueuesForNode_ = function(\n  node: Tree<Transaction[]>,\n  queue: Array<Transaction>\n) {\n  const nodeQueue = node.getValue();\n  if (nodeQueue !== null) {\n    for (let i = 0; i < nodeQueue.length; i++) {\n      queue.push(nodeQueue[i]);\n    }\n  }\n\n  node.forEachChild(child => {\n    this.aggregateTransactionQueuesForNode_(child, queue);\n  });\n};\n\n/**\n * Remove COMPLETED transactions at or below this node in the transactionQueueTree_.\n *\n * @param {!Tree.<Array.<!Transaction>>} node\n * @private\n */\n(Repo.prototype as any).pruneCompletedTransactionsBelowNode_ = function(\n  node: Tree<Transaction[]>\n) {\n  const queue = node.getValue();\n  if (queue) {\n    let to = 0;\n    for (let from = 0; from < queue.length; from++) {\n      if (queue[from].status !== TransactionStatus.COMPLETED) {\n        queue[to] = queue[from];\n        to++;\n      }\n    }\n    queue.length = to;\n    node.setValue(queue.length > 0 ? queue : null);\n  }\n\n  node.forEachChild(childNode => {\n    this.pruneCompletedTransactionsBelowNode_(childNode);\n  });\n};\n\n/**\n * Aborts all transactions on ancestors or descendants of the specified path.  Called when doing a set() or update()\n * since we consider them incompatible with transactions.\n *\n * @param {!Path} path Path for which we want to abort related transactions.\n * @return {!Path}\n * @private\n */\n(Repo.prototype as any).abortTransactions_ = function(path: Path): Path {\n  const affectedPath = this.getAncestorTransactionNode_(path).path();\n\n  const transactionNode = this.transactionQueueTree_.subTree(path);\n\n  transactionNode.forEachAncestor((node: Tree<Transaction[]>) => {\n    this.abortTransactionsOnNode_(node);\n  });\n\n  this.abortTransactionsOnNode_(transactionNode);\n\n  transactionNode.forEachDescendant((node: Tree<Transaction[]>) => {\n    this.abortTransactionsOnNode_(node);\n  });\n\n  return affectedPath;\n};\n\n/**\n * Abort transactions stored in this transaction queue node.\n *\n * @param {!Tree.<Array.<Transaction>>} node Node to abort transactions for.\n * @private\n */\n(Repo.prototype as any).abortTransactionsOnNode_ = function(\n  node: Tree<Transaction[]>\n) {\n  const queue = node.getValue();\n  if (queue !== null) {\n    // Queue up the callbacks and fire them after cleaning up all of our transaction state, since\n    // the callback could trigger more transactions or sets.\n    const callbacks = [];\n\n    // Go through queue.  Any already-sent transactions must be marked for abort, while the unsent ones\n    // can be immediately aborted and removed.\n    let events: Event[] = [];\n    let lastSent = -1;\n    for (let i = 0; i < queue.length; i++) {\n      if (queue[i].status === TransactionStatus.SENT_NEEDS_ABORT) {\n        // Already marked.  No action needed.\n      } else if (queue[i].status === TransactionStatus.SENT) {\n        assert(\n          lastSent === i - 1,\n          'All SENT items should be at beginning of queue.'\n        );\n        lastSent = i;\n        // Mark transaction for abort when it comes back.\n        queue[i].status = TransactionStatus.SENT_NEEDS_ABORT;\n        queue[i].abortReason = 'set';\n      } else {\n        assert(\n          queue[i].status === TransactionStatus.RUN,\n          'Unexpected transaction status in abort'\n        );\n        // We can abort it immediately.\n        queue[i].unwatcher();\n        events = events.concat(\n          this.serverSyncTree_.ackUserWrite(queue[i].currentWriteId, true)\n        );\n        if (queue[i].onComplete) {\n          const snapshot: DataSnapshot | null = null;\n          callbacks.push(\n            queue[i].onComplete.bind(null, new Error('set'), false, snapshot)\n          );\n        }\n      }\n    }\n    if (lastSent === -1) {\n      // We're not waiting for any sent transactions.  We can clear the queue.\n      node.setValue(null);\n    } else {\n      // Remove the transactions we aborted.\n      queue.length = lastSent + 1;\n    }\n\n    // Now fire the callbacks.\n    this.eventQueue_.raiseEventsForChangedPath(node.path(), events);\n    for (let i = 0; i < callbacks.length; i++) {\n      exceptionGuard(callbacks[i]);\n    }\n  }\n};\n"]}