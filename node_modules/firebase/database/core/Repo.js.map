{"version":3,"sources":["src/database/core/Repo.ts","database/core/Repo.js"],"names":["INTERRUPT_REASON","Repo","repoInfo_","forceRestClient","app","_this","dataUpdateCount","statsListener_","eventQueue_","nextWriteId_","interceptServerDataCallback_","onDisconnect_","persistentConnection_","authTokenProvider","stats_","getCollection","server_","onDataUpdate_","bind","setTimeout","onConnectStatus_","authOverride","options","Error","e","onServerInfoUpdate_","addTokenChangeListener","token","refreshAuthToken","statsReporter_","getOrCreateReporter","transactions_init_","infoData_","infoSyncTree_","startListening","query","tag","currentHashFn","onComplete","infoEvents","node","getNode","path","isEmpty","applyServerOverwrite","stopListening","updateInfo_","serverSyncTree_","listen","status","data","events","raiseEventsForChangedPath","unlisten","prototype","toString","secure","host","name","namespace","serverTime","offsetNode","offset","val","Date","getTime","generateServerValues","timestamp","pathString","isMerge","taggedChildren","raw","applyTaggedQueryMerge","taggedSnap","applyTaggedQueryOverwrite","changedChildren","applyServerMerge","snap","affectedPath","length","rerunTransactions_","interceptServerData_","callback","connectStatus","runOnDisconnectEvents_","updates","value","key","newNode","updateSnapshot","getNextWriteId_","setWithPriority","newVal","newPriority","log_","priority","serverValues","newNodeUnresolved","writeId","applyUserOverwrite","queueEvents","put","errorReason","success","clearEvents","ackUserWrite","callOnCompleteCallback","abortTransactions_","update","childrenToMerge","empty","changedKey","changedValue","writeId_1","applyUserMerge","merge","changedPath","child","resolvedOnDisconnectTree","forEachTree","Empty","concat","onDisconnectCancel","forget","onDisconnectSet","onDisconnectPut","remember","onDisconnectSetWithPriority","onDisconnectUpdate","onDisconnectMerge","childName","childNode","newChildNode","addEventCallbackForQuery","eventRegistration","getFront","addEventRegistration","raiseEventsAtPath","removeEventCallbackForQuery","removeEventRegistration","interrupt","resume","stats","showDelta","console","get","longestName","Object","keys","reduce","previousValue","currentValue","Math","max","stat","i","log","statsIncrementCounter","metric","incrementCounter","includeStat","var_args","_i","arguments","prefix","id","apply","code","toUpperCase","message","error","defineProperty","__database","enumerable","configurable"],"mappings":"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","file":"Repo.js","sourcesContent":["/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\nimport {\n  generateWithValues,\n  resolveDeferredValueSnapshot,\n  resolveDeferredValueTree\n} from './util/ServerValues';\nimport { nodeFromJSON } from './snap/nodeFromJSON';\nimport { Path } from './util/Path';\nimport { SparseSnapshotTree } from './SparseSnapshotTree';\nimport { SyncTree } from './SyncTree';\nimport { SnapshotHolder } from './SnapshotHolder';\nimport { stringify } from '../../utils/json';\nimport { beingCrawled, each, exceptionGuard, warn, log } from './util/util';\nimport { map, forEach, isEmpty } from '../../utils/obj';\nimport { AuthTokenProvider } from './AuthTokenProvider';\nimport { StatsManager } from './stats/StatsManager';\nimport { StatsReporter } from './stats/StatsReporter';\nimport { StatsListener } from './stats/StatsListener';\nimport { EventQueue } from './view/EventQueue';\nimport { PersistentConnection } from './PersistentConnection';\nimport { ReadonlyRestClient } from './ReadonlyRestClient';\nimport { FirebaseApp } from '../../app/firebase_app';\nimport { RepoInfo } from './RepoInfo';\nimport { Database } from '../api/Database';\nimport { ServerActions } from './ServerActions';\nimport { Query } from '../api/Query';\nimport { EventRegistration } from './view/EventRegistration';\nimport { StatsCollection } from './stats/StatsCollection';\nimport { Event } from './view/Event';\nimport { Node } from './snap/Node';\n\nconst INTERRUPT_REASON = 'repo_interrupt';\n\n/**\n * A connection to a single data repository.\n */\nexport class Repo {\n  dataUpdateCount = 0;\n  private infoSyncTree_: SyncTree;\n  private serverSyncTree_: SyncTree;\n\n  private stats_: StatsCollection;\n  private statsListener_: StatsListener | null = null;\n  private eventQueue_ = new EventQueue();\n  private nextWriteId_ = 1;\n  private server_: ServerActions;\n  private statsReporter_: StatsReporter;\n  private transactions_init_: () => void;\n  private infoData_: SnapshotHolder;\n  private abortTransactions_: (path: Path) => Path;\n  private rerunTransactions_: (changedPath: Path) => Path;\n  private interceptServerDataCallback_:\n    | ((a: string, b: any) => void)\n    | null = null;\n  private __database: Database;\n\n  // A list of data pieces and paths to be set when this client disconnects.\n  private onDisconnect_ = new SparseSnapshotTree();\n\n  /**\n   * TODO: This should be @private but it's used by test_access.js and internal.js\n   * @type {?PersistentConnection}\n   */\n  persistentConnection_: PersistentConnection | null = null;\n\n  /**\n   * @param {!RepoInfo} repoInfo_\n   * @param {boolean} forceRestClient\n   * @param {!FirebaseApp} app\n   */\n  constructor(\n    private repoInfo_: RepoInfo,\n    forceRestClient: boolean,\n    public app: FirebaseApp\n  ) {\n    /** @type {!AuthTokenProvider} */\n    const authTokenProvider = new AuthTokenProvider(app);\n\n    this.stats_ = StatsManager.getCollection(repoInfo_);\n\n    if (forceRestClient || beingCrawled()) {\n      this.server_ = new ReadonlyRestClient(\n        this.repoInfo_,\n        this.onDataUpdate_.bind(this),\n        authTokenProvider\n      );\n\n      // Minor hack: Fire onConnect immediately, since there's no actual connection.\n      setTimeout(this.onConnectStatus_.bind(this, true), 0);\n    } else {\n      const authOverride = app.options['databaseAuthVariableOverride'];\n      // Validate authOverride\n      if (typeof authOverride !== 'undefined' && authOverride !== null) {\n        if (typeof authOverride !== 'object') {\n          throw new Error(\n            'Only objects are supported for option databaseAuthVariableOverride'\n          );\n        }\n        try {\n          stringify(authOverride);\n        } catch (e) {\n          throw new Error('Invalid authOverride provided: ' + e);\n        }\n      }\n\n      this.persistentConnection_ = new PersistentConnection(\n        this.repoInfo_,\n        this.onDataUpdate_.bind(this),\n        this.onConnectStatus_.bind(this),\n        this.onServerInfoUpdate_.bind(this),\n        authTokenProvider,\n        authOverride\n      );\n\n      this.server_ = this.persistentConnection_;\n    }\n\n    authTokenProvider.addTokenChangeListener(token => {\n      this.server_.refreshAuthToken(token);\n    });\n\n    // In the case of multiple Repos for the same repoInfo (i.e. there are multiple Firebase.Contexts being used),\n    // we only want to create one StatsReporter.  As such, we'll report stats over the first Repo created.\n    this.statsReporter_ = StatsManager.getOrCreateReporter(\n      repoInfo_,\n      () => new StatsReporter(this.stats_, this.server_)\n    );\n\n    this.transactions_init_();\n\n    // Used for .info.\n    this.infoData_ = new SnapshotHolder();\n    this.infoSyncTree_ = new SyncTree({\n      startListening: (query, tag, currentHashFn, onComplete) => {\n        let infoEvents: Event[] = [];\n        const node = this.infoData_.getNode(query.path);\n        // This is possibly a hack, but we have different semantics for .info endpoints. We don't raise null events\n        // on initial data...\n        if (!node.isEmpty()) {\n          infoEvents = this.infoSyncTree_.applyServerOverwrite(\n            query.path,\n            node\n          );\n          setTimeout(() => {\n            onComplete('ok');\n          }, 0);\n        }\n        return infoEvents;\n      },\n      stopListening: () => {}\n    });\n    this.updateInfo_('connected', false);\n\n    this.serverSyncTree_ = new SyncTree({\n      startListening: (query, tag, currentHashFn, onComplete) => {\n        this.server_.listen(query, currentHashFn, tag, (status, data) => {\n          const events = onComplete(status, data);\n          this.eventQueue_.raiseEventsForChangedPath(query.path, events);\n        });\n        // No synchronous events for network-backed sync trees\n        return [];\n      },\n      stopListening: (query, tag) => {\n        this.server_.unlisten(query, tag);\n      }\n    });\n  }\n\n  /**\n   * @return {string}  The URL corresponding to the root of this Firebase.\n   */\n  toString(): string {\n    return (\n      (this.repoInfo_.secure ? 'https://' : 'http://') + this.repoInfo_.host\n    );\n  }\n\n  /**\n   * @return {!string} The namespace represented by the repo.\n   */\n  name(): string {\n    return this.repoInfo_.namespace;\n  }\n\n  /**\n   * @return {!number} The time in milliseconds, taking the server offset into account if we have one.\n   */\n  serverTime(): number {\n    const offsetNode = this.infoData_.getNode(\n      new Path('.info/serverTimeOffset')\n    );\n    const offset = (offsetNode.val() as number) || 0;\n    return new Date().getTime() + offset;\n  }\n\n  /**\n   * Generate ServerValues using some variables from the repo object.\n   * @return {!Object}\n   */\n  generateServerValues(): Object {\n    return generateWithValues({\n      timestamp: this.serverTime()\n    });\n  }\n\n  /**\n   * Called by realtime when we get new messages from the server.\n   *\n   * @private\n   * @param {string} pathString\n   * @param {*} data\n   * @param {boolean} isMerge\n   * @param {?number} tag\n   */\n  private onDataUpdate_(\n    pathString: string,\n    data: any,\n    isMerge: boolean,\n    tag: number | null\n  ) {\n    // For testing.\n    this.dataUpdateCount++;\n    const path = new Path(pathString);\n    data = this.interceptServerDataCallback_\n      ? this.interceptServerDataCallback_(pathString, data)\n      : data;\n    let events = [];\n    if (tag) {\n      if (isMerge) {\n        const taggedChildren = map(data as { [k: string]: any }, (raw: any) =>\n          nodeFromJSON(raw)\n        );\n        events = this.serverSyncTree_.applyTaggedQueryMerge(\n          path,\n          taggedChildren,\n          tag\n        );\n      } else {\n        const taggedSnap = nodeFromJSON(data);\n        events = this.serverSyncTree_.applyTaggedQueryOverwrite(\n          path,\n          taggedSnap,\n          tag\n        );\n      }\n    } else if (isMerge) {\n      const changedChildren = map(data as { [k: string]: any }, (raw: any) =>\n        nodeFromJSON(raw)\n      );\n      events = this.serverSyncTree_.applyServerMerge(path, changedChildren);\n    } else {\n      const snap = nodeFromJSON(data);\n      events = this.serverSyncTree_.applyServerOverwrite(path, snap);\n    }\n    let affectedPath = path;\n    if (events.length > 0) {\n      // Since we have a listener outstanding for each transaction, receiving any events\n      // is a proxy for some change having occurred.\n      affectedPath = this.rerunTransactions_(path);\n    }\n    this.eventQueue_.raiseEventsForChangedPath(affectedPath, events);\n  }\n\n  /**\n   * TODO: This should be @private but it's used by test_access.js and internal.js\n   * @param {?function(!string, *):*} callback\n   * @private\n   */\n  interceptServerData_(callback: ((a: string, b: any) => any) | null) {\n    this.interceptServerDataCallback_ = callback;\n  }\n\n  /**\n   * @param {!boolean} connectStatus\n   * @private\n   */\n  private onConnectStatus_(connectStatus: boolean) {\n    this.updateInfo_('connected', connectStatus);\n    if (connectStatus === false) {\n      this.runOnDisconnectEvents_();\n    }\n  }\n\n  /**\n   * @param {!Object} updates\n   * @private\n   */\n  private onServerInfoUpdate_(updates: Object) {\n    each(updates, (value: any, key: string) => {\n      this.updateInfo_(key, value);\n    });\n  }\n\n  /**\n   *\n   * @param {!string} pathString\n   * @param {*} value\n   * @private\n   */\n  private updateInfo_(pathString: string, value: any) {\n    const path = new Path('/.info/' + pathString);\n    const newNode = nodeFromJSON(value);\n    this.infoData_.updateSnapshot(path, newNode);\n    const events = this.infoSyncTree_.applyServerOverwrite(path, newNode);\n    this.eventQueue_.raiseEventsForChangedPath(path, events);\n  }\n\n  /**\n   * @return {!number}\n   * @private\n   */\n  private getNextWriteId_(): number {\n    return this.nextWriteId_++;\n  }\n\n  /**\n   * @param {!Path} path\n   * @param {*} newVal\n   * @param {number|string|null} newPriority\n   * @param {?function(?Error, *=)} onComplete\n   */\n  setWithPriority(\n    path: Path,\n    newVal: any,\n    newPriority: number | string | null,\n    onComplete: ((status: Error | null, errorReason?: string) => void) | null\n  ) {\n    this.log_('set', {\n      path: path.toString(),\n      value: newVal,\n      priority: newPriority\n    });\n\n    // TODO: Optimize this behavior to either (a) store flag to skip resolving where possible and / or\n    // (b) store unresolved paths on JSON parse\n    const serverValues = this.generateServerValues();\n    const newNodeUnresolved = nodeFromJSON(newVal, newPriority);\n    const newNode = resolveDeferredValueSnapshot(\n      newNodeUnresolved,\n      serverValues\n    );\n\n    const writeId = this.getNextWriteId_();\n    const events = this.serverSyncTree_.applyUserOverwrite(\n      path,\n      newNode,\n      writeId,\n      true\n    );\n    this.eventQueue_.queueEvents(events);\n    this.server_.put(\n      path.toString(),\n      newNodeUnresolved.val(/*export=*/ true),\n      (status, errorReason) => {\n        const success = status === 'ok';\n        if (!success) {\n          warn('set at ' + path + ' failed: ' + status);\n        }\n\n        const clearEvents = this.serverSyncTree_.ackUserWrite(\n          writeId,\n          !success\n        );\n        this.eventQueue_.raiseEventsForChangedPath(path, clearEvents);\n        this.callOnCompleteCallback(onComplete, status, errorReason);\n      }\n    );\n    const affectedPath = this.abortTransactions_(path);\n    this.rerunTransactions_(affectedPath);\n    // We queued the events above, so just flush the queue here\n    this.eventQueue_.raiseEventsForChangedPath(affectedPath, []);\n  }\n\n  /**\n   * @param {!Path} path\n   * @param {!Object} childrenToMerge\n   * @param {?function(?Error, *=)} onComplete\n   */\n  update(\n    path: Path,\n    childrenToMerge: { [k: string]: any },\n    onComplete: ((status: Error | null, errorReason?: string) => void) | null\n  ) {\n    this.log_('update', { path: path.toString(), value: childrenToMerge });\n\n    // Start with our existing data and merge each child into it.\n    let empty = true;\n    const serverValues = this.generateServerValues();\n    const changedChildren: { [k: string]: Node } = {};\n    forEach(childrenToMerge, (changedKey: string, changedValue: any) => {\n      empty = false;\n      const newNodeUnresolved = nodeFromJSON(changedValue);\n      changedChildren[changedKey] = resolveDeferredValueSnapshot(\n        newNodeUnresolved,\n        serverValues\n      );\n    });\n\n    if (!empty) {\n      const writeId = this.getNextWriteId_();\n      const events = this.serverSyncTree_.applyUserMerge(\n        path,\n        changedChildren,\n        writeId\n      );\n      this.eventQueue_.queueEvents(events);\n      this.server_.merge(\n        path.toString(),\n        childrenToMerge,\n        (status, errorReason) => {\n          const success = status === 'ok';\n          if (!success) {\n            warn('update at ' + path + ' failed: ' + status);\n          }\n\n          const clearEvents = this.serverSyncTree_.ackUserWrite(\n            writeId,\n            !success\n          );\n          const affectedPath =\n            clearEvents.length > 0 ? this.rerunTransactions_(path) : path;\n          this.eventQueue_.raiseEventsForChangedPath(affectedPath, clearEvents);\n          this.callOnCompleteCallback(onComplete, status, errorReason);\n        }\n      );\n\n      forEach(childrenToMerge, (changedPath: string) => {\n        const affectedPath = this.abortTransactions_(path.child(changedPath));\n        this.rerunTransactions_(affectedPath);\n      });\n\n      // We queued the events above, so just flush the queue here\n      this.eventQueue_.raiseEventsForChangedPath(path, []);\n    } else {\n      log(\"update() called with empty data.  Don't do anything.\");\n      this.callOnCompleteCallback(onComplete, 'ok');\n    }\n  }\n\n  /**\n   * Applies all of the changes stored up in the onDisconnect_ tree.\n   * @private\n   */\n  private runOnDisconnectEvents_() {\n    this.log_('onDisconnectEvents');\n\n    const serverValues = this.generateServerValues();\n    const resolvedOnDisconnectTree = resolveDeferredValueTree(\n      this.onDisconnect_,\n      serverValues\n    );\n    let events: Event[] = [];\n\n    resolvedOnDisconnectTree.forEachTree(Path.Empty, (path, snap) => {\n      events = events.concat(\n        this.serverSyncTree_.applyServerOverwrite(path, snap)\n      );\n      const affectedPath = this.abortTransactions_(path);\n      this.rerunTransactions_(affectedPath);\n    });\n\n    this.onDisconnect_ = new SparseSnapshotTree();\n    this.eventQueue_.raiseEventsForChangedPath(Path.Empty, events);\n  }\n\n  /**\n   * @param {!Path} path\n   * @param {?function(?Error, *=)} onComplete\n   */\n  onDisconnectCancel(\n    path: Path,\n    onComplete: ((status: Error | null, errorReason?: string) => void) | null\n  ) {\n    this.server_.onDisconnectCancel(path.toString(), (status, errorReason) => {\n      if (status === 'ok') {\n        this.onDisconnect_.forget(path);\n      }\n      this.callOnCompleteCallback(onComplete, status, errorReason);\n    });\n  }\n\n  /**\n   * @param {!Path} path\n   * @param {*} value\n   * @param {?function(?Error, *=)} onComplete\n   */\n  onDisconnectSet(\n    path: Path,\n    value: any,\n    onComplete: ((status: Error | null, errorReason?: string) => void) | null\n  ) {\n    const newNode = nodeFromJSON(value);\n    this.server_.onDisconnectPut(\n      path.toString(),\n      newNode.val(/*export=*/ true),\n      (status, errorReason) => {\n        if (status === 'ok') {\n          this.onDisconnect_.remember(path, newNode);\n        }\n        this.callOnCompleteCallback(onComplete, status, errorReason);\n      }\n    );\n  }\n\n  /**\n   * @param {!Path} path\n   * @param {*} value\n   * @param {*} priority\n   * @param {?function(?Error, *=)} onComplete\n   */\n  onDisconnectSetWithPriority(\n    path: Path,\n    value: any,\n    priority: any,\n    onComplete: ((status: Error | null, errorReason?: string) => void) | null\n  ) {\n    const newNode = nodeFromJSON(value, priority);\n    this.server_.onDisconnectPut(\n      path.toString(),\n      newNode.val(/*export=*/ true),\n      (status, errorReason) => {\n        if (status === 'ok') {\n          this.onDisconnect_.remember(path, newNode);\n        }\n        this.callOnCompleteCallback(onComplete, status, errorReason);\n      }\n    );\n  }\n\n  /**\n   * @param {!Path} path\n   * @param {*} childrenToMerge\n   * @param {?function(?Error, *=)} onComplete\n   */\n  onDisconnectUpdate(\n    path: Path,\n    childrenToMerge: { [k: string]: any },\n    onComplete: ((status: Error | null, errorReason?: string) => void) | null\n  ) {\n    if (isEmpty(childrenToMerge)) {\n      log(\n        \"onDisconnect().update() called with empty data.  Don't do anything.\"\n      );\n      this.callOnCompleteCallback(onComplete, 'ok');\n      return;\n    }\n\n    this.server_.onDisconnectMerge(\n      path.toString(),\n      childrenToMerge,\n      (status, errorReason) => {\n        if (status === 'ok') {\n          forEach(childrenToMerge, (childName: string, childNode: any) => {\n            const newChildNode = nodeFromJSON(childNode);\n            this.onDisconnect_.remember(path.child(childName), newChildNode);\n          });\n        }\n        this.callOnCompleteCallback(onComplete, status, errorReason);\n      }\n    );\n  }\n\n  /**\n   * @param {!Query} query\n   * @param {!EventRegistration} eventRegistration\n   */\n  addEventCallbackForQuery(query: Query, eventRegistration: EventRegistration) {\n    let events;\n    if (query.path.getFront() === '.info') {\n      events = this.infoSyncTree_.addEventRegistration(\n        query,\n        eventRegistration\n      );\n    } else {\n      events = this.serverSyncTree_.addEventRegistration(\n        query,\n        eventRegistration\n      );\n    }\n    this.eventQueue_.raiseEventsAtPath(query.path, events);\n  }\n\n  /**\n   * @param {!Query} query\n   * @param {?EventRegistration} eventRegistration\n   */\n  removeEventCallbackForQuery(\n    query: Query,\n    eventRegistration: EventRegistration\n  ) {\n    // These are guaranteed not to raise events, since we're not passing in a cancelError. However, we can future-proof\n    // a little bit by handling the return values anyways.\n    let events;\n    if (query.path.getFront() === '.info') {\n      events = this.infoSyncTree_.removeEventRegistration(\n        query,\n        eventRegistration\n      );\n    } else {\n      events = this.serverSyncTree_.removeEventRegistration(\n        query,\n        eventRegistration\n      );\n    }\n    this.eventQueue_.raiseEventsAtPath(query.path, events);\n  }\n\n  interrupt() {\n    if (this.persistentConnection_) {\n      this.persistentConnection_.interrupt(INTERRUPT_REASON);\n    }\n  }\n\n  resume() {\n    if (this.persistentConnection_) {\n      this.persistentConnection_.resume(INTERRUPT_REASON);\n    }\n  }\n\n  stats(showDelta: boolean = false) {\n    if (typeof console === 'undefined') return;\n\n    let stats: { [k: string]: any };\n    if (showDelta) {\n      if (!this.statsListener_)\n        this.statsListener_ = new StatsListener(this.stats_);\n      stats = this.statsListener_.get();\n    } else {\n      stats = this.stats_.get();\n    }\n\n    const longestName = Object.keys(stats).reduce(\n      (previousValue, currentValue) =>\n        Math.max(currentValue.length, previousValue),\n      0\n    );\n\n    forEach(stats, (stat: string, value: any) => {\n      // pad stat names to be the same length (plus 2 extra spaces).\n      for (let i = stat.length; i < longestName + 2; i++) stat += ' ';\n      console.log(stat + value);\n    });\n  }\n\n  statsIncrementCounter(metric: string) {\n    this.stats_.incrementCounter(metric);\n    this.statsReporter_.includeStat(metric);\n  }\n\n  /**\n   * @param {...*} var_args\n   * @private\n   */\n  private log_(...var_args: any[]) {\n    let prefix = '';\n    if (this.persistentConnection_) {\n      prefix = this.persistentConnection_.id + ':';\n    }\n    log(prefix, ...var_args);\n  }\n\n  /**\n   * @param {?function(?Error, *=)} callback\n   * @param {!string} status\n   * @param {?string=} errorReason\n   */\n  callOnCompleteCallback(\n    callback: ((status: Error | null, errorReason?: string) => void) | null,\n    status: string,\n    errorReason?: string | null\n  ) {\n    if (callback) {\n      exceptionGuard(function() {\n        if (status == 'ok') {\n          callback(null);\n        } else {\n          const code = (status || 'error').toUpperCase();\n          let message = code;\n          if (errorReason) message += ': ' + errorReason;\n\n          const error = new Error(message);\n          (error as any).code = code;\n          callback(error);\n        }\n      });\n    }\n  }\n\n  get database(): Database {\n    return this.__database || (this.__database = new Database(this));\n  }\n}\n","/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\nimport { generateWithValues, resolveDeferredValueSnapshot, resolveDeferredValueTree } from './util/ServerValues';\nimport { nodeFromJSON } from './snap/nodeFromJSON';\nimport { Path } from './util/Path';\nimport { SparseSnapshotTree } from './SparseSnapshotTree';\nimport { SyncTree } from './SyncTree';\nimport { SnapshotHolder } from './SnapshotHolder';\nimport { stringify } from '../../utils/json';\nimport { beingCrawled, each, exceptionGuard, warn, log } from './util/util';\nimport { map, forEach, isEmpty } from '../../utils/obj';\nimport { AuthTokenProvider } from './AuthTokenProvider';\nimport { StatsManager } from './stats/StatsManager';\nimport { StatsReporter } from './stats/StatsReporter';\nimport { StatsListener } from './stats/StatsListener';\nimport { EventQueue } from './view/EventQueue';\nimport { PersistentConnection } from './PersistentConnection';\nimport { ReadonlyRestClient } from './ReadonlyRestClient';\nimport { Database } from '../api/Database';\nvar INTERRUPT_REASON = 'repo_interrupt';\n/**\n * A connection to a single data repository.\n */\nvar Repo = (function () {\n    /**\n     * @param {!RepoInfo} repoInfo_\n     * @param {boolean} forceRestClient\n     * @param {!FirebaseApp} app\n     */\n    function Repo(repoInfo_, forceRestClient, app) {\n        var _this = this;\n        this.repoInfo_ = repoInfo_;\n        this.app = app;\n        this.dataUpdateCount = 0;\n        this.statsListener_ = null;\n        this.eventQueue_ = new EventQueue();\n        this.nextWriteId_ = 1;\n        this.interceptServerDataCallback_ = null;\n        // A list of data pieces and paths to be set when this client disconnects.\n        this.onDisconnect_ = new SparseSnapshotTree();\n        /**\n         * TODO: This should be @private but it's used by test_access.js and internal.js\n         * @type {?PersistentConnection}\n         */\n        this.persistentConnection_ = null;\n        /** @type {!AuthTokenProvider} */\n        var authTokenProvider = new AuthTokenProvider(app);\n        this.stats_ = StatsManager.getCollection(repoInfo_);\n        if (forceRestClient || beingCrawled()) {\n            this.server_ = new ReadonlyRestClient(this.repoInfo_, this.onDataUpdate_.bind(this), authTokenProvider);\n            // Minor hack: Fire onConnect immediately, since there's no actual connection.\n            setTimeout(this.onConnectStatus_.bind(this, true), 0);\n        }\n        else {\n            var authOverride = app.options['databaseAuthVariableOverride'];\n            // Validate authOverride\n            if (typeof authOverride !== 'undefined' && authOverride !== null) {\n                if (typeof authOverride !== 'object') {\n                    throw new Error('Only objects are supported for option databaseAuthVariableOverride');\n                }\n                try {\n                    stringify(authOverride);\n                }\n                catch (e) {\n                    throw new Error('Invalid authOverride provided: ' + e);\n                }\n            }\n            this.persistentConnection_ = new PersistentConnection(this.repoInfo_, this.onDataUpdate_.bind(this), this.onConnectStatus_.bind(this), this.onServerInfoUpdate_.bind(this), authTokenProvider, authOverride);\n            this.server_ = this.persistentConnection_;\n        }\n        authTokenProvider.addTokenChangeListener(function (token) {\n            _this.server_.refreshAuthToken(token);\n        });\n        // In the case of multiple Repos for the same repoInfo (i.e. there are multiple Firebase.Contexts being used),\n        // we only want to create one StatsReporter.  As such, we'll report stats over the first Repo created.\n        this.statsReporter_ = StatsManager.getOrCreateReporter(repoInfo_, function () { return new StatsReporter(_this.stats_, _this.server_); });\n        this.transactions_init_();\n        // Used for .info.\n        this.infoData_ = new SnapshotHolder();\n        this.infoSyncTree_ = new SyncTree({\n            startListening: function (query, tag, currentHashFn, onComplete) {\n                var infoEvents = [];\n                var node = _this.infoData_.getNode(query.path);\n                // This is possibly a hack, but we have different semantics for .info endpoints. We don't raise null events\n                // on initial data...\n                if (!node.isEmpty()) {\n                    infoEvents = _this.infoSyncTree_.applyServerOverwrite(query.path, node);\n                    setTimeout(function () {\n                        onComplete('ok');\n                    }, 0);\n                }\n                return infoEvents;\n            },\n            stopListening: function () { }\n        });\n        this.updateInfo_('connected', false);\n        this.serverSyncTree_ = new SyncTree({\n            startListening: function (query, tag, currentHashFn, onComplete) {\n                _this.server_.listen(query, currentHashFn, tag, function (status, data) {\n                    var events = onComplete(status, data);\n                    _this.eventQueue_.raiseEventsForChangedPath(query.path, events);\n                });\n                // No synchronous events for network-backed sync trees\n                return [];\n            },\n            stopListening: function (query, tag) {\n                _this.server_.unlisten(query, tag);\n            }\n        });\n    }\n    /**\n     * @return {string}  The URL corresponding to the root of this Firebase.\n     */\n    Repo.prototype.toString = function () {\n        return ((this.repoInfo_.secure ? 'https://' : 'http://') + this.repoInfo_.host);\n    };\n    /**\n     * @return {!string} The namespace represented by the repo.\n     */\n    Repo.prototype.name = function () {\n        return this.repoInfo_.namespace;\n    };\n    /**\n     * @return {!number} The time in milliseconds, taking the server offset into account if we have one.\n     */\n    Repo.prototype.serverTime = function () {\n        var offsetNode = this.infoData_.getNode(new Path('.info/serverTimeOffset'));\n        var offset = offsetNode.val() || 0;\n        return new Date().getTime() + offset;\n    };\n    /**\n     * Generate ServerValues using some variables from the repo object.\n     * @return {!Object}\n     */\n    Repo.prototype.generateServerValues = function () {\n        return generateWithValues({\n            timestamp: this.serverTime()\n        });\n    };\n    /**\n     * Called by realtime when we get new messages from the server.\n     *\n     * @private\n     * @param {string} pathString\n     * @param {*} data\n     * @param {boolean} isMerge\n     * @param {?number} tag\n     */\n    Repo.prototype.onDataUpdate_ = function (pathString, data, isMerge, tag) {\n        // For testing.\n        this.dataUpdateCount++;\n        var path = new Path(pathString);\n        data = this.interceptServerDataCallback_\n            ? this.interceptServerDataCallback_(pathString, data)\n            : data;\n        var events = [];\n        if (tag) {\n            if (isMerge) {\n                var taggedChildren = map(data, function (raw) {\n                    return nodeFromJSON(raw);\n                });\n                events = this.serverSyncTree_.applyTaggedQueryMerge(path, taggedChildren, tag);\n            }\n            else {\n                var taggedSnap = nodeFromJSON(data);\n                events = this.serverSyncTree_.applyTaggedQueryOverwrite(path, taggedSnap, tag);\n            }\n        }\n        else if (isMerge) {\n            var changedChildren = map(data, function (raw) {\n                return nodeFromJSON(raw);\n            });\n            events = this.serverSyncTree_.applyServerMerge(path, changedChildren);\n        }\n        else {\n            var snap = nodeFromJSON(data);\n            events = this.serverSyncTree_.applyServerOverwrite(path, snap);\n        }\n        var affectedPath = path;\n        if (events.length > 0) {\n            // Since we have a listener outstanding for each transaction, receiving any events\n            // is a proxy for some change having occurred.\n            affectedPath = this.rerunTransactions_(path);\n        }\n        this.eventQueue_.raiseEventsForChangedPath(affectedPath, events);\n    };\n    /**\n     * TODO: This should be @private but it's used by test_access.js and internal.js\n     * @param {?function(!string, *):*} callback\n     * @private\n     */\n    Repo.prototype.interceptServerData_ = function (callback) {\n        this.interceptServerDataCallback_ = callback;\n    };\n    /**\n     * @param {!boolean} connectStatus\n     * @private\n     */\n    Repo.prototype.onConnectStatus_ = function (connectStatus) {\n        this.updateInfo_('connected', connectStatus);\n        if (connectStatus === false) {\n            this.runOnDisconnectEvents_();\n        }\n    };\n    /**\n     * @param {!Object} updates\n     * @private\n     */\n    Repo.prototype.onServerInfoUpdate_ = function (updates) {\n        var _this = this;\n        each(updates, function (value, key) {\n            _this.updateInfo_(key, value);\n        });\n    };\n    /**\n     *\n     * @param {!string} pathString\n     * @param {*} value\n     * @private\n     */\n    Repo.prototype.updateInfo_ = function (pathString, value) {\n        var path = new Path('/.info/' + pathString);\n        var newNode = nodeFromJSON(value);\n        this.infoData_.updateSnapshot(path, newNode);\n        var events = this.infoSyncTree_.applyServerOverwrite(path, newNode);\n        this.eventQueue_.raiseEventsForChangedPath(path, events);\n    };\n    /**\n     * @return {!number}\n     * @private\n     */\n    Repo.prototype.getNextWriteId_ = function () {\n        return this.nextWriteId_++;\n    };\n    /**\n     * @param {!Path} path\n     * @param {*} newVal\n     * @param {number|string|null} newPriority\n     * @param {?function(?Error, *=)} onComplete\n     */\n    Repo.prototype.setWithPriority = function (path, newVal, newPriority, onComplete) {\n        var _this = this;\n        this.log_('set', {\n            path: path.toString(),\n            value: newVal,\n            priority: newPriority\n        });\n        // TODO: Optimize this behavior to either (a) store flag to skip resolving where possible and / or\n        // (b) store unresolved paths on JSON parse\n        var serverValues = this.generateServerValues();\n        var newNodeUnresolved = nodeFromJSON(newVal, newPriority);\n        var newNode = resolveDeferredValueSnapshot(newNodeUnresolved, serverValues);\n        var writeId = this.getNextWriteId_();\n        var events = this.serverSyncTree_.applyUserOverwrite(path, newNode, writeId, true);\n        this.eventQueue_.queueEvents(events);\n        this.server_.put(path.toString(), newNodeUnresolved.val(/*export=*/ true), function (status, errorReason) {\n            var success = status === 'ok';\n            if (!success) {\n                warn('set at ' + path + ' failed: ' + status);\n            }\n            var clearEvents = _this.serverSyncTree_.ackUserWrite(writeId, !success);\n            _this.eventQueue_.raiseEventsForChangedPath(path, clearEvents);\n            _this.callOnCompleteCallback(onComplete, status, errorReason);\n        });\n        var affectedPath = this.abortTransactions_(path);\n        this.rerunTransactions_(affectedPath);\n        // We queued the events above, so just flush the queue here\n        this.eventQueue_.raiseEventsForChangedPath(affectedPath, []);\n    };\n    /**\n     * @param {!Path} path\n     * @param {!Object} childrenToMerge\n     * @param {?function(?Error, *=)} onComplete\n     */\n    Repo.prototype.update = function (path, childrenToMerge, onComplete) {\n        var _this = this;\n        this.log_('update', { path: path.toString(), value: childrenToMerge });\n        // Start with our existing data and merge each child into it.\n        var empty = true;\n        var serverValues = this.generateServerValues();\n        var changedChildren = {};\n        forEach(childrenToMerge, function (changedKey, changedValue) {\n            empty = false;\n            var newNodeUnresolved = nodeFromJSON(changedValue);\n            changedChildren[changedKey] = resolveDeferredValueSnapshot(newNodeUnresolved, serverValues);\n        });\n        if (!empty) {\n            var writeId_1 = this.getNextWriteId_();\n            var events = this.serverSyncTree_.applyUserMerge(path, changedChildren, writeId_1);\n            this.eventQueue_.queueEvents(events);\n            this.server_.merge(path.toString(), childrenToMerge, function (status, errorReason) {\n                var success = status === 'ok';\n                if (!success) {\n                    warn('update at ' + path + ' failed: ' + status);\n                }\n                var clearEvents = _this.serverSyncTree_.ackUserWrite(writeId_1, !success);\n                var affectedPath = clearEvents.length > 0 ? _this.rerunTransactions_(path) : path;\n                _this.eventQueue_.raiseEventsForChangedPath(affectedPath, clearEvents);\n                _this.callOnCompleteCallback(onComplete, status, errorReason);\n            });\n            forEach(childrenToMerge, function (changedPath) {\n                var affectedPath = _this.abortTransactions_(path.child(changedPath));\n                _this.rerunTransactions_(affectedPath);\n            });\n            // We queued the events above, so just flush the queue here\n            this.eventQueue_.raiseEventsForChangedPath(path, []);\n        }\n        else {\n            log(\"update() called with empty data.  Don't do anything.\");\n            this.callOnCompleteCallback(onComplete, 'ok');\n        }\n    };\n    /**\n     * Applies all of the changes stored up in the onDisconnect_ tree.\n     * @private\n     */\n    Repo.prototype.runOnDisconnectEvents_ = function () {\n        var _this = this;\n        this.log_('onDisconnectEvents');\n        var serverValues = this.generateServerValues();\n        var resolvedOnDisconnectTree = resolveDeferredValueTree(this.onDisconnect_, serverValues);\n        var events = [];\n        resolvedOnDisconnectTree.forEachTree(Path.Empty, function (path, snap) {\n            events = events.concat(_this.serverSyncTree_.applyServerOverwrite(path, snap));\n            var affectedPath = _this.abortTransactions_(path);\n            _this.rerunTransactions_(affectedPath);\n        });\n        this.onDisconnect_ = new SparseSnapshotTree();\n        this.eventQueue_.raiseEventsForChangedPath(Path.Empty, events);\n    };\n    /**\n     * @param {!Path} path\n     * @param {?function(?Error, *=)} onComplete\n     */\n    Repo.prototype.onDisconnectCancel = function (path, onComplete) {\n        var _this = this;\n        this.server_.onDisconnectCancel(path.toString(), function (status, errorReason) {\n            if (status === 'ok') {\n                _this.onDisconnect_.forget(path);\n            }\n            _this.callOnCompleteCallback(onComplete, status, errorReason);\n        });\n    };\n    /**\n     * @param {!Path} path\n     * @param {*} value\n     * @param {?function(?Error, *=)} onComplete\n     */\n    Repo.prototype.onDisconnectSet = function (path, value, onComplete) {\n        var _this = this;\n        var newNode = nodeFromJSON(value);\n        this.server_.onDisconnectPut(path.toString(), newNode.val(/*export=*/ true), function (status, errorReason) {\n            if (status === 'ok') {\n                _this.onDisconnect_.remember(path, newNode);\n            }\n            _this.callOnCompleteCallback(onComplete, status, errorReason);\n        });\n    };\n    /**\n     * @param {!Path} path\n     * @param {*} value\n     * @param {*} priority\n     * @param {?function(?Error, *=)} onComplete\n     */\n    Repo.prototype.onDisconnectSetWithPriority = function (path, value, priority, onComplete) {\n        var _this = this;\n        var newNode = nodeFromJSON(value, priority);\n        this.server_.onDisconnectPut(path.toString(), newNode.val(/*export=*/ true), function (status, errorReason) {\n            if (status === 'ok') {\n                _this.onDisconnect_.remember(path, newNode);\n            }\n            _this.callOnCompleteCallback(onComplete, status, errorReason);\n        });\n    };\n    /**\n     * @param {!Path} path\n     * @param {*} childrenToMerge\n     * @param {?function(?Error, *=)} onComplete\n     */\n    Repo.prototype.onDisconnectUpdate = function (path, childrenToMerge, onComplete) {\n        var _this = this;\n        if (isEmpty(childrenToMerge)) {\n            log(\"onDisconnect().update() called with empty data.  Don't do anything.\");\n            this.callOnCompleteCallback(onComplete, 'ok');\n            return;\n        }\n        this.server_.onDisconnectMerge(path.toString(), childrenToMerge, function (status, errorReason) {\n            if (status === 'ok') {\n                forEach(childrenToMerge, function (childName, childNode) {\n                    var newChildNode = nodeFromJSON(childNode);\n                    _this.onDisconnect_.remember(path.child(childName), newChildNode);\n                });\n            }\n            _this.callOnCompleteCallback(onComplete, status, errorReason);\n        });\n    };\n    /**\n     * @param {!Query} query\n     * @param {!EventRegistration} eventRegistration\n     */\n    Repo.prototype.addEventCallbackForQuery = function (query, eventRegistration) {\n        var events;\n        if (query.path.getFront() === '.info') {\n            events = this.infoSyncTree_.addEventRegistration(query, eventRegistration);\n        }\n        else {\n            events = this.serverSyncTree_.addEventRegistration(query, eventRegistration);\n        }\n        this.eventQueue_.raiseEventsAtPath(query.path, events);\n    };\n    /**\n     * @param {!Query} query\n     * @param {?EventRegistration} eventRegistration\n     */\n    Repo.prototype.removeEventCallbackForQuery = function (query, eventRegistration) {\n        // These are guaranteed not to raise events, since we're not passing in a cancelError. However, we can future-proof\n        // a little bit by handling the return values anyways.\n        var events;\n        if (query.path.getFront() === '.info') {\n            events = this.infoSyncTree_.removeEventRegistration(query, eventRegistration);\n        }\n        else {\n            events = this.serverSyncTree_.removeEventRegistration(query, eventRegistration);\n        }\n        this.eventQueue_.raiseEventsAtPath(query.path, events);\n    };\n    Repo.prototype.interrupt = function () {\n        if (this.persistentConnection_) {\n            this.persistentConnection_.interrupt(INTERRUPT_REASON);\n        }\n    };\n    Repo.prototype.resume = function () {\n        if (this.persistentConnection_) {\n            this.persistentConnection_.resume(INTERRUPT_REASON);\n        }\n    };\n    Repo.prototype.stats = function (showDelta) {\n        if (showDelta === void 0) { showDelta = false; }\n        if (typeof console === 'undefined')\n            return;\n        var stats;\n        if (showDelta) {\n            if (!this.statsListener_)\n                this.statsListener_ = new StatsListener(this.stats_);\n            stats = this.statsListener_.get();\n        }\n        else {\n            stats = this.stats_.get();\n        }\n        var longestName = Object.keys(stats).reduce(function (previousValue, currentValue) {\n            return Math.max(currentValue.length, previousValue);\n        }, 0);\n        forEach(stats, function (stat, value) {\n            // pad stat names to be the same length (plus 2 extra spaces).\n            for (var i = stat.length; i < longestName + 2; i++)\n                stat += ' ';\n            console.log(stat + value);\n        });\n    };\n    Repo.prototype.statsIncrementCounter = function (metric) {\n        this.stats_.incrementCounter(metric);\n        this.statsReporter_.includeStat(metric);\n    };\n    /**\n     * @param {...*} var_args\n     * @private\n     */\n    Repo.prototype.log_ = function () {\n        var var_args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            var_args[_i] = arguments[_i];\n        }\n        var prefix = '';\n        if (this.persistentConnection_) {\n            prefix = this.persistentConnection_.id + ':';\n        }\n        log.apply(void 0, [prefix].concat(var_args));\n    };\n    /**\n     * @param {?function(?Error, *=)} callback\n     * @param {!string} status\n     * @param {?string=} errorReason\n     */\n    Repo.prototype.callOnCompleteCallback = function (callback, status, errorReason) {\n        if (callback) {\n            exceptionGuard(function () {\n                if (status == 'ok') {\n                    callback(null);\n                }\n                else {\n                    var code = (status || 'error').toUpperCase();\n                    var message = code;\n                    if (errorReason)\n                        message += ': ' + errorReason;\n                    var error = new Error(message);\n                    error.code = code;\n                    callback(error);\n                }\n            });\n        }\n    };\n    Object.defineProperty(Repo.prototype, \"database\", {\n        get: function () {\n            return this.__database || (this.__database = new Database(this));\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return Repo;\n}());\nexport { Repo };\n\n\n"]}