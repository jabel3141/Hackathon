{"version":3,"sources":["src/database/realtime/BrowserPollConnection.ts","database/realtime/BrowserPollConnection.js"],"names":["FIREBASE_LONGPOLL_START_PARAM","FIREBASE_LONGPOLL_CLOSE_COMMAND","FIREBASE_LONGPOLL_COMMAND_CB_NAME","FIREBASE_LONGPOLL_DATA_CB_NAME","FIREBASE_LONGPOLL_ID_PARAM","FIREBASE_LONGPOLL_PW_PARAM","FIREBASE_LONGPOLL_SERIAL_PARAM","FIREBASE_LONGPOLL_CALLBACK_ID_PARAM","FIREBASE_LONGPOLL_SEGMENT_NUM_PARAM","FIREBASE_LONGPOLL_SEGMENTS_IN_PACKET","FIREBASE_LONGPOLL_DATA_PARAM","FIREBASE_LONGPOLL_DISCONN_FRAME_PARAM","FIREBASE_LONGPOLL_DISCONN_FRAME_REQUEST_PARAM","MAX_URL_DATA_SIZE","SEG_HEADER_SIZE","MAX_PAYLOAD_SIZE","KEEPALIVE_REQUEST_INTERVAL","LP_CONNECT_TIMEOUT","BrowserPollConnection","connId","repoInfo","transportSessionId","lastSessionId","bytesSent","bytesReceived","everConnected_","log_","stats_","getCollection","urlFn","params","connectionURL","prototype","open","onMessage","onDisconnect","_this","curSegmentNum","onDisconnect_","myPacketOrderer","isClosed_","connectTimeoutTimer_","setTimeout","onClosed_","Math","floor","scriptTagHolder","FirebaseIFrameScriptHolder","args","_i","arguments","length","command","arg1","arg2","arg3","arg4","incrementIncomingBytes_","clearTimeout","id","password","sendNewPolls","closeAfter","Error","pN","data","handleResponse","urlParams","random","uniqueCallbackIdentifier","location","href","indexOf","connectURL","addTag","start","startLongPoll","addDisconnectPingFrame","forceAllow","forceAllow_","forceDisallow","forceDisallow_","isAvailable","document","createElement","markConnectionHealthy","shutdown_","close","myDisconnFrame","body","removeChild","send","dataStr","incrementCounter","base64data","dataSegs","i","enqueueSegment","pw","src","style","display","appendChild","commandCB","onMessageCB","outstandingRequests","pendingSegs","currentSerial","window","myIFrame","createIFrame_","script","substr","currentDomain","domain","iframeContents","doc","write","e","stack","iframe","a","contentWindow","contentDocument","alive","innerHTML","myID","myPW","theURL","nodeRestRequest","newRequest_","count","curDataString","nextSeg","d","theSeg","shift","seg","ts","addLongPollTag_","segnum","totalsegs","push","url","serial","add","doNewRequest","remove","keepaliveTimeout","readyStateCB","loadCB","doNodeLongPoll","newScript_1","type","async","onload","onreadystatechange","rstate","readyState","parentNode","onerror"],"mappings":"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","file":"BrowserPollConnection.js","sourcesContent":["/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\nimport {\n  base64Encode,\n  executeWhenDOMReady,\n  isChromeExtensionContentScript,\n  isWindowsStoreApp,\n  log,\n  logWrapper,\n  LUIDGenerator,\n  splitStringBySize\n} from '../core/util/util';\nimport { CountedSet } from '../core/util/CountedSet';\nimport { StatsManager } from '../core/stats/StatsManager';\nimport { PacketReceiver } from './polling/PacketReceiver';\nimport {\n  FORGE_DOMAIN,\n  FORGE_REF,\n  LAST_SESSION_PARAM,\n  LONG_POLLING,\n  PROTOCOL_VERSION,\n  REFERER_PARAM,\n  TRANSPORT_SESSION_PARAM,\n  VERSION_PARAM\n} from './Constants';\nimport { stringify } from '../../utils/json';\nimport { isNodeSdk } from '../../utils/environment';\nimport { Transport } from './Transport';\nimport { RepoInfo } from '../core/RepoInfo';\nimport { StatsCollection } from '../core/stats/StatsCollection';\n\n// URL query parameters associated with longpolling\nexport const FIREBASE_LONGPOLL_START_PARAM = 'start';\nexport const FIREBASE_LONGPOLL_CLOSE_COMMAND = 'close';\nexport const FIREBASE_LONGPOLL_COMMAND_CB_NAME = 'pLPCommand';\nexport const FIREBASE_LONGPOLL_DATA_CB_NAME = 'pRTLPCB';\nexport const FIREBASE_LONGPOLL_ID_PARAM = 'id';\nexport const FIREBASE_LONGPOLL_PW_PARAM = 'pw';\nexport const FIREBASE_LONGPOLL_SERIAL_PARAM = 'ser';\nexport const FIREBASE_LONGPOLL_CALLBACK_ID_PARAM = 'cb';\nexport const FIREBASE_LONGPOLL_SEGMENT_NUM_PARAM = 'seg';\nexport const FIREBASE_LONGPOLL_SEGMENTS_IN_PACKET = 'ts';\nexport const FIREBASE_LONGPOLL_DATA_PARAM = 'd';\nexport const FIREBASE_LONGPOLL_DISCONN_FRAME_PARAM = 'disconn';\nexport const FIREBASE_LONGPOLL_DISCONN_FRAME_REQUEST_PARAM = 'dframe';\n\n//Data size constants.\n//TODO: Perf: the maximum length actually differs from browser to browser.\n// We should check what browser we're on and set accordingly.\nconst MAX_URL_DATA_SIZE = 1870;\nconst SEG_HEADER_SIZE = 30; //ie: &seg=8299234&ts=982389123&d=\nconst MAX_PAYLOAD_SIZE = MAX_URL_DATA_SIZE - SEG_HEADER_SIZE;\n\n/**\n * Keepalive period\n * send a fresh request at minimum every 25 seconds. Opera has a maximum request\n * length of 30 seconds that we can't exceed.\n * @const\n * @type {number}\n */\nconst KEEPALIVE_REQUEST_INTERVAL = 25000;\n\n/**\n * How long to wait before aborting a long-polling connection attempt.\n * @const\n * @type {number}\n */\nconst LP_CONNECT_TIMEOUT = 30000;\n\n/**\n * This class manages a single long-polling connection.\n *\n * @constructor\n * @implements {Transport}\n */\nexport class BrowserPollConnection implements Transport {\n  bytesSent = 0;\n  bytesReceived = 0;\n  urlFn: (params: object) => string;\n  scriptTagHolder: FirebaseIFrameScriptHolder;\n  myDisconnFrame: HTMLIFrameElement;\n  curSegmentNum: number;\n  myPacketOrderer: PacketReceiver;\n  id: string;\n  password: string;\n  private log_: (...a: any[]) => void;\n  private stats_: StatsCollection;\n  private everConnected_ = false;\n  private isClosed_: boolean;\n  private connectTimeoutTimer_: number | null;\n  private onDisconnect_: ((a?: boolean) => void) | null;\n\n  /**\n   * @param {string} connId An identifier for this connection, used for logging\n   * @param {RepoInfo} repoInfo The info for the endpoint to send data to.\n   * @param {string=} transportSessionId Optional transportSessionid if we are reconnecting for an existing\n   *                                         transport session\n   * @param {string=}  lastSessionId Optional lastSessionId if the PersistentConnection has already created a\n   *                                     connection previously\n   */\n  constructor(\n    public connId: string,\n    public repoInfo: RepoInfo,\n    public transportSessionId?: string,\n    public lastSessionId?: string\n  ) {\n    this.log_ = logWrapper(connId);\n    this.stats_ = StatsManager.getCollection(repoInfo);\n    this.urlFn = (params: { [k: string]: string }) =>\n      repoInfo.connectionURL(LONG_POLLING, params);\n  }\n\n  /**\n   *\n   * @param {function(Object)} onMessage Callback when messages arrive\n   * @param {function()} onDisconnect Callback with connection lost.\n   */\n  open(onMessage: (msg: Object) => void, onDisconnect: (a?: boolean) => void) {\n    this.curSegmentNum = 0;\n    this.onDisconnect_ = onDisconnect;\n    this.myPacketOrderer = new PacketReceiver(onMessage);\n    this.isClosed_ = false;\n\n    this.connectTimeoutTimer_ = setTimeout(() => {\n      this.log_('Timed out trying to connect.');\n      // Make sure we clear the host cache\n      this.onClosed_();\n      this.connectTimeoutTimer_ = null;\n    }, Math.floor(LP_CONNECT_TIMEOUT)) as any;\n\n    // Ensure we delay the creation of the iframe until the DOM is loaded.\n    executeWhenDOMReady(() => {\n      if (this.isClosed_) return;\n\n      //Set up a callback that gets triggered once a connection is set up.\n      this.scriptTagHolder = new FirebaseIFrameScriptHolder(\n        (...args) => {\n          const [command, arg1, arg2, arg3, arg4] = args;\n          this.incrementIncomingBytes_(args);\n          if (!this.scriptTagHolder) return; // we closed the connection.\n\n          if (this.connectTimeoutTimer_) {\n            clearTimeout(this.connectTimeoutTimer_);\n            this.connectTimeoutTimer_ = null;\n          }\n          this.everConnected_ = true;\n          if (command == FIREBASE_LONGPOLL_START_PARAM) {\n            this.id = arg1;\n            this.password = arg2;\n          } else if (command === FIREBASE_LONGPOLL_CLOSE_COMMAND) {\n            // Don't clear the host cache. We got a response from the server, so we know it's reachable\n            if (arg1) {\n              // We aren't expecting any more data (other than what the server's already in the process of sending us\n              // through our already open polls), so don't send any more.\n              this.scriptTagHolder.sendNewPolls = false;\n\n              // arg1 in this case is the last response number sent by the server. We should try to receive\n              // all of the responses up to this one before closing\n              this.myPacketOrderer.closeAfter(arg1, () => {\n                this.onClosed_();\n              });\n            } else {\n              this.onClosed_();\n            }\n          } else {\n            throw new Error('Unrecognized command received: ' + command);\n          }\n        },\n        (...args) => {\n          const [pN, data] = args;\n          this.incrementIncomingBytes_(args);\n          this.myPacketOrderer.handleResponse(pN, data);\n        },\n        () => {\n          this.onClosed_();\n        },\n        this.urlFn\n      );\n\n      //Send the initial request to connect. The serial number is simply to keep the browser from pulling previous results\n      //from cache.\n      const urlParams: { [k: string]: string | number } = {};\n      urlParams[FIREBASE_LONGPOLL_START_PARAM] = 't';\n      urlParams[FIREBASE_LONGPOLL_SERIAL_PARAM] = Math.floor(\n        Math.random() * 100000000\n      );\n      if (this.scriptTagHolder.uniqueCallbackIdentifier)\n        urlParams[\n          FIREBASE_LONGPOLL_CALLBACK_ID_PARAM\n        ] = this.scriptTagHolder.uniqueCallbackIdentifier;\n      urlParams[VERSION_PARAM] = PROTOCOL_VERSION;\n      if (this.transportSessionId) {\n        urlParams[TRANSPORT_SESSION_PARAM] = this.transportSessionId;\n      }\n      if (this.lastSessionId) {\n        urlParams[LAST_SESSION_PARAM] = this.lastSessionId;\n      }\n      if (\n        !isNodeSdk() &&\n        typeof location !== 'undefined' &&\n        location.href &&\n        location.href.indexOf(FORGE_DOMAIN) !== -1\n      ) {\n        urlParams[REFERER_PARAM] = FORGE_REF;\n      }\n      const connectURL = this.urlFn(urlParams);\n      this.log_('Connecting via long-poll to ' + connectURL);\n      this.scriptTagHolder.addTag(connectURL, () => {\n        /* do nothing */\n      });\n    });\n  }\n\n  /**\n   * Call this when a handshake has completed successfully and we want to consider the connection established\n   */\n  start() {\n    this.scriptTagHolder.startLongPoll(this.id, this.password);\n    this.addDisconnectPingFrame(this.id, this.password);\n  }\n\n  private static forceAllow_: boolean;\n\n  /**\n   * Forces long polling to be considered as a potential transport\n   */\n  static forceAllow() {\n    BrowserPollConnection.forceAllow_ = true;\n  }\n\n  private static forceDisallow_: boolean;\n\n  /**\n   * Forces longpolling to not be considered as a potential transport\n   */\n  static forceDisallow() {\n    BrowserPollConnection.forceDisallow_ = true;\n  }\n\n  // Static method, use string literal so it can be accessed in a generic way\n  static isAvailable() {\n    // NOTE: In React-Native there's normally no 'document', but if you debug a React-Native app in\n    // the Chrome debugger, 'document' is defined, but document.createElement is null (2015/06/08).\n    return (\n      BrowserPollConnection.forceAllow_ ||\n      (!BrowserPollConnection.forceDisallow_ &&\n        typeof document !== 'undefined' &&\n        document.createElement != null &&\n        !isChromeExtensionContentScript() &&\n        !isWindowsStoreApp() &&\n        !isNodeSdk())\n    );\n  }\n\n  /**\n   * No-op for polling\n   */\n  markConnectionHealthy() {}\n\n  /**\n   * Stops polling and cleans up the iframe\n   * @private\n   */\n  private shutdown_() {\n    this.isClosed_ = true;\n\n    if (this.scriptTagHolder) {\n      this.scriptTagHolder.close();\n      this.scriptTagHolder = null;\n    }\n\n    //remove the disconnect frame, which will trigger an XHR call to the server to tell it we're leaving.\n    if (this.myDisconnFrame) {\n      document.body.removeChild(this.myDisconnFrame);\n      this.myDisconnFrame = null;\n    }\n\n    if (this.connectTimeoutTimer_) {\n      clearTimeout(this.connectTimeoutTimer_);\n      this.connectTimeoutTimer_ = null;\n    }\n  }\n\n  /**\n   * Triggered when this transport is closed\n   * @private\n   */\n  private onClosed_() {\n    if (!this.isClosed_) {\n      this.log_('Longpoll is closing itself');\n      this.shutdown_();\n\n      if (this.onDisconnect_) {\n        this.onDisconnect_(this.everConnected_);\n        this.onDisconnect_ = null;\n      }\n    }\n  }\n\n  /**\n   * External-facing close handler. RealTime has requested we shut down. Kill our connection and tell the server\n   * that we've left.\n   */\n  close() {\n    if (!this.isClosed_) {\n      this.log_('Longpoll is being closed.');\n      this.shutdown_();\n    }\n  }\n\n  /**\n   * Send the JSON object down to the server. It will need to be stringified, base64 encoded, and then\n   * broken into chunks (since URLs have a small maximum length).\n   * @param {!Object} data The JSON data to transmit.\n   */\n  send(data: Object) {\n    const dataStr = stringify(data);\n    this.bytesSent += dataStr.length;\n    this.stats_.incrementCounter('bytes_sent', dataStr.length);\n\n    //first, lets get the base64-encoded data\n    const base64data = base64Encode(dataStr);\n\n    //We can only fit a certain amount in each URL, so we need to split this request\n    //up into multiple pieces if it doesn't fit in one request.\n    const dataSegs = splitStringBySize(base64data, MAX_PAYLOAD_SIZE);\n\n    //Enqueue each segment for transmission. We assign each chunk a sequential ID and a total number\n    //of segments so that we can reassemble the packet on the server.\n    for (let i = 0; i < dataSegs.length; i++) {\n      this.scriptTagHolder.enqueueSegment(\n        this.curSegmentNum,\n        dataSegs.length,\n        dataSegs[i]\n      );\n      this.curSegmentNum++;\n    }\n  }\n\n  /**\n   * This is how we notify the server that we're leaving.\n   * We aren't able to send requests with DHTML on a window close event, but we can\n   * trigger XHR requests in some browsers (everything but Opera basically).\n   * @param {!string} id\n   * @param {!string} pw\n   */\n  addDisconnectPingFrame(id: string, pw: string) {\n    if (isNodeSdk()) return;\n    this.myDisconnFrame = document.createElement('iframe');\n    const urlParams: { [k: string]: string } = {};\n    urlParams[FIREBASE_LONGPOLL_DISCONN_FRAME_REQUEST_PARAM] = 't';\n    urlParams[FIREBASE_LONGPOLL_ID_PARAM] = id;\n    urlParams[FIREBASE_LONGPOLL_PW_PARAM] = pw;\n    this.myDisconnFrame.src = this.urlFn(urlParams);\n    this.myDisconnFrame.style.display = 'none';\n\n    document.body.appendChild(this.myDisconnFrame);\n  }\n\n  /**\n   * Used to track the bytes received by this client\n   * @param {*} args\n   * @private\n   */\n  private incrementIncomingBytes_(args: any) {\n    // TODO: This is an annoying perf hit just to track the number of incoming bytes.  Maybe it should be opt-in.\n    const bytesReceived = stringify(args).length;\n    this.bytesReceived += bytesReceived;\n    this.stats_.incrementCounter('bytes_received', bytesReceived);\n  }\n}\n\nexport interface IFrameElement extends HTMLIFrameElement {\n  doc: Document;\n}\n\n/*********************************************************************************************\n * A wrapper around an iframe that is used as a long-polling script holder.\n * @constructor\n *********************************************************************************************/\nexport class FirebaseIFrameScriptHolder {\n  //We maintain a count of all of the outstanding requests, because if we have too many active at once it can cause\n  //problems in some browsers.\n  /**\n   * @type {CountedSet.<number, number>}\n   */\n  outstandingRequests = new CountedSet<number, number>();\n\n  //A queue of the pending segments waiting for transmission to the server.\n  pendingSegs: { seg: number; ts: number; d: any }[] = [];\n\n  //A serial number. We use this for two things:\n  // 1) A way to ensure the browser doesn't cache responses to polls\n  // 2) A way to make the server aware when long-polls arrive in a different order than we started them. The\n  //    server needs to release both polls in this case or it will cause problems in Opera since Opera can only execute\n  //    JSONP code in the order it was added to the iframe.\n  currentSerial = Math.floor(Math.random() * 100000000);\n\n  // This gets set to false when we're \"closing down\" the connection (e.g. we're switching transports but there's still\n  // incoming data from the server that we're waiting for).\n  sendNewPolls = true;\n\n  uniqueCallbackIdentifier: number;\n  myIFrame: IFrameElement;\n  alive: boolean;\n  myID: string;\n  myPW: string;\n  commandCB: (command: string, ...args: any[]) => void;\n  onMessageCB: (...args: any[]) => void;\n\n  /**\n   * @param commandCB - The callback to be called when control commands are recevied from the server.\n   * @param onMessageCB - The callback to be triggered when responses arrive from the server.\n   * @param onDisconnect - The callback to be triggered when this tag holder is closed\n   * @param urlFn - A function that provides the URL of the endpoint to send data to.\n   */\n  constructor(\n    commandCB: (command: string, ...args: any[]) => void,\n    onMessageCB: (...args: any[]) => void,\n    public onDisconnect: () => void,\n    public urlFn: (a: object) => string\n  ) {\n    if (!isNodeSdk()) {\n      //Each script holder registers a couple of uniquely named callbacks with the window. These are called from the\n      //iframes where we put the long-polling script tags. We have two callbacks:\n      //   1) Command Callback - Triggered for control issues, like starting a connection.\n      //   2) Message Callback - Triggered when new data arrives.\n      this.uniqueCallbackIdentifier = LUIDGenerator();\n      (window as any)[\n        FIREBASE_LONGPOLL_COMMAND_CB_NAME + this.uniqueCallbackIdentifier\n      ] = commandCB;\n      (window as any)[\n        FIREBASE_LONGPOLL_DATA_CB_NAME + this.uniqueCallbackIdentifier\n      ] = onMessageCB;\n\n      //Create an iframe for us to add script tags to.\n      this.myIFrame = FirebaseIFrameScriptHolder.createIFrame_();\n\n      // Set the iframe's contents.\n      let script = '';\n      // if we set a javascript url, it's IE and we need to set the document domain. The javascript url is sufficient\n      // for ie9, but ie8 needs to do it again in the document itself.\n      if (\n        this.myIFrame.src &&\n        this.myIFrame.src.substr(0, 'javascript:'.length) === 'javascript:'\n      ) {\n        const currentDomain = document.domain;\n        script = '<script>document.domain=\"' + currentDomain + '\";</script>';\n      }\n      const iframeContents = '<html><body>' + script + '</body></html>';\n      try {\n        this.myIFrame.doc.open();\n        this.myIFrame.doc.write(iframeContents);\n        this.myIFrame.doc.close();\n      } catch (e) {\n        log('frame writing exception');\n        if (e.stack) {\n          log(e.stack);\n        }\n        log(e);\n      }\n    } else {\n      this.commandCB = commandCB;\n      this.onMessageCB = onMessageCB;\n    }\n  }\n\n  /**\n   * Each browser has its own funny way to handle iframes. Here we mush them all together into one object that I can\n   * actually use.\n   * @private\n   * @return {Element}\n   */\n  private static createIFrame_(): IFrameElement {\n    const iframe = document.createElement('iframe') as IFrameElement;\n    iframe.style.display = 'none';\n\n    // This is necessary in order to initialize the document inside the iframe\n    if (document.body) {\n      document.body.appendChild(iframe);\n      try {\n        // If document.domain has been modified in IE, this will throw an error, and we need to set the\n        // domain of the iframe's document manually. We can do this via a javascript: url as the src attribute\n        // Also note that we must do this *after* the iframe has been appended to the page. Otherwise it doesn't work.\n        const a = iframe.contentWindow.document;\n        if (!a) {\n          // Apologies for the log-spam, I need to do something to keep closure from optimizing out the assignment above.\n          log('No IE domain setting required');\n        }\n      } catch (e) {\n        const domain = document.domain;\n        iframe.src =\n          \"javascript:void((function(){document.open();document.domain='\" +\n          domain +\n          \"';document.close();})())\";\n      }\n    } else {\n      // LongPollConnection attempts to delay initialization until the document is ready, so hopefully this\n      // never gets hit.\n      throw 'Document body has not initialized. Wait to initialize Firebase until after the document is ready.';\n    }\n\n    // Get the document of the iframe in a browser-specific way.\n    if (iframe.contentDocument) {\n      (iframe as any).doc = iframe.contentDocument; // Firefox, Opera, Safari\n    } else if (iframe.contentWindow) {\n      (iframe as any).doc = iframe.contentWindow.document; // Internet Explorer\n    } else if ((iframe as any).document) {\n      (iframe as any).doc = (iframe as any).document; //others?\n    }\n\n    return iframe;\n  }\n\n  /**\n   * Cancel all outstanding queries and remove the frame.\n   */\n  close() {\n    //Mark this iframe as dead, so no new requests are sent.\n    this.alive = false;\n\n    if (this.myIFrame) {\n      //We have to actually remove all of the html inside this iframe before removing it from the\n      //window, or IE will continue loading and executing the script tags we've already added, which\n      //can lead to some errors being thrown. Setting innerHTML seems to be the easiest way to do this.\n      this.myIFrame.doc.body.innerHTML = '';\n      setTimeout(() => {\n        if (this.myIFrame !== null) {\n          document.body.removeChild(this.myIFrame);\n          this.myIFrame = null;\n        }\n      }, Math.floor(0));\n    }\n\n    if (isNodeSdk() && this.myID) {\n      const urlParams: { [k: string]: string } = {};\n      urlParams[FIREBASE_LONGPOLL_DISCONN_FRAME_PARAM] = 't';\n      urlParams[FIREBASE_LONGPOLL_ID_PARAM] = this.myID;\n      urlParams[FIREBASE_LONGPOLL_PW_PARAM] = this.myPW;\n      const theURL = this.urlFn(urlParams);\n      (FirebaseIFrameScriptHolder as any).nodeRestRequest(theURL);\n    }\n\n    // Protect from being called recursively.\n    const onDisconnect = this.onDisconnect;\n    if (onDisconnect) {\n      this.onDisconnect = null;\n      onDisconnect();\n    }\n  }\n\n  /**\n   * Actually start the long-polling session by adding the first script tag(s) to the iframe.\n   * @param {!string} id - The ID of this connection\n   * @param {!string} pw - The password for this connection\n   */\n  startLongPoll(id: string, pw: string) {\n    this.myID = id;\n    this.myPW = pw;\n    this.alive = true;\n\n    //send the initial request. If there are requests queued, make sure that we transmit as many as we are currently able to.\n    while (this.newRequest_()) {}\n  }\n\n  /**\n   * This is called any time someone might want a script tag to be added. It adds a script tag when there aren't\n   * too many outstanding requests and we are still alive.\n   *\n   * If there are outstanding packet segments to send, it sends one. If there aren't, it sends a long-poll anyways if\n   * needed.\n   */\n  private newRequest_() {\n    // We keep one outstanding request open all the time to receive data, but if we need to send data\n    // (pendingSegs.length > 0) then we create a new request to send the data.  The server will automatically\n    // close the old request.\n    if (\n      this.alive &&\n      this.sendNewPolls &&\n      this.outstandingRequests.count() < (this.pendingSegs.length > 0 ? 2 : 1)\n    ) {\n      //construct our url\n      this.currentSerial++;\n      const urlParams: { [k: string]: string | number } = {};\n      urlParams[FIREBASE_LONGPOLL_ID_PARAM] = this.myID;\n      urlParams[FIREBASE_LONGPOLL_PW_PARAM] = this.myPW;\n      urlParams[FIREBASE_LONGPOLL_SERIAL_PARAM] = this.currentSerial;\n      let theURL = this.urlFn(urlParams);\n      //Now add as much data as we can.\n      let curDataString = '';\n      let i = 0;\n\n      while (this.pendingSegs.length > 0) {\n        //first, lets see if the next segment will fit.\n        const nextSeg = this.pendingSegs[0];\n        if (\n          nextSeg.d.length + SEG_HEADER_SIZE + curDataString.length <=\n          MAX_URL_DATA_SIZE\n        ) {\n          //great, the segment will fit. Lets append it.\n          const theSeg = this.pendingSegs.shift();\n          curDataString =\n            curDataString +\n            '&' +\n            FIREBASE_LONGPOLL_SEGMENT_NUM_PARAM +\n            i +\n            '=' +\n            theSeg.seg +\n            '&' +\n            FIREBASE_LONGPOLL_SEGMENTS_IN_PACKET +\n            i +\n            '=' +\n            theSeg.ts +\n            '&' +\n            FIREBASE_LONGPOLL_DATA_PARAM +\n            i +\n            '=' +\n            theSeg.d;\n          i++;\n        } else {\n          break;\n        }\n      }\n\n      theURL = theURL + curDataString;\n      this.addLongPollTag_(theURL, this.currentSerial);\n\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * Queue a packet for transmission to the server.\n   * @param segnum - A sequential id for this packet segment used for reassembly\n   * @param totalsegs - The total number of segments in this packet\n   * @param data - The data for this segment.\n   */\n  enqueueSegment(segnum: number, totalsegs: number, data: any) {\n    //add this to the queue of segments to send.\n    this.pendingSegs.push({ seg: segnum, ts: totalsegs, d: data });\n\n    //send the data immediately if there isn't already data being transmitted, unless\n    //startLongPoll hasn't been called yet.\n    if (this.alive) {\n      this.newRequest_();\n    }\n  }\n\n  /**\n   * Add a script tag for a regular long-poll request.\n   * @param {!string} url - The URL of the script tag.\n   * @param {!number} serial - The serial number of the request.\n   * @private\n   */\n  private addLongPollTag_(url: string, serial: number) {\n    //remember that we sent this request.\n    this.outstandingRequests.add(serial, 1);\n\n    const doNewRequest = () => {\n      this.outstandingRequests.remove(serial);\n      this.newRequest_();\n    };\n\n    // If this request doesn't return on its own accord (by the server sending us some data), we'll\n    // create a new one after the KEEPALIVE interval to make sure we always keep a fresh request open.\n    const keepaliveTimeout = setTimeout(\n      doNewRequest,\n      Math.floor(KEEPALIVE_REQUEST_INTERVAL)\n    );\n\n    const readyStateCB = () => {\n      // Request completed.  Cancel the keepalive.\n      clearTimeout(keepaliveTimeout);\n\n      // Trigger a new request so we can continue receiving data.\n      doNewRequest();\n    };\n\n    this.addTag(url, readyStateCB);\n  }\n\n  /**\n   * Add an arbitrary script tag to the iframe.\n   * @param {!string} url - The URL for the script tag source.\n   * @param {!function()} loadCB - A callback to be triggered once the script has loaded.\n   */\n  addTag(url: string, loadCB: () => void) {\n    if (isNodeSdk()) {\n      (this as any).doNodeLongPoll(url, loadCB);\n    } else {\n      setTimeout(() => {\n        try {\n          // if we're already closed, don't add this poll\n          if (!this.sendNewPolls) return;\n          const newScript = this.myIFrame.doc.createElement('script');\n          newScript.type = 'text/javascript';\n          newScript.async = true;\n          newScript.src = url;\n          newScript.onload = (newScript as any).onreadystatechange = function() {\n            const rstate = (newScript as any).readyState;\n            if (!rstate || rstate === 'loaded' || rstate === 'complete') {\n              newScript.onload = (newScript as any).onreadystatechange = null;\n              if (newScript.parentNode) {\n                newScript.parentNode.removeChild(newScript);\n              }\n              loadCB();\n            }\n          };\n          newScript.onerror = () => {\n            log('Long-poll script failed to load: ' + url);\n            this.sendNewPolls = false;\n            this.close();\n          };\n          this.myIFrame.doc.body.appendChild(newScript);\n        } catch (e) {\n          // TODO: we should make this error visible somehow\n        }\n      }, Math.floor(1));\n    }\n  }\n}\n","/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\nimport { base64Encode, executeWhenDOMReady, isChromeExtensionContentScript, isWindowsStoreApp, log, logWrapper, LUIDGenerator, splitStringBySize } from '../core/util/util';\nimport { CountedSet } from '../core/util/CountedSet';\nimport { StatsManager } from '../core/stats/StatsManager';\nimport { PacketReceiver } from './polling/PacketReceiver';\nimport { FORGE_DOMAIN, FORGE_REF, LAST_SESSION_PARAM, LONG_POLLING, PROTOCOL_VERSION, REFERER_PARAM, TRANSPORT_SESSION_PARAM, VERSION_PARAM } from './Constants';\nimport { stringify } from '../../utils/json';\nimport { isNodeSdk } from '../../utils/environment';\n// URL query parameters associated with longpolling\nexport var FIREBASE_LONGPOLL_START_PARAM = 'start';\nexport var FIREBASE_LONGPOLL_CLOSE_COMMAND = 'close';\nexport var FIREBASE_LONGPOLL_COMMAND_CB_NAME = 'pLPCommand';\nexport var FIREBASE_LONGPOLL_DATA_CB_NAME = 'pRTLPCB';\nexport var FIREBASE_LONGPOLL_ID_PARAM = 'id';\nexport var FIREBASE_LONGPOLL_PW_PARAM = 'pw';\nexport var FIREBASE_LONGPOLL_SERIAL_PARAM = 'ser';\nexport var FIREBASE_LONGPOLL_CALLBACK_ID_PARAM = 'cb';\nexport var FIREBASE_LONGPOLL_SEGMENT_NUM_PARAM = 'seg';\nexport var FIREBASE_LONGPOLL_SEGMENTS_IN_PACKET = 'ts';\nexport var FIREBASE_LONGPOLL_DATA_PARAM = 'd';\nexport var FIREBASE_LONGPOLL_DISCONN_FRAME_PARAM = 'disconn';\nexport var FIREBASE_LONGPOLL_DISCONN_FRAME_REQUEST_PARAM = 'dframe';\n//Data size constants.\n//TODO: Perf: the maximum length actually differs from browser to browser.\n// We should check what browser we're on and set accordingly.\nvar MAX_URL_DATA_SIZE = 1870;\nvar SEG_HEADER_SIZE = 30; //ie: &seg=8299234&ts=982389123&d=\nvar MAX_PAYLOAD_SIZE = MAX_URL_DATA_SIZE - SEG_HEADER_SIZE;\n/**\n * Keepalive period\n * send a fresh request at minimum every 25 seconds. Opera has a maximum request\n * length of 30 seconds that we can't exceed.\n * @const\n * @type {number}\n */\nvar KEEPALIVE_REQUEST_INTERVAL = 25000;\n/**\n * How long to wait before aborting a long-polling connection attempt.\n * @const\n * @type {number}\n */\nvar LP_CONNECT_TIMEOUT = 30000;\n/**\n * This class manages a single long-polling connection.\n *\n * @constructor\n * @implements {Transport}\n */\nvar BrowserPollConnection = (function () {\n    /**\n     * @param {string} connId An identifier for this connection, used for logging\n     * @param {RepoInfo} repoInfo The info for the endpoint to send data to.\n     * @param {string=} transportSessionId Optional transportSessionid if we are reconnecting for an existing\n     *                                         transport session\n     * @param {string=}  lastSessionId Optional lastSessionId if the PersistentConnection has already created a\n     *                                     connection previously\n     */\n    function BrowserPollConnection(connId, repoInfo, transportSessionId, lastSessionId) {\n        this.connId = connId;\n        this.repoInfo = repoInfo;\n        this.transportSessionId = transportSessionId;\n        this.lastSessionId = lastSessionId;\n        this.bytesSent = 0;\n        this.bytesReceived = 0;\n        this.everConnected_ = false;\n        this.log_ = logWrapper(connId);\n        this.stats_ = StatsManager.getCollection(repoInfo);\n        this.urlFn = function (params) {\n            return repoInfo.connectionURL(LONG_POLLING, params);\n        };\n    }\n    /**\n     *\n     * @param {function(Object)} onMessage Callback when messages arrive\n     * @param {function()} onDisconnect Callback with connection lost.\n     */\n    BrowserPollConnection.prototype.open = function (onMessage, onDisconnect) {\n        var _this = this;\n        this.curSegmentNum = 0;\n        this.onDisconnect_ = onDisconnect;\n        this.myPacketOrderer = new PacketReceiver(onMessage);\n        this.isClosed_ = false;\n        this.connectTimeoutTimer_ = setTimeout(function () {\n            _this.log_('Timed out trying to connect.');\n            // Make sure we clear the host cache\n            _this.onClosed_();\n            _this.connectTimeoutTimer_ = null;\n        }, Math.floor(LP_CONNECT_TIMEOUT));\n        // Ensure we delay the creation of the iframe until the DOM is loaded.\n        executeWhenDOMReady(function () {\n            if (_this.isClosed_)\n                return;\n            //Set up a callback that gets triggered once a connection is set up.\n            _this.scriptTagHolder = new FirebaseIFrameScriptHolder(function () {\n                var args = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    args[_i] = arguments[_i];\n                }\n                var command = args[0], arg1 = args[1], arg2 = args[2], arg3 = args[3], arg4 = args[4];\n                _this.incrementIncomingBytes_(args);\n                if (!_this.scriptTagHolder)\n                    return; // we closed the connection.\n                if (_this.connectTimeoutTimer_) {\n                    clearTimeout(_this.connectTimeoutTimer_);\n                    _this.connectTimeoutTimer_ = null;\n                }\n                _this.everConnected_ = true;\n                if (command == FIREBASE_LONGPOLL_START_PARAM) {\n                    _this.id = arg1;\n                    _this.password = arg2;\n                }\n                else if (command === FIREBASE_LONGPOLL_CLOSE_COMMAND) {\n                    // Don't clear the host cache. We got a response from the server, so we know it's reachable\n                    if (arg1) {\n                        // We aren't expecting any more data (other than what the server's already in the process of sending us\n                        // through our already open polls), so don't send any more.\n                        _this.scriptTagHolder.sendNewPolls = false;\n                        // arg1 in this case is the last response number sent by the server. We should try to receive\n                        // all of the responses up to this one before closing\n                        _this.myPacketOrderer.closeAfter(arg1, function () {\n                            _this.onClosed_();\n                        });\n                    }\n                    else {\n                        _this.onClosed_();\n                    }\n                }\n                else {\n                    throw new Error('Unrecognized command received: ' + command);\n                }\n            }, function () {\n                var args = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    args[_i] = arguments[_i];\n                }\n                var pN = args[0], data = args[1];\n                _this.incrementIncomingBytes_(args);\n                _this.myPacketOrderer.handleResponse(pN, data);\n            }, function () {\n                _this.onClosed_();\n            }, _this.urlFn);\n            //Send the initial request to connect. The serial number is simply to keep the browser from pulling previous results\n            //from cache.\n            var urlParams = {};\n            urlParams[FIREBASE_LONGPOLL_START_PARAM] = 't';\n            urlParams[FIREBASE_LONGPOLL_SERIAL_PARAM] = Math.floor(Math.random() * 100000000);\n            if (_this.scriptTagHolder.uniqueCallbackIdentifier)\n                urlParams[FIREBASE_LONGPOLL_CALLBACK_ID_PARAM] = _this.scriptTagHolder.uniqueCallbackIdentifier;\n            urlParams[VERSION_PARAM] = PROTOCOL_VERSION;\n            if (_this.transportSessionId) {\n                urlParams[TRANSPORT_SESSION_PARAM] = _this.transportSessionId;\n            }\n            if (_this.lastSessionId) {\n                urlParams[LAST_SESSION_PARAM] = _this.lastSessionId;\n            }\n            if (!isNodeSdk() &&\n                typeof location !== 'undefined' &&\n                location.href &&\n                location.href.indexOf(FORGE_DOMAIN) !== -1) {\n                urlParams[REFERER_PARAM] = FORGE_REF;\n            }\n            var connectURL = _this.urlFn(urlParams);\n            _this.log_('Connecting via long-poll to ' + connectURL);\n            _this.scriptTagHolder.addTag(connectURL, function () {\n                /* do nothing */\n            });\n        });\n    };\n    /**\n     * Call this when a handshake has completed successfully and we want to consider the connection established\n     */\n    BrowserPollConnection.prototype.start = function () {\n        this.scriptTagHolder.startLongPoll(this.id, this.password);\n        this.addDisconnectPingFrame(this.id, this.password);\n    };\n    /**\n     * Forces long polling to be considered as a potential transport\n     */\n    BrowserPollConnection.forceAllow = function () {\n        BrowserPollConnection.forceAllow_ = true;\n    };\n    /**\n     * Forces longpolling to not be considered as a potential transport\n     */\n    BrowserPollConnection.forceDisallow = function () {\n        BrowserPollConnection.forceDisallow_ = true;\n    };\n    // Static method, use string literal so it can be accessed in a generic way\n    BrowserPollConnection.isAvailable = function () {\n        // NOTE: In React-Native there's normally no 'document', but if you debug a React-Native app in\n        // the Chrome debugger, 'document' is defined, but document.createElement is null (2015/06/08).\n        return (BrowserPollConnection.forceAllow_ ||\n            (!BrowserPollConnection.forceDisallow_ &&\n                typeof document !== 'undefined' &&\n                document.createElement != null &&\n                !isChromeExtensionContentScript() &&\n                !isWindowsStoreApp() &&\n                !isNodeSdk()));\n    };\n    /**\n     * No-op for polling\n     */\n    BrowserPollConnection.prototype.markConnectionHealthy = function () { };\n    /**\n     * Stops polling and cleans up the iframe\n     * @private\n     */\n    BrowserPollConnection.prototype.shutdown_ = function () {\n        this.isClosed_ = true;\n        if (this.scriptTagHolder) {\n            this.scriptTagHolder.close();\n            this.scriptTagHolder = null;\n        }\n        //remove the disconnect frame, which will trigger an XHR call to the server to tell it we're leaving.\n        if (this.myDisconnFrame) {\n            document.body.removeChild(this.myDisconnFrame);\n            this.myDisconnFrame = null;\n        }\n        if (this.connectTimeoutTimer_) {\n            clearTimeout(this.connectTimeoutTimer_);\n            this.connectTimeoutTimer_ = null;\n        }\n    };\n    /**\n     * Triggered when this transport is closed\n     * @private\n     */\n    BrowserPollConnection.prototype.onClosed_ = function () {\n        if (!this.isClosed_) {\n            this.log_('Longpoll is closing itself');\n            this.shutdown_();\n            if (this.onDisconnect_) {\n                this.onDisconnect_(this.everConnected_);\n                this.onDisconnect_ = null;\n            }\n        }\n    };\n    /**\n     * External-facing close handler. RealTime has requested we shut down. Kill our connection and tell the server\n     * that we've left.\n     */\n    BrowserPollConnection.prototype.close = function () {\n        if (!this.isClosed_) {\n            this.log_('Longpoll is being closed.');\n            this.shutdown_();\n        }\n    };\n    /**\n     * Send the JSON object down to the server. It will need to be stringified, base64 encoded, and then\n     * broken into chunks (since URLs have a small maximum length).\n     * @param {!Object} data The JSON data to transmit.\n     */\n    BrowserPollConnection.prototype.send = function (data) {\n        var dataStr = stringify(data);\n        this.bytesSent += dataStr.length;\n        this.stats_.incrementCounter('bytes_sent', dataStr.length);\n        //first, lets get the base64-encoded data\n        var base64data = base64Encode(dataStr);\n        //We can only fit a certain amount in each URL, so we need to split this request\n        //up into multiple pieces if it doesn't fit in one request.\n        var dataSegs = splitStringBySize(base64data, MAX_PAYLOAD_SIZE);\n        //Enqueue each segment for transmission. We assign each chunk a sequential ID and a total number\n        //of segments so that we can reassemble the packet on the server.\n        for (var i = 0; i < dataSegs.length; i++) {\n            this.scriptTagHolder.enqueueSegment(this.curSegmentNum, dataSegs.length, dataSegs[i]);\n            this.curSegmentNum++;\n        }\n    };\n    /**\n     * This is how we notify the server that we're leaving.\n     * We aren't able to send requests with DHTML on a window close event, but we can\n     * trigger XHR requests in some browsers (everything but Opera basically).\n     * @param {!string} id\n     * @param {!string} pw\n     */\n    BrowserPollConnection.prototype.addDisconnectPingFrame = function (id, pw) {\n        if (isNodeSdk())\n            return;\n        this.myDisconnFrame = document.createElement('iframe');\n        var urlParams = {};\n        urlParams[FIREBASE_LONGPOLL_DISCONN_FRAME_REQUEST_PARAM] = 't';\n        urlParams[FIREBASE_LONGPOLL_ID_PARAM] = id;\n        urlParams[FIREBASE_LONGPOLL_PW_PARAM] = pw;\n        this.myDisconnFrame.src = this.urlFn(urlParams);\n        this.myDisconnFrame.style.display = 'none';\n        document.body.appendChild(this.myDisconnFrame);\n    };\n    /**\n     * Used to track the bytes received by this client\n     * @param {*} args\n     * @private\n     */\n    BrowserPollConnection.prototype.incrementIncomingBytes_ = function (args) {\n        // TODO: This is an annoying perf hit just to track the number of incoming bytes.  Maybe it should be opt-in.\n        var bytesReceived = stringify(args).length;\n        this.bytesReceived += bytesReceived;\n        this.stats_.incrementCounter('bytes_received', bytesReceived);\n    };\n    return BrowserPollConnection;\n}());\nexport { BrowserPollConnection };\n/*********************************************************************************************\n * A wrapper around an iframe that is used as a long-polling script holder.\n * @constructor\n *********************************************************************************************/\nvar FirebaseIFrameScriptHolder = (function () {\n    /**\n     * @param commandCB - The callback to be called when control commands are recevied from the server.\n     * @param onMessageCB - The callback to be triggered when responses arrive from the server.\n     * @param onDisconnect - The callback to be triggered when this tag holder is closed\n     * @param urlFn - A function that provides the URL of the endpoint to send data to.\n     */\n    function FirebaseIFrameScriptHolder(commandCB, onMessageCB, onDisconnect, urlFn) {\n        this.onDisconnect = onDisconnect;\n        this.urlFn = urlFn;\n        //We maintain a count of all of the outstanding requests, because if we have too many active at once it can cause\n        //problems in some browsers.\n        /**\n         * @type {CountedSet.<number, number>}\n         */\n        this.outstandingRequests = new CountedSet();\n        //A queue of the pending segments waiting for transmission to the server.\n        this.pendingSegs = [];\n        //A serial number. We use this for two things:\n        // 1) A way to ensure the browser doesn't cache responses to polls\n        // 2) A way to make the server aware when long-polls arrive in a different order than we started them. The\n        //    server needs to release both polls in this case or it will cause problems in Opera since Opera can only execute\n        //    JSONP code in the order it was added to the iframe.\n        this.currentSerial = Math.floor(Math.random() * 100000000);\n        // This gets set to false when we're \"closing down\" the connection (e.g. we're switching transports but there's still\n        // incoming data from the server that we're waiting for).\n        this.sendNewPolls = true;\n        if (!isNodeSdk()) {\n            //Each script holder registers a couple of uniquely named callbacks with the window. These are called from the\n            //iframes where we put the long-polling script tags. We have two callbacks:\n            //   1) Command Callback - Triggered for control issues, like starting a connection.\n            //   2) Message Callback - Triggered when new data arrives.\n            this.uniqueCallbackIdentifier = LUIDGenerator();\n            window[FIREBASE_LONGPOLL_COMMAND_CB_NAME + this.uniqueCallbackIdentifier] = commandCB;\n            window[FIREBASE_LONGPOLL_DATA_CB_NAME + this.uniqueCallbackIdentifier] = onMessageCB;\n            //Create an iframe for us to add script tags to.\n            this.myIFrame = FirebaseIFrameScriptHolder.createIFrame_();\n            // Set the iframe's contents.\n            var script = '';\n            // if we set a javascript url, it's IE and we need to set the document domain. The javascript url is sufficient\n            // for ie9, but ie8 needs to do it again in the document itself.\n            if (this.myIFrame.src &&\n                this.myIFrame.src.substr(0, 'javascript:'.length) === 'javascript:') {\n                var currentDomain = document.domain;\n                script = '<script>document.domain=\"' + currentDomain + '\";</script>';\n            }\n            var iframeContents = '<html><body>' + script + '</body></html>';\n            try {\n                this.myIFrame.doc.open();\n                this.myIFrame.doc.write(iframeContents);\n                this.myIFrame.doc.close();\n            }\n            catch (e) {\n                log('frame writing exception');\n                if (e.stack) {\n                    log(e.stack);\n                }\n                log(e);\n            }\n        }\n        else {\n            this.commandCB = commandCB;\n            this.onMessageCB = onMessageCB;\n        }\n    }\n    /**\n     * Each browser has its own funny way to handle iframes. Here we mush them all together into one object that I can\n     * actually use.\n     * @private\n     * @return {Element}\n     */\n    FirebaseIFrameScriptHolder.createIFrame_ = function () {\n        var iframe = document.createElement('iframe');\n        iframe.style.display = 'none';\n        // This is necessary in order to initialize the document inside the iframe\n        if (document.body) {\n            document.body.appendChild(iframe);\n            try {\n                // If document.domain has been modified in IE, this will throw an error, and we need to set the\n                // domain of the iframe's document manually. We can do this via a javascript: url as the src attribute\n                // Also note that we must do this *after* the iframe has been appended to the page. Otherwise it doesn't work.\n                var a = iframe.contentWindow.document;\n                if (!a) {\n                    // Apologies for the log-spam, I need to do something to keep closure from optimizing out the assignment above.\n                    log('No IE domain setting required');\n                }\n            }\n            catch (e) {\n                var domain = document.domain;\n                iframe.src =\n                    \"javascript:void((function(){document.open();document.domain='\" +\n                        domain +\n                        \"';document.close();})())\";\n            }\n        }\n        else {\n            // LongPollConnection attempts to delay initialization until the document is ready, so hopefully this\n            // never gets hit.\n            throw 'Document body has not initialized. Wait to initialize Firebase until after the document is ready.';\n        }\n        // Get the document of the iframe in a browser-specific way.\n        if (iframe.contentDocument) {\n            iframe.doc = iframe.contentDocument; // Firefox, Opera, Safari\n        }\n        else if (iframe.contentWindow) {\n            iframe.doc = iframe.contentWindow.document; // Internet Explorer\n        }\n        else if (iframe.document) {\n            iframe.doc = iframe.document; //others?\n        }\n        return iframe;\n    };\n    /**\n     * Cancel all outstanding queries and remove the frame.\n     */\n    FirebaseIFrameScriptHolder.prototype.close = function () {\n        var _this = this;\n        //Mark this iframe as dead, so no new requests are sent.\n        this.alive = false;\n        if (this.myIFrame) {\n            //We have to actually remove all of the html inside this iframe before removing it from the\n            //window, or IE will continue loading and executing the script tags we've already added, which\n            //can lead to some errors being thrown. Setting innerHTML seems to be the easiest way to do this.\n            this.myIFrame.doc.body.innerHTML = '';\n            setTimeout(function () {\n                if (_this.myIFrame !== null) {\n                    document.body.removeChild(_this.myIFrame);\n                    _this.myIFrame = null;\n                }\n            }, Math.floor(0));\n        }\n        if (isNodeSdk() && this.myID) {\n            var urlParams = {};\n            urlParams[FIREBASE_LONGPOLL_DISCONN_FRAME_PARAM] = 't';\n            urlParams[FIREBASE_LONGPOLL_ID_PARAM] = this.myID;\n            urlParams[FIREBASE_LONGPOLL_PW_PARAM] = this.myPW;\n            var theURL = this.urlFn(urlParams);\n            FirebaseIFrameScriptHolder.nodeRestRequest(theURL);\n        }\n        // Protect from being called recursively.\n        var onDisconnect = this.onDisconnect;\n        if (onDisconnect) {\n            this.onDisconnect = null;\n            onDisconnect();\n        }\n    };\n    /**\n     * Actually start the long-polling session by adding the first script tag(s) to the iframe.\n     * @param {!string} id - The ID of this connection\n     * @param {!string} pw - The password for this connection\n     */\n    FirebaseIFrameScriptHolder.prototype.startLongPoll = function (id, pw) {\n        this.myID = id;\n        this.myPW = pw;\n        this.alive = true;\n        //send the initial request. If there are requests queued, make sure that we transmit as many as we are currently able to.\n        while (this.newRequest_()) { }\n    };\n    /**\n     * This is called any time someone might want a script tag to be added. It adds a script tag when there aren't\n     * too many outstanding requests and we are still alive.\n     *\n     * If there are outstanding packet segments to send, it sends one. If there aren't, it sends a long-poll anyways if\n     * needed.\n     */\n    FirebaseIFrameScriptHolder.prototype.newRequest_ = function () {\n        // We keep one outstanding request open all the time to receive data, but if we need to send data\n        // (pendingSegs.length > 0) then we create a new request to send the data.  The server will automatically\n        // close the old request.\n        if (this.alive &&\n            this.sendNewPolls &&\n            this.outstandingRequests.count() < (this.pendingSegs.length > 0 ? 2 : 1)) {\n            //construct our url\n            this.currentSerial++;\n            var urlParams = {};\n            urlParams[FIREBASE_LONGPOLL_ID_PARAM] = this.myID;\n            urlParams[FIREBASE_LONGPOLL_PW_PARAM] = this.myPW;\n            urlParams[FIREBASE_LONGPOLL_SERIAL_PARAM] = this.currentSerial;\n            var theURL = this.urlFn(urlParams);\n            //Now add as much data as we can.\n            var curDataString = '';\n            var i = 0;\n            while (this.pendingSegs.length > 0) {\n                //first, lets see if the next segment will fit.\n                var nextSeg = this.pendingSegs[0];\n                if (nextSeg.d.length + SEG_HEADER_SIZE + curDataString.length <=\n                    MAX_URL_DATA_SIZE) {\n                    //great, the segment will fit. Lets append it.\n                    var theSeg = this.pendingSegs.shift();\n                    curDataString =\n                        curDataString +\n                            '&' +\n                            FIREBASE_LONGPOLL_SEGMENT_NUM_PARAM +\n                            i +\n                            '=' +\n                            theSeg.seg +\n                            '&' +\n                            FIREBASE_LONGPOLL_SEGMENTS_IN_PACKET +\n                            i +\n                            '=' +\n                            theSeg.ts +\n                            '&' +\n                            FIREBASE_LONGPOLL_DATA_PARAM +\n                            i +\n                            '=' +\n                            theSeg.d;\n                    i++;\n                }\n                else {\n                    break;\n                }\n            }\n            theURL = theURL + curDataString;\n            this.addLongPollTag_(theURL, this.currentSerial);\n            return true;\n        }\n        else {\n            return false;\n        }\n    };\n    /**\n     * Queue a packet for transmission to the server.\n     * @param segnum - A sequential id for this packet segment used for reassembly\n     * @param totalsegs - The total number of segments in this packet\n     * @param data - The data for this segment.\n     */\n    FirebaseIFrameScriptHolder.prototype.enqueueSegment = function (segnum, totalsegs, data) {\n        //add this to the queue of segments to send.\n        this.pendingSegs.push({ seg: segnum, ts: totalsegs, d: data });\n        //send the data immediately if there isn't already data being transmitted, unless\n        //startLongPoll hasn't been called yet.\n        if (this.alive) {\n            this.newRequest_();\n        }\n    };\n    /**\n     * Add a script tag for a regular long-poll request.\n     * @param {!string} url - The URL of the script tag.\n     * @param {!number} serial - The serial number of the request.\n     * @private\n     */\n    FirebaseIFrameScriptHolder.prototype.addLongPollTag_ = function (url, serial) {\n        var _this = this;\n        //remember that we sent this request.\n        this.outstandingRequests.add(serial, 1);\n        var doNewRequest = function () {\n            _this.outstandingRequests.remove(serial);\n            _this.newRequest_();\n        };\n        // If this request doesn't return on its own accord (by the server sending us some data), we'll\n        // create a new one after the KEEPALIVE interval to make sure we always keep a fresh request open.\n        var keepaliveTimeout = setTimeout(doNewRequest, Math.floor(KEEPALIVE_REQUEST_INTERVAL));\n        var readyStateCB = function () {\n            // Request completed.  Cancel the keepalive.\n            clearTimeout(keepaliveTimeout);\n            // Trigger a new request so we can continue receiving data.\n            doNewRequest();\n        };\n        this.addTag(url, readyStateCB);\n    };\n    /**\n     * Add an arbitrary script tag to the iframe.\n     * @param {!string} url - The URL for the script tag source.\n     * @param {!function()} loadCB - A callback to be triggered once the script has loaded.\n     */\n    FirebaseIFrameScriptHolder.prototype.addTag = function (url, loadCB) {\n        var _this = this;\n        if (isNodeSdk()) {\n            this.doNodeLongPoll(url, loadCB);\n        }\n        else {\n            setTimeout(function () {\n                try {\n                    // if we're already closed, don't add this poll\n                    if (!_this.sendNewPolls)\n                        return;\n                    var newScript_1 = _this.myIFrame.doc.createElement('script');\n                    newScript_1.type = 'text/javascript';\n                    newScript_1.async = true;\n                    newScript_1.src = url;\n                    newScript_1.onload = newScript_1.onreadystatechange = function () {\n                        var rstate = newScript_1.readyState;\n                        if (!rstate || rstate === 'loaded' || rstate === 'complete') {\n                            newScript_1.onload = newScript_1.onreadystatechange = null;\n                            if (newScript_1.parentNode) {\n                                newScript_1.parentNode.removeChild(newScript_1);\n                            }\n                            loadCB();\n                        }\n                    };\n                    newScript_1.onerror = function () {\n                        log('Long-poll script failed to load: ' + url);\n                        _this.sendNewPolls = false;\n                        _this.close();\n                    };\n                    _this.myIFrame.doc.body.appendChild(newScript_1);\n                }\n                catch (e) {\n                    // TODO: we should make this error visible somehow\n                }\n            }, Math.floor(1));\n        }\n    };\n    return FirebaseIFrameScriptHolder;\n}());\nexport { FirebaseIFrameScriptHolder };\n\n\n"]}