{"version":3,"sources":["src/database/realtime/WebSocketConnection.ts"],"names":["setWebSocketImpl","WEBSOCKET_MAX_FRAME_SIZE","WEBSOCKET_KEEPALIVE_INTERVAL","WebSocketImpl","MozWebSocket","WebSocket","impl","WebSocketConnection","connId","repoInfo","transportSessionId","lastSessionId","keepaliveTimer","frames","totalFrames","bytesSent","bytesReceived","log_","stats_","getCollection","connURL","connectionURL_","urlParams","location","href","indexOf","connectionURL","prototype","open","onMessage","onDisconnect","_this","everConnected_","set","device","NODE_ADMIN","options","headers","SDK_VERSION","process","platform","env","proxy","origin","mySock","e","error","message","data","onClosed_","onopen","onclose","onmessage","m","handleIncomingFrame","onerror","start","forceDisallow","forceDisallow_","isAvailable","isOldAndroid","navigator","userAgent","oldAndroidRegex","oldAndroidMatch","match","length","parseFloat","previouslyFailed","isInMemoryStorage","get","markConnectionHealthy","remove","appendFrame_","push","fullMess","join","jsonMess","handleNewFrameCount_","frameCount","extractFrameCount_","Number","isNaN","mess","incrementCounter","resetKeepAlive","remainingData","send","dataStr","dataSegs","sendString_","String","i","shutdown_","isClosed_","clearInterval","close","setInterval","Math","floor","str","setTimeout","bind","responsesRequiredToBeHealthy","healthyTimeout"],"mappings":"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","file":"WebSocketConnection.js","sourcesContent":["/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\nimport { RepoInfo } from '../core/RepoInfo';\n\ndeclare const MozWebSocket: any;\n\nimport firebase from '../../app';\nimport { assert } from '../../utils/assert';\nimport { logWrapper, splitStringBySize } from '../core/util/util';\nimport { StatsManager } from '../core/stats/StatsManager';\nimport {\n  FORGE_DOMAIN,\n  FORGE_REF,\n  LAST_SESSION_PARAM,\n  PROTOCOL_VERSION,\n  REFERER_PARAM,\n  TRANSPORT_SESSION_PARAM,\n  VERSION_PARAM,\n  WEBSOCKET\n} from './Constants';\nimport { CONSTANTS as ENV_CONSTANTS } from '../../utils/constants';\nimport { PersistentStorage } from '../core/storage/storage';\nimport { jsonEval, stringify } from '../../utils/json';\nimport { isNodeSdk } from '../../utils/environment';\nimport { Transport } from './Transport';\nimport { StatsCollection } from '../core/stats/StatsCollection';\n\nconst WEBSOCKET_MAX_FRAME_SIZE = 16384;\nconst WEBSOCKET_KEEPALIVE_INTERVAL = 45000;\n\nlet WebSocketImpl = null;\nif (typeof MozWebSocket !== 'undefined') {\n  WebSocketImpl = MozWebSocket;\n} else if (typeof WebSocket !== 'undefined') {\n  WebSocketImpl = WebSocket;\n}\n\nexport function setWebSocketImpl(impl) {\n  WebSocketImpl = impl;\n}\n\n/**\n * Create a new websocket connection with the given callbacks.\n * @constructor\n * @implements {Transport}\n */\nexport class WebSocketConnection implements Transport {\n  keepaliveTimer: number | null = null;\n  frames: string[] | null = null;\n  totalFrames = 0;\n  bytesSent = 0;\n  bytesReceived = 0;\n  connURL: string;\n  onDisconnect: (a?: boolean) => void;\n  onMessage: (msg: Object) => void;\n  mySock: any | null;\n  private log_: (...a: any[]) => void;\n  private stats_: StatsCollection;\n  private everConnected_: boolean;\n  private isClosed_: boolean;\n\n  /**\n   * @param {string} connId identifier for this transport\n   * @param {RepoInfo} repoInfo The info for the websocket endpoint.\n   * @param {string=} transportSessionId Optional transportSessionId if this is connecting to an existing transport\n   *                                         session\n   * @param {string=} lastSessionId Optional lastSessionId if there was a previous connection\n   */\n  constructor(\n    public connId: string,\n    repoInfo: RepoInfo,\n    transportSessionId?: string,\n    lastSessionId?: string\n  ) {\n    this.log_ = logWrapper(this.connId);\n    this.stats_ = StatsManager.getCollection(repoInfo);\n    this.connURL = WebSocketConnection.connectionURL_(\n      repoInfo,\n      transportSessionId,\n      lastSessionId\n    );\n  }\n\n  /**\n   * @param {RepoInfo} repoInfo The info for the websocket endpoint.\n   * @param {string=} transportSessionId Optional transportSessionId if this is connecting to an existing transport\n   *                                         session\n   * @param {string=} lastSessionId Optional lastSessionId if there was a previous connection\n   * @return {string} connection url\n   * @private\n   */\n  private static connectionURL_(\n    repoInfo: RepoInfo,\n    transportSessionId?: string,\n    lastSessionId?: string\n  ): string {\n    const urlParams: { [k: string]: string } = {};\n    urlParams[VERSION_PARAM] = PROTOCOL_VERSION;\n\n    if (\n      !isNodeSdk() &&\n      typeof location !== 'undefined' &&\n      location.href &&\n      location.href.indexOf(FORGE_DOMAIN) !== -1\n    ) {\n      urlParams[REFERER_PARAM] = FORGE_REF;\n    }\n    if (transportSessionId) {\n      urlParams[TRANSPORT_SESSION_PARAM] = transportSessionId;\n    }\n    if (lastSessionId) {\n      urlParams[LAST_SESSION_PARAM] = lastSessionId;\n    }\n    return repoInfo.connectionURL(WEBSOCKET, urlParams);\n  }\n\n  /**\n   *\n   * @param onMessage Callback when messages arrive\n   * @param onDisconnect Callback with connection lost.\n   */\n  open(onMessage: (msg: Object) => void, onDisconnect: (a?: boolean) => void) {\n    this.onDisconnect = onDisconnect;\n    this.onMessage = onMessage;\n\n    this.log_('Websocket connecting to ' + this.connURL);\n\n    this.everConnected_ = false;\n    // Assume failure until proven otherwise.\n    PersistentStorage.set('previous_websocket_failure', true);\n\n    try {\n      if (isNodeSdk()) {\n        const device = ENV_CONSTANTS.NODE_ADMIN ? 'AdminNode' : 'Node';\n        // UA Format: Firebase/<wire_protocol>/<sdk_version>/<platform>/<device>\n        const options: { [k: string]: object } = {\n          headers: {\n            'User-Agent': `Firebase/${PROTOCOL_VERSION}/${firebase.SDK_VERSION}/${process.platform}/${device}`\n          }\n        };\n\n        // Plumb appropriate http_proxy environment variable into faye-websocket if it exists.\n        const env = process['env'];\n        const proxy =\n          this.connURL.indexOf('wss://') == 0\n            ? env['HTTPS_PROXY'] || env['https_proxy']\n            : env['HTTP_PROXY'] || env['http_proxy'];\n\n        if (proxy) {\n          options['proxy'] = { origin: proxy };\n        }\n\n        this.mySock = new WebSocketImpl(this.connURL, [], options);\n      } else {\n        this.mySock = new WebSocketImpl(this.connURL);\n      }\n    } catch (e) {\n      this.log_('Error instantiating WebSocket.');\n      const error = e.message || e.data;\n      if (error) {\n        this.log_(error);\n      }\n      this.onClosed_();\n      return;\n    }\n\n    this.mySock.onopen = () => {\n      this.log_('Websocket connected.');\n      this.everConnected_ = true;\n    };\n\n    this.mySock.onclose = () => {\n      this.log_('Websocket connection was disconnected.');\n      this.mySock = null;\n      this.onClosed_();\n    };\n\n    this.mySock.onmessage = (m: object) => {\n      this.handleIncomingFrame(m);\n    };\n\n    this.mySock.onerror = (e: any) => {\n      this.log_('WebSocket error.  Closing connection.');\n      const error = e.message || e.data;\n      if (error) {\n        this.log_(error);\n      }\n      this.onClosed_();\n    };\n  }\n\n  /**\n   * No-op for websockets, we don't need to do anything once the connection is confirmed as open\n   */\n  start() {}\n\n  static forceDisallow_: Boolean;\n\n  static forceDisallow() {\n    WebSocketConnection.forceDisallow_ = true;\n  }\n\n  static isAvailable(): boolean {\n    let isOldAndroid = false;\n    if (typeof navigator !== 'undefined' && navigator.userAgent) {\n      const oldAndroidRegex = /Android ([0-9]{0,}\\.[0-9]{0,})/;\n      const oldAndroidMatch = navigator.userAgent.match(oldAndroidRegex);\n      if (oldAndroidMatch && oldAndroidMatch.length > 1) {\n        if (parseFloat(oldAndroidMatch[1]) < 4.4) {\n          isOldAndroid = true;\n        }\n      }\n    }\n\n    return (\n      !isOldAndroid &&\n      WebSocketImpl !== null &&\n      !WebSocketConnection.forceDisallow_\n    );\n  }\n\n  /**\n   * Number of response before we consider the connection \"healthy.\"\n   * @type {number}\n   */\n  static responsesRequiredToBeHealthy = 2;\n\n  /**\n   * Time to wait for the connection te become healthy before giving up.\n   * @type {number}\n   */\n  static healthyTimeout = 30000;\n\n  /**\n   * Returns true if we previously failed to connect with this transport.\n   * @return {boolean}\n   */\n  static previouslyFailed(): boolean {\n    // If our persistent storage is actually only in-memory storage,\n    // we default to assuming that it previously failed to be safe.\n    return (\n      PersistentStorage.isInMemoryStorage ||\n      PersistentStorage.get('previous_websocket_failure') === true\n    );\n  }\n\n  markConnectionHealthy() {\n    PersistentStorage.remove('previous_websocket_failure');\n  }\n\n  private appendFrame_(data: string) {\n    this.frames.push(data);\n    if (this.frames.length == this.totalFrames) {\n      const fullMess = this.frames.join('');\n      this.frames = null;\n      const jsonMess = jsonEval(fullMess);\n\n      //handle the message\n      this.onMessage(jsonMess);\n    }\n  }\n\n  /**\n   * @param {number} frameCount The number of frames we are expecting from the server\n   * @private\n   */\n  private handleNewFrameCount_(frameCount: number) {\n    this.totalFrames = frameCount;\n    this.frames = [];\n  }\n\n  /**\n   * Attempts to parse a frame count out of some text. If it can't, assumes a value of 1\n   * @param {!String} data\n   * @return {?String} Any remaining data to be process, or null if there is none\n   * @private\n   */\n  private extractFrameCount_(data: string): string | null {\n    assert(this.frames === null, 'We already have a frame buffer');\n    // TODO: The server is only supposed to send up to 9999 frames (i.e. length <= 4), but that isn't being enforced\n    // currently.  So allowing larger frame counts (length <= 6).  See https://app.asana.com/0/search/8688598998380/8237608042508\n    if (data.length <= 6) {\n      const frameCount = Number(data);\n      if (!isNaN(frameCount)) {\n        this.handleNewFrameCount_(frameCount);\n        return null;\n      }\n    }\n    this.handleNewFrameCount_(1);\n    return data;\n  }\n\n  /**\n   * Process a websocket frame that has arrived from the server.\n   * @param mess The frame data\n   */\n  handleIncomingFrame(mess: { [k: string]: any }) {\n    if (this.mySock === null) return; // Chrome apparently delivers incoming packets even after we .close() the connection sometimes.\n    const data = mess['data'] as string;\n    this.bytesReceived += data.length;\n    this.stats_.incrementCounter('bytes_received', data.length);\n\n    this.resetKeepAlive();\n\n    if (this.frames !== null) {\n      // we're buffering\n      this.appendFrame_(data);\n    } else {\n      // try to parse out a frame count, otherwise, assume 1 and process it\n      const remainingData = this.extractFrameCount_(data);\n      if (remainingData !== null) {\n        this.appendFrame_(remainingData);\n      }\n    }\n  }\n\n  /**\n   * Send a message to the server\n   * @param {Object} data The JSON object to transmit\n   */\n  send(data: Object) {\n    this.resetKeepAlive();\n\n    const dataStr = stringify(data);\n    this.bytesSent += dataStr.length;\n    this.stats_.incrementCounter('bytes_sent', dataStr.length);\n\n    //We can only fit a certain amount in each websocket frame, so we need to split this request\n    //up into multiple pieces if it doesn't fit in one request.\n\n    const dataSegs = splitStringBySize(dataStr, WEBSOCKET_MAX_FRAME_SIZE);\n\n    //Send the length header\n    if (dataSegs.length > 1) {\n      this.sendString_(String(dataSegs.length));\n    }\n\n    //Send the actual data in segments.\n    for (let i = 0; i < dataSegs.length; i++) {\n      this.sendString_(dataSegs[i]);\n    }\n  }\n\n  private shutdown_() {\n    this.isClosed_ = true;\n    if (this.keepaliveTimer) {\n      clearInterval(this.keepaliveTimer);\n      this.keepaliveTimer = null;\n    }\n\n    if (this.mySock) {\n      this.mySock.close();\n      this.mySock = null;\n    }\n  }\n\n  private onClosed_() {\n    if (!this.isClosed_) {\n      this.log_('WebSocket is closing itself');\n      this.shutdown_();\n\n      // since this is an internal close, trigger the close listener\n      if (this.onDisconnect) {\n        this.onDisconnect(this.everConnected_);\n        this.onDisconnect = null;\n      }\n    }\n  }\n\n  /**\n   * External-facing close handler.\n   * Close the websocket and kill the connection.\n   */\n  close() {\n    if (!this.isClosed_) {\n      this.log_('WebSocket is being closed');\n      this.shutdown_();\n    }\n  }\n\n  /**\n   * Kill the current keepalive timer and start a new one, to ensure that it always fires N seconds after\n   * the last activity.\n   */\n  resetKeepAlive() {\n    clearInterval(this.keepaliveTimer);\n    this.keepaliveTimer = setInterval(() => {\n      //If there has been no websocket activity for a while, send a no-op\n      if (this.mySock) {\n        this.sendString_('0');\n      }\n      this.resetKeepAlive();\n    }, Math.floor(WEBSOCKET_KEEPALIVE_INTERVAL)) as any;\n  }\n\n  /**\n   * Send a string over the websocket.\n   *\n   * @param {string} str String to send.\n   * @private\n   */\n  private sendString_(str: string) {\n    // Firefox seems to sometimes throw exceptions (NS_ERROR_UNEXPECTED) from websocket .send()\n    // calls for some unknown reason.  We treat these as an error and disconnect.\n    // See https://app.asana.com/0/58926111402292/68021340250410\n    try {\n      this.mySock.send(str);\n    } catch (e) {\n      this.log_(\n        'Exception thrown from WebSocket.send():',\n        e.message || e.data,\n        'Closing connection.'\n      );\n      setTimeout(this.onClosed_.bind(this), 0);\n    }\n  }\n}\n"]}