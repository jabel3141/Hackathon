{"version":3,"sources":["src/database/realtime/Connection.ts","database/realtime/Connection.js"],"names":["UPGRADE_TIMEOUT","DELAY_BEFORE_SENDING_EXTRA_REQUESTS","BYTES_SENT_HEALTHY_OVERRIDE","BYTES_RECEIVED_HEALTHY_OVERRIDE","MESSAGE_TYPE","MESSAGE_DATA","CONTROL_SHUTDOWN","CONTROL_RESET","CONTROL_ERROR","CONTROL_PONG","SWITCH_ACK","END_TRANSMISSION","PING","SERVER_HELLO","Connection","id","repoInfo_","onMessage_","onReady_","onDisconnect_","onKill_","lastSessionId","connectionCount","pendingDataMessages","state_","log_","transportManager_","start_","prototype","_this","conn","initialTransport","conn_","nextTransportId_","undefined","primaryResponsesRequired_","onMessageReceived","connReceiver_","onConnectionLost","disconnReceiver_","tx_","rx_","secondaryConn_","isHealthy_","setTimeout","open","Math","floor","healthyTimeout_ms","healthyTimeout_","bytesReceived","markConnectionHealthy","bytesSent","close","everConnected","onConnectionLost_","onSecondaryConnectionLost_","message","onPrimaryMessageReceived_","onSecondaryMessageReceived_","sendRequest","dataMsg","msg","t","d","sendData_","tryCleanupConnection","connId","onSecondaryControl_","controlData","cmd","upgradeIfSecondaryHealthy_","secondaryResponsesRequired_","parsedData","layer","data","push","Error","proceedWithUpgrade_","send","start","onControl_","onDataMessage_","onPrimaryResponse_","payload","onHandshake_","i","length","onConnectionShutdown_","onReset_","sendPingOnPrimaryIfNecessary_","handshake","timestamp","ts","version","v","host","h","sessionId","s","updateHost","onConnectionEstablished_","tryStartUpgrade_","upgradeTransport","startUpgrade_","onMessage","onDisconnect","closeConnections_","isCacheableHost","remove","internalHost","reason","clearTimeout"],"mappings":"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","file":"Connection.js","sourcesContent":["/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\nimport {\n  error,\n  logWrapper,\n  requireKey,\n  setTimeoutNonBlocking,\n  warn\n} from '../core/util/util';\nimport { PersistentStorage } from '../core/storage/storage';\nimport { PROTOCOL_VERSION } from './Constants';\nimport { TransportManager } from './TransportManager';\nimport { RepoInfo } from '../core/RepoInfo';\nimport { Transport, TransportConstructor } from './Transport';\n\n// Abort upgrade attempt if it takes longer than 60s.\nconst UPGRADE_TIMEOUT = 60000;\n\n// For some transports (WebSockets), we need to \"validate\" the transport by exchanging a few requests and responses.\n// If we haven't sent enough requests within 5s, we'll start sending noop ping requests.\nconst DELAY_BEFORE_SENDING_EXTRA_REQUESTS = 5000;\n\n// If the initial data sent triggers a lot of bandwidth (i.e. it's a large put or a listen for a large amount of data)\n// then we may not be able to exchange our ping/pong requests within the healthy timeout.  So if we reach the timeout\n// but we've sent/received enough bytes, we don't cancel the connection.\nconst BYTES_SENT_HEALTHY_OVERRIDE = 10 * 1024;\nconst BYTES_RECEIVED_HEALTHY_OVERRIDE = 100 * 1024;\n\nconst enum RealtimeState {\n  CONNECTING,\n  CONNECTED,\n  DISCONNECTED\n}\n\nconst MESSAGE_TYPE = 't';\nconst MESSAGE_DATA = 'd';\nconst CONTROL_SHUTDOWN = 's';\nconst CONTROL_RESET = 'r';\nconst CONTROL_ERROR = 'e';\nconst CONTROL_PONG = 'o';\nconst SWITCH_ACK = 'a';\nconst END_TRANSMISSION = 'n';\nconst PING = 'p';\n\nconst SERVER_HELLO = 'h';\n\n/**\n * Creates a new real-time connection to the server using whichever method works\n * best in the current browser.\n *\n * @constructor\n */\nexport class Connection {\n  connectionCount = 0;\n  pendingDataMessages: any[] = [];\n  sessionId: string;\n\n  private conn_: Transport;\n  private healthyTimeout_: number;\n  private isHealthy_: boolean;\n  private log_: (...args: any[]) => void;\n  private primaryResponsesRequired_: number;\n  private rx_: Transport;\n  private secondaryConn_: Transport;\n  private secondaryResponsesRequired_: number;\n  private state_ = RealtimeState.CONNECTING;\n  private transportManager_: TransportManager;\n  private tx_: Transport;\n\n  /**\n   * @param {!string} id - an id for this connection\n   * @param {!RepoInfo} repoInfo_ - the info for the endpoint to connect to\n   * @param {function(Object)} onMessage_ - the callback to be triggered when a server-push message arrives\n   * @param {function(number, string)} onReady_ - the callback to be triggered when this connection is ready to send messages.\n   * @param {function()} onDisconnect_ - the callback to be triggered when a connection was lost\n   * @param {function(string)} onKill_ - the callback to be triggered when this connection has permanently shut down.\n   * @param {string=} lastSessionId - last session id in persistent connection. is used to clean up old session in real-time server\n   */\n  constructor(\n    public id: string,\n    private repoInfo_: RepoInfo,\n    private onMessage_: (a: Object) => void,\n    private onReady_: (a: number, b: string) => void,\n    private onDisconnect_: () => void,\n    private onKill_: (a: string) => void,\n    public lastSessionId?: string\n  ) {\n    this.log_ = logWrapper('c:' + this.id + ':');\n    this.transportManager_ = new TransportManager(repoInfo_);\n    this.log_('Connection created');\n    this.start_();\n  }\n\n  /**\n   * Starts a connection attempt\n   * @private\n   */\n  private start_() {\n    const conn = this.transportManager_.initialTransport();\n    this.conn_ = new conn(\n      this.nextTransportId_(),\n      this.repoInfo_,\n      undefined,\n      this.lastSessionId\n    );\n\n    // For certain transports (WebSockets), we need to send and receive several messages back and forth before we\n    // can consider the transport healthy.\n    this.primaryResponsesRequired_ = conn['responsesRequiredToBeHealthy'] || 0;\n\n    const onMessageReceived = this.connReceiver_(this.conn_);\n    const onConnectionLost = this.disconnReceiver_(this.conn_);\n    this.tx_ = this.conn_;\n    this.rx_ = this.conn_;\n    this.secondaryConn_ = null;\n    this.isHealthy_ = false;\n\n    /*\n     * Firefox doesn't like when code from one iframe tries to create another iframe by way of the parent frame.\n     * This can occur in the case of a redirect, i.e. we guessed wrong on what server to connect to and received a reset.\n     * Somehow, setTimeout seems to make this ok. That doesn't make sense from a security perspective, since you should\n     * still have the context of your originating frame.\n     */\n    setTimeout(() => {\n      // this.conn_ gets set to null in some of the tests. Check to make sure it still exists before using it\n      this.conn_ && this.conn_.open(onMessageReceived, onConnectionLost);\n    }, Math.floor(0));\n\n    const healthyTimeout_ms = conn['healthyTimeout'] || 0;\n    if (healthyTimeout_ms > 0) {\n      this.healthyTimeout_ = setTimeoutNonBlocking(() => {\n        this.healthyTimeout_ = null;\n        if (!this.isHealthy_) {\n          if (\n            this.conn_ &&\n            this.conn_.bytesReceived > BYTES_RECEIVED_HEALTHY_OVERRIDE\n          ) {\n            this.log_(\n              'Connection exceeded healthy timeout but has received ' +\n                this.conn_.bytesReceived +\n                ' bytes.  Marking connection healthy.'\n            );\n            this.isHealthy_ = true;\n            this.conn_.markConnectionHealthy();\n          } else if (\n            this.conn_ &&\n            this.conn_.bytesSent > BYTES_SENT_HEALTHY_OVERRIDE\n          ) {\n            this.log_(\n              'Connection exceeded healthy timeout but has sent ' +\n                this.conn_.bytesSent +\n                ' bytes.  Leaving connection alive.'\n            );\n            // NOTE: We don't want to mark it healthy, since we have no guarantee that the bytes have made it to\n            // the server.\n          } else {\n            this.log_('Closing unhealthy connection after timeout.');\n            this.close();\n          }\n        }\n      }, Math.floor(healthyTimeout_ms)) as any;\n    }\n  }\n\n  /**\n   * @return {!string}\n   * @private\n   */\n  private nextTransportId_(): string {\n    return 'c:' + this.id + ':' + this.connectionCount++;\n  }\n\n  private disconnReceiver_(conn) {\n    return everConnected => {\n      if (conn === this.conn_) {\n        this.onConnectionLost_(everConnected);\n      } else if (conn === this.secondaryConn_) {\n        this.log_('Secondary connection lost.');\n        this.onSecondaryConnectionLost_();\n      } else {\n        this.log_('closing an old connection');\n      }\n    };\n  }\n\n  private connReceiver_(conn: Transport) {\n    return (message: object) => {\n      if (this.state_ != RealtimeState.DISCONNECTED) {\n        if (conn === this.rx_) {\n          this.onPrimaryMessageReceived_(message);\n        } else if (conn === this.secondaryConn_) {\n          this.onSecondaryMessageReceived_(message);\n        } else {\n          this.log_('message on old connection');\n        }\n      }\n    };\n  }\n\n  /**\n   *\n   * @param {Object} dataMsg An arbitrary data message to be sent to the server\n   */\n  sendRequest(dataMsg: object) {\n    // wrap in a data message envelope and send it on\n    const msg = { t: 'd', d: dataMsg };\n    this.sendData_(msg);\n  }\n\n  tryCleanupConnection() {\n    if (this.tx_ === this.secondaryConn_ && this.rx_ === this.secondaryConn_) {\n      this.log_(\n        'cleaning up and promoting a connection: ' + this.secondaryConn_.connId\n      );\n      this.conn_ = this.secondaryConn_;\n      this.secondaryConn_ = null;\n      // the server will shutdown the old connection\n    }\n  }\n\n  private onSecondaryControl_(controlData: { [k: string]: any }) {\n    if (MESSAGE_TYPE in controlData) {\n      const cmd = controlData[MESSAGE_TYPE] as string;\n      if (cmd === SWITCH_ACK) {\n        this.upgradeIfSecondaryHealthy_();\n      } else if (cmd === CONTROL_RESET) {\n        // Most likely the session wasn't valid. Abandon the switch attempt\n        this.log_('Got a reset on secondary, closing it');\n        this.secondaryConn_.close();\n        // If we were already using this connection for something, than we need to fully close\n        if (\n          this.tx_ === this.secondaryConn_ ||\n          this.rx_ === this.secondaryConn_\n        ) {\n          this.close();\n        }\n      } else if (cmd === CONTROL_PONG) {\n        this.log_('got pong on secondary.');\n        this.secondaryResponsesRequired_--;\n        this.upgradeIfSecondaryHealthy_();\n      }\n    }\n  }\n\n  private onSecondaryMessageReceived_(parsedData: object) {\n    const layer: string = requireKey('t', parsedData);\n    const data: any = requireKey('d', parsedData);\n    if (layer == 'c') {\n      this.onSecondaryControl_(data);\n    } else if (layer == 'd') {\n      // got a data message, but we're still second connection. Need to buffer it up\n      this.pendingDataMessages.push(data);\n    } else {\n      throw new Error('Unknown protocol layer: ' + layer);\n    }\n  }\n\n  private upgradeIfSecondaryHealthy_() {\n    if (this.secondaryResponsesRequired_ <= 0) {\n      this.log_('Secondary connection is healthy.');\n      this.isHealthy_ = true;\n      this.secondaryConn_.markConnectionHealthy();\n      this.proceedWithUpgrade_();\n    } else {\n      // Send a ping to make sure the connection is healthy.\n      this.log_('sending ping on secondary.');\n      this.secondaryConn_.send({ t: 'c', d: { t: PING, d: {} } });\n    }\n  }\n\n  private proceedWithUpgrade_() {\n    // tell this connection to consider itself open\n    this.secondaryConn_.start();\n    // send ack\n    this.log_('sending client ack on secondary');\n    this.secondaryConn_.send({ t: 'c', d: { t: SWITCH_ACK, d: {} } });\n\n    // send end packet on primary transport, switch to sending on this one\n    // can receive on this one, buffer responses until end received on primary transport\n    this.log_('Ending transmission on primary');\n    this.conn_.send({ t: 'c', d: { t: END_TRANSMISSION, d: {} } });\n    this.tx_ = this.secondaryConn_;\n\n    this.tryCleanupConnection();\n  }\n\n  private onPrimaryMessageReceived_(parsedData: { [k: string]: any }) {\n    // Must refer to parsedData properties in quotes, so closure doesn't touch them.\n    const layer: string = requireKey('t', parsedData);\n    const data: any = requireKey('d', parsedData);\n    if (layer == 'c') {\n      this.onControl_(data);\n    } else if (layer == 'd') {\n      this.onDataMessage_(data);\n    }\n  }\n\n  private onDataMessage_(message: any) {\n    this.onPrimaryResponse_();\n\n    // We don't do anything with data messages, just kick them up a level\n    this.onMessage_(message);\n  }\n\n  private onPrimaryResponse_() {\n    if (!this.isHealthy_) {\n      this.primaryResponsesRequired_--;\n      if (this.primaryResponsesRequired_ <= 0) {\n        this.log_('Primary connection is healthy.');\n        this.isHealthy_ = true;\n        this.conn_.markConnectionHealthy();\n      }\n    }\n  }\n\n  private onControl_(controlData: { [k: string]: any }) {\n    const cmd: string = requireKey(MESSAGE_TYPE, controlData);\n    if (MESSAGE_DATA in controlData) {\n      const payload = controlData[MESSAGE_DATA];\n      if (cmd === SERVER_HELLO) {\n        this.onHandshake_(payload);\n      } else if (cmd === END_TRANSMISSION) {\n        this.log_('recvd end transmission on primary');\n        this.rx_ = this.secondaryConn_;\n        for (let i = 0; i < this.pendingDataMessages.length; ++i) {\n          this.onDataMessage_(this.pendingDataMessages[i]);\n        }\n        this.pendingDataMessages = [];\n        this.tryCleanupConnection();\n      } else if (cmd === CONTROL_SHUTDOWN) {\n        // This was previously the 'onKill' callback passed to the lower-level connection\n        // payload in this case is the reason for the shutdown. Generally a human-readable error\n        this.onConnectionShutdown_(payload);\n      } else if (cmd === CONTROL_RESET) {\n        // payload in this case is the host we should contact\n        this.onReset_(payload);\n      } else if (cmd === CONTROL_ERROR) {\n        error('Server Error: ' + payload);\n      } else if (cmd === CONTROL_PONG) {\n        this.log_('got pong on primary.');\n        this.onPrimaryResponse_();\n        this.sendPingOnPrimaryIfNecessary_();\n      } else {\n        error('Unknown control packet command: ' + cmd);\n      }\n    }\n  }\n\n  /**\n   *\n   * @param {Object} handshake The handshake data returned from the server\n   * @private\n   */\n  private onHandshake_(handshake: {\n    ts: number;\n    v: string;\n    h: string;\n    s: string;\n  }) {\n    const timestamp = handshake.ts;\n    const version = handshake.v;\n    const host = handshake.h;\n    this.sessionId = handshake.s;\n    this.repoInfo_.updateHost(host);\n    // if we've already closed the connection, then don't bother trying to progress further\n    if (this.state_ == RealtimeState.CONNECTING) {\n      this.conn_.start();\n      this.onConnectionEstablished_(this.conn_, timestamp);\n      if (PROTOCOL_VERSION !== version) {\n        warn('Protocol version mismatch detected');\n      }\n      // TODO: do we want to upgrade? when? maybe a delay?\n      this.tryStartUpgrade_();\n    }\n  }\n\n  private tryStartUpgrade_() {\n    const conn = this.transportManager_.upgradeTransport();\n    if (conn) {\n      this.startUpgrade_(conn);\n    }\n  }\n\n  private startUpgrade_(conn: TransportConstructor) {\n    this.secondaryConn_ = new conn(\n      this.nextTransportId_(),\n      this.repoInfo_,\n      this.sessionId\n    );\n    // For certain transports (WebSockets), we need to send and receive several messages back and forth before we\n    // can consider the transport healthy.\n    this.secondaryResponsesRequired_ =\n      conn['responsesRequiredToBeHealthy'] || 0;\n\n    const onMessage = this.connReceiver_(this.secondaryConn_);\n    const onDisconnect = this.disconnReceiver_(this.secondaryConn_);\n    this.secondaryConn_.open(onMessage, onDisconnect);\n\n    // If we haven't successfully upgraded after UPGRADE_TIMEOUT, give up and kill the secondary.\n    setTimeoutNonBlocking(() => {\n      if (this.secondaryConn_) {\n        this.log_('Timed out trying to upgrade.');\n        this.secondaryConn_.close();\n      }\n    }, Math.floor(UPGRADE_TIMEOUT));\n  }\n\n  private onReset_(host: string) {\n    this.log_('Reset packet received.  New host: ' + host);\n    this.repoInfo_.updateHost(host);\n    // TODO: if we're already \"connected\", we need to trigger a disconnect at the next layer up.\n    // We don't currently support resets after the connection has already been established\n    if (this.state_ === RealtimeState.CONNECTED) {\n      this.close();\n    } else {\n      // Close whatever connections we have open and start again.\n      this.closeConnections_();\n      this.start_();\n    }\n  }\n\n  private onConnectionEstablished_(conn: Transport, timestamp: number) {\n    this.log_('Realtime connection established.');\n    this.conn_ = conn;\n    this.state_ = RealtimeState.CONNECTED;\n\n    if (this.onReady_) {\n      this.onReady_(timestamp, this.sessionId);\n      this.onReady_ = null;\n    }\n\n    // If after 5 seconds we haven't sent enough requests to the server to get the connection healthy,\n    // send some pings.\n    if (this.primaryResponsesRequired_ === 0) {\n      this.log_('Primary connection is healthy.');\n      this.isHealthy_ = true;\n    } else {\n      setTimeoutNonBlocking(() => {\n        this.sendPingOnPrimaryIfNecessary_();\n      }, Math.floor(DELAY_BEFORE_SENDING_EXTRA_REQUESTS));\n    }\n  }\n\n  private sendPingOnPrimaryIfNecessary_() {\n    // If the connection isn't considered healthy yet, we'll send a noop ping packet request.\n    if (!this.isHealthy_ && this.state_ === RealtimeState.CONNECTED) {\n      this.log_('sending ping on primary.');\n      this.sendData_({ t: 'c', d: { t: PING, d: {} } });\n    }\n  }\n\n  private onSecondaryConnectionLost_() {\n    const conn = this.secondaryConn_;\n    this.secondaryConn_ = null;\n    if (this.tx_ === conn || this.rx_ === conn) {\n      // we are relying on this connection already in some capacity. Therefore, a failure is real\n      this.close();\n    }\n  }\n\n  /**\n   *\n   * @param {boolean} everConnected Whether or not the connection ever reached a server. Used to determine if\n   * we should flush the host cache\n   * @private\n   */\n  private onConnectionLost_(everConnected: boolean) {\n    this.conn_ = null;\n\n    // NOTE: IF you're seeing a Firefox error for this line, I think it might be because it's getting\n    // called on window close and RealtimeState.CONNECTING is no longer defined.  Just a guess.\n    if (!everConnected && this.state_ === RealtimeState.CONNECTING) {\n      this.log_('Realtime connection failed.');\n      // Since we failed to connect at all, clear any cached entry for this namespace in case the machine went away\n      if (this.repoInfo_.isCacheableHost()) {\n        PersistentStorage.remove('host:' + this.repoInfo_.host);\n        // reset the internal host to what we would show the user, i.e. <ns>.firebaseio.com\n        this.repoInfo_.internalHost = this.repoInfo_.host;\n      }\n    } else if (this.state_ === RealtimeState.CONNECTED) {\n      this.log_('Realtime connection lost.');\n    }\n\n    this.close();\n  }\n\n  /**\n   *\n   * @param {string} reason\n   * @private\n   */\n  private onConnectionShutdown_(reason: string) {\n    this.log_('Connection shutdown command received. Shutting down...');\n\n    if (this.onKill_) {\n      this.onKill_(reason);\n      this.onKill_ = null;\n    }\n\n    // We intentionally don't want to fire onDisconnect (kill is a different case),\n    // so clear the callback.\n    this.onDisconnect_ = null;\n\n    this.close();\n  }\n\n  private sendData_(data: object) {\n    if (this.state_ !== RealtimeState.CONNECTED) {\n      throw 'Connection is not connected';\n    } else {\n      this.tx_.send(data);\n    }\n  }\n\n  /**\n   * Cleans up this connection, calling the appropriate callbacks\n   */\n  close() {\n    if (this.state_ !== RealtimeState.DISCONNECTED) {\n      this.log_('Closing realtime connection.');\n      this.state_ = RealtimeState.DISCONNECTED;\n\n      this.closeConnections_();\n\n      if (this.onDisconnect_) {\n        this.onDisconnect_();\n        this.onDisconnect_ = null;\n      }\n    }\n  }\n\n  /**\n   *\n   * @private\n   */\n  private closeConnections_() {\n    this.log_('Shutting down all connections');\n    if (this.conn_) {\n      this.conn_.close();\n      this.conn_ = null;\n    }\n\n    if (this.secondaryConn_) {\n      this.secondaryConn_.close();\n      this.secondaryConn_ = null;\n    }\n\n    if (this.healthyTimeout_) {\n      clearTimeout(this.healthyTimeout_);\n      this.healthyTimeout_ = null;\n    }\n  }\n}\n","/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\nimport { error, logWrapper, requireKey, setTimeoutNonBlocking, warn } from '../core/util/util';\nimport { PersistentStorage } from '../core/storage/storage';\nimport { PROTOCOL_VERSION } from './Constants';\nimport { TransportManager } from './TransportManager';\n// Abort upgrade attempt if it takes longer than 60s.\nvar UPGRADE_TIMEOUT = 60000;\n// For some transports (WebSockets), we need to \"validate\" the transport by exchanging a few requests and responses.\n// If we haven't sent enough requests within 5s, we'll start sending noop ping requests.\nvar DELAY_BEFORE_SENDING_EXTRA_REQUESTS = 5000;\n// If the initial data sent triggers a lot of bandwidth (i.e. it's a large put or a listen for a large amount of data)\n// then we may not be able to exchange our ping/pong requests within the healthy timeout.  So if we reach the timeout\n// but we've sent/received enough bytes, we don't cancel the connection.\nvar BYTES_SENT_HEALTHY_OVERRIDE = 10 * 1024;\nvar BYTES_RECEIVED_HEALTHY_OVERRIDE = 100 * 1024;\nvar MESSAGE_TYPE = 't';\nvar MESSAGE_DATA = 'd';\nvar CONTROL_SHUTDOWN = 's';\nvar CONTROL_RESET = 'r';\nvar CONTROL_ERROR = 'e';\nvar CONTROL_PONG = 'o';\nvar SWITCH_ACK = 'a';\nvar END_TRANSMISSION = 'n';\nvar PING = 'p';\nvar SERVER_HELLO = 'h';\n/**\n * Creates a new real-time connection to the server using whichever method works\n * best in the current browser.\n *\n * @constructor\n */\nvar Connection = (function () {\n    /**\n     * @param {!string} id - an id for this connection\n     * @param {!RepoInfo} repoInfo_ - the info for the endpoint to connect to\n     * @param {function(Object)} onMessage_ - the callback to be triggered when a server-push message arrives\n     * @param {function(number, string)} onReady_ - the callback to be triggered when this connection is ready to send messages.\n     * @param {function()} onDisconnect_ - the callback to be triggered when a connection was lost\n     * @param {function(string)} onKill_ - the callback to be triggered when this connection has permanently shut down.\n     * @param {string=} lastSessionId - last session id in persistent connection. is used to clean up old session in real-time server\n     */\n    function Connection(id, repoInfo_, onMessage_, onReady_, onDisconnect_, onKill_, lastSessionId) {\n        this.id = id;\n        this.repoInfo_ = repoInfo_;\n        this.onMessage_ = onMessage_;\n        this.onReady_ = onReady_;\n        this.onDisconnect_ = onDisconnect_;\n        this.onKill_ = onKill_;\n        this.lastSessionId = lastSessionId;\n        this.connectionCount = 0;\n        this.pendingDataMessages = [];\n        this.state_ = 0 /* CONNECTING */;\n        this.log_ = logWrapper('c:' + this.id + ':');\n        this.transportManager_ = new TransportManager(repoInfo_);\n        this.log_('Connection created');\n        this.start_();\n    }\n    /**\n     * Starts a connection attempt\n     * @private\n     */\n    Connection.prototype.start_ = function () {\n        var _this = this;\n        var conn = this.transportManager_.initialTransport();\n        this.conn_ = new conn(this.nextTransportId_(), this.repoInfo_, undefined, this.lastSessionId);\n        // For certain transports (WebSockets), we need to send and receive several messages back and forth before we\n        // can consider the transport healthy.\n        this.primaryResponsesRequired_ = conn['responsesRequiredToBeHealthy'] || 0;\n        var onMessageReceived = this.connReceiver_(this.conn_);\n        var onConnectionLost = this.disconnReceiver_(this.conn_);\n        this.tx_ = this.conn_;\n        this.rx_ = this.conn_;\n        this.secondaryConn_ = null;\n        this.isHealthy_ = false;\n        /*\n         * Firefox doesn't like when code from one iframe tries to create another iframe by way of the parent frame.\n         * This can occur in the case of a redirect, i.e. we guessed wrong on what server to connect to and received a reset.\n         * Somehow, setTimeout seems to make this ok. That doesn't make sense from a security perspective, since you should\n         * still have the context of your originating frame.\n         */\n        setTimeout(function () {\n            // this.conn_ gets set to null in some of the tests. Check to make sure it still exists before using it\n            _this.conn_ && _this.conn_.open(onMessageReceived, onConnectionLost);\n        }, Math.floor(0));\n        var healthyTimeout_ms = conn['healthyTimeout'] || 0;\n        if (healthyTimeout_ms > 0) {\n            this.healthyTimeout_ = setTimeoutNonBlocking(function () {\n                _this.healthyTimeout_ = null;\n                if (!_this.isHealthy_) {\n                    if (_this.conn_ &&\n                        _this.conn_.bytesReceived > BYTES_RECEIVED_HEALTHY_OVERRIDE) {\n                        _this.log_('Connection exceeded healthy timeout but has received ' +\n                            _this.conn_.bytesReceived +\n                            ' bytes.  Marking connection healthy.');\n                        _this.isHealthy_ = true;\n                        _this.conn_.markConnectionHealthy();\n                    }\n                    else if (_this.conn_ &&\n                        _this.conn_.bytesSent > BYTES_SENT_HEALTHY_OVERRIDE) {\n                        _this.log_('Connection exceeded healthy timeout but has sent ' +\n                            _this.conn_.bytesSent +\n                            ' bytes.  Leaving connection alive.');\n                        // NOTE: We don't want to mark it healthy, since we have no guarantee that the bytes have made it to\n                        // the server.\n                    }\n                    else {\n                        _this.log_('Closing unhealthy connection after timeout.');\n                        _this.close();\n                    }\n                }\n            }, Math.floor(healthyTimeout_ms));\n        }\n    };\n    /**\n     * @return {!string}\n     * @private\n     */\n    Connection.prototype.nextTransportId_ = function () {\n        return 'c:' + this.id + ':' + this.connectionCount++;\n    };\n    Connection.prototype.disconnReceiver_ = function (conn) {\n        var _this = this;\n        return function (everConnected) {\n            if (conn === _this.conn_) {\n                _this.onConnectionLost_(everConnected);\n            }\n            else if (conn === _this.secondaryConn_) {\n                _this.log_('Secondary connection lost.');\n                _this.onSecondaryConnectionLost_();\n            }\n            else {\n                _this.log_('closing an old connection');\n            }\n        };\n    };\n    Connection.prototype.connReceiver_ = function (conn) {\n        var _this = this;\n        return function (message) {\n            if (_this.state_ != 2 /* DISCONNECTED */) {\n                if (conn === _this.rx_) {\n                    _this.onPrimaryMessageReceived_(message);\n                }\n                else if (conn === _this.secondaryConn_) {\n                    _this.onSecondaryMessageReceived_(message);\n                }\n                else {\n                    _this.log_('message on old connection');\n                }\n            }\n        };\n    };\n    /**\n     *\n     * @param {Object} dataMsg An arbitrary data message to be sent to the server\n     */\n    Connection.prototype.sendRequest = function (dataMsg) {\n        // wrap in a data message envelope and send it on\n        var msg = { t: 'd', d: dataMsg };\n        this.sendData_(msg);\n    };\n    Connection.prototype.tryCleanupConnection = function () {\n        if (this.tx_ === this.secondaryConn_ && this.rx_ === this.secondaryConn_) {\n            this.log_('cleaning up and promoting a connection: ' + this.secondaryConn_.connId);\n            this.conn_ = this.secondaryConn_;\n            this.secondaryConn_ = null;\n            // the server will shutdown the old connection\n        }\n    };\n    Connection.prototype.onSecondaryControl_ = function (controlData) {\n        if (MESSAGE_TYPE in controlData) {\n            var cmd = controlData[MESSAGE_TYPE];\n            if (cmd === SWITCH_ACK) {\n                this.upgradeIfSecondaryHealthy_();\n            }\n            else if (cmd === CONTROL_RESET) {\n                // Most likely the session wasn't valid. Abandon the switch attempt\n                this.log_('Got a reset on secondary, closing it');\n                this.secondaryConn_.close();\n                // If we were already using this connection for something, than we need to fully close\n                if (this.tx_ === this.secondaryConn_ ||\n                    this.rx_ === this.secondaryConn_) {\n                    this.close();\n                }\n            }\n            else if (cmd === CONTROL_PONG) {\n                this.log_('got pong on secondary.');\n                this.secondaryResponsesRequired_--;\n                this.upgradeIfSecondaryHealthy_();\n            }\n        }\n    };\n    Connection.prototype.onSecondaryMessageReceived_ = function (parsedData) {\n        var layer = requireKey('t', parsedData);\n        var data = requireKey('d', parsedData);\n        if (layer == 'c') {\n            this.onSecondaryControl_(data);\n        }\n        else if (layer == 'd') {\n            // got a data message, but we're still second connection. Need to buffer it up\n            this.pendingDataMessages.push(data);\n        }\n        else {\n            throw new Error('Unknown protocol layer: ' + layer);\n        }\n    };\n    Connection.prototype.upgradeIfSecondaryHealthy_ = function () {\n        if (this.secondaryResponsesRequired_ <= 0) {\n            this.log_('Secondary connection is healthy.');\n            this.isHealthy_ = true;\n            this.secondaryConn_.markConnectionHealthy();\n            this.proceedWithUpgrade_();\n        }\n        else {\n            // Send a ping to make sure the connection is healthy.\n            this.log_('sending ping on secondary.');\n            this.secondaryConn_.send({ t: 'c', d: { t: PING, d: {} } });\n        }\n    };\n    Connection.prototype.proceedWithUpgrade_ = function () {\n        // tell this connection to consider itself open\n        this.secondaryConn_.start();\n        // send ack\n        this.log_('sending client ack on secondary');\n        this.secondaryConn_.send({ t: 'c', d: { t: SWITCH_ACK, d: {} } });\n        // send end packet on primary transport, switch to sending on this one\n        // can receive on this one, buffer responses until end received on primary transport\n        this.log_('Ending transmission on primary');\n        this.conn_.send({ t: 'c', d: { t: END_TRANSMISSION, d: {} } });\n        this.tx_ = this.secondaryConn_;\n        this.tryCleanupConnection();\n    };\n    Connection.prototype.onPrimaryMessageReceived_ = function (parsedData) {\n        // Must refer to parsedData properties in quotes, so closure doesn't touch them.\n        var layer = requireKey('t', parsedData);\n        var data = requireKey('d', parsedData);\n        if (layer == 'c') {\n            this.onControl_(data);\n        }\n        else if (layer == 'd') {\n            this.onDataMessage_(data);\n        }\n    };\n    Connection.prototype.onDataMessage_ = function (message) {\n        this.onPrimaryResponse_();\n        // We don't do anything with data messages, just kick them up a level\n        this.onMessage_(message);\n    };\n    Connection.prototype.onPrimaryResponse_ = function () {\n        if (!this.isHealthy_) {\n            this.primaryResponsesRequired_--;\n            if (this.primaryResponsesRequired_ <= 0) {\n                this.log_('Primary connection is healthy.');\n                this.isHealthy_ = true;\n                this.conn_.markConnectionHealthy();\n            }\n        }\n    };\n    Connection.prototype.onControl_ = function (controlData) {\n        var cmd = requireKey(MESSAGE_TYPE, controlData);\n        if (MESSAGE_DATA in controlData) {\n            var payload = controlData[MESSAGE_DATA];\n            if (cmd === SERVER_HELLO) {\n                this.onHandshake_(payload);\n            }\n            else if (cmd === END_TRANSMISSION) {\n                this.log_('recvd end transmission on primary');\n                this.rx_ = this.secondaryConn_;\n                for (var i = 0; i < this.pendingDataMessages.length; ++i) {\n                    this.onDataMessage_(this.pendingDataMessages[i]);\n                }\n                this.pendingDataMessages = [];\n                this.tryCleanupConnection();\n            }\n            else if (cmd === CONTROL_SHUTDOWN) {\n                // This was previously the 'onKill' callback passed to the lower-level connection\n                // payload in this case is the reason for the shutdown. Generally a human-readable error\n                this.onConnectionShutdown_(payload);\n            }\n            else if (cmd === CONTROL_RESET) {\n                // payload in this case is the host we should contact\n                this.onReset_(payload);\n            }\n            else if (cmd === CONTROL_ERROR) {\n                error('Server Error: ' + payload);\n            }\n            else if (cmd === CONTROL_PONG) {\n                this.log_('got pong on primary.');\n                this.onPrimaryResponse_();\n                this.sendPingOnPrimaryIfNecessary_();\n            }\n            else {\n                error('Unknown control packet command: ' + cmd);\n            }\n        }\n    };\n    /**\n     *\n     * @param {Object} handshake The handshake data returned from the server\n     * @private\n     */\n    Connection.prototype.onHandshake_ = function (handshake) {\n        var timestamp = handshake.ts;\n        var version = handshake.v;\n        var host = handshake.h;\n        this.sessionId = handshake.s;\n        this.repoInfo_.updateHost(host);\n        // if we've already closed the connection, then don't bother trying to progress further\n        if (this.state_ == 0 /* CONNECTING */) {\n            this.conn_.start();\n            this.onConnectionEstablished_(this.conn_, timestamp);\n            if (PROTOCOL_VERSION !== version) {\n                warn('Protocol version mismatch detected');\n            }\n            // TODO: do we want to upgrade? when? maybe a delay?\n            this.tryStartUpgrade_();\n        }\n    };\n    Connection.prototype.tryStartUpgrade_ = function () {\n        var conn = this.transportManager_.upgradeTransport();\n        if (conn) {\n            this.startUpgrade_(conn);\n        }\n    };\n    Connection.prototype.startUpgrade_ = function (conn) {\n        var _this = this;\n        this.secondaryConn_ = new conn(this.nextTransportId_(), this.repoInfo_, this.sessionId);\n        // For certain transports (WebSockets), we need to send and receive several messages back and forth before we\n        // can consider the transport healthy.\n        this.secondaryResponsesRequired_ =\n            conn['responsesRequiredToBeHealthy'] || 0;\n        var onMessage = this.connReceiver_(this.secondaryConn_);\n        var onDisconnect = this.disconnReceiver_(this.secondaryConn_);\n        this.secondaryConn_.open(onMessage, onDisconnect);\n        // If we haven't successfully upgraded after UPGRADE_TIMEOUT, give up and kill the secondary.\n        setTimeoutNonBlocking(function () {\n            if (_this.secondaryConn_) {\n                _this.log_('Timed out trying to upgrade.');\n                _this.secondaryConn_.close();\n            }\n        }, Math.floor(UPGRADE_TIMEOUT));\n    };\n    Connection.prototype.onReset_ = function (host) {\n        this.log_('Reset packet received.  New host: ' + host);\n        this.repoInfo_.updateHost(host);\n        // TODO: if we're already \"connected\", we need to trigger a disconnect at the next layer up.\n        // We don't currently support resets after the connection has already been established\n        if (this.state_ === 1 /* CONNECTED */) {\n            this.close();\n        }\n        else {\n            // Close whatever connections we have open and start again.\n            this.closeConnections_();\n            this.start_();\n        }\n    };\n    Connection.prototype.onConnectionEstablished_ = function (conn, timestamp) {\n        var _this = this;\n        this.log_('Realtime connection established.');\n        this.conn_ = conn;\n        this.state_ = 1 /* CONNECTED */;\n        if (this.onReady_) {\n            this.onReady_(timestamp, this.sessionId);\n            this.onReady_ = null;\n        }\n        // If after 5 seconds we haven't sent enough requests to the server to get the connection healthy,\n        // send some pings.\n        if (this.primaryResponsesRequired_ === 0) {\n            this.log_('Primary connection is healthy.');\n            this.isHealthy_ = true;\n        }\n        else {\n            setTimeoutNonBlocking(function () {\n                _this.sendPingOnPrimaryIfNecessary_();\n            }, Math.floor(DELAY_BEFORE_SENDING_EXTRA_REQUESTS));\n        }\n    };\n    Connection.prototype.sendPingOnPrimaryIfNecessary_ = function () {\n        // If the connection isn't considered healthy yet, we'll send a noop ping packet request.\n        if (!this.isHealthy_ && this.state_ === 1 /* CONNECTED */) {\n            this.log_('sending ping on primary.');\n            this.sendData_({ t: 'c', d: { t: PING, d: {} } });\n        }\n    };\n    Connection.prototype.onSecondaryConnectionLost_ = function () {\n        var conn = this.secondaryConn_;\n        this.secondaryConn_ = null;\n        if (this.tx_ === conn || this.rx_ === conn) {\n            // we are relying on this connection already in some capacity. Therefore, a failure is real\n            this.close();\n        }\n    };\n    /**\n     *\n     * @param {boolean} everConnected Whether or not the connection ever reached a server. Used to determine if\n     * we should flush the host cache\n     * @private\n     */\n    Connection.prototype.onConnectionLost_ = function (everConnected) {\n        this.conn_ = null;\n        // NOTE: IF you're seeing a Firefox error for this line, I think it might be because it's getting\n        // called on window close and RealtimeState.CONNECTING is no longer defined.  Just a guess.\n        if (!everConnected && this.state_ === 0 /* CONNECTING */) {\n            this.log_('Realtime connection failed.');\n            // Since we failed to connect at all, clear any cached entry for this namespace in case the machine went away\n            if (this.repoInfo_.isCacheableHost()) {\n                PersistentStorage.remove('host:' + this.repoInfo_.host);\n                // reset the internal host to what we would show the user, i.e. <ns>.firebaseio.com\n                this.repoInfo_.internalHost = this.repoInfo_.host;\n            }\n        }\n        else if (this.state_ === 1 /* CONNECTED */) {\n            this.log_('Realtime connection lost.');\n        }\n        this.close();\n    };\n    /**\n     *\n     * @param {string} reason\n     * @private\n     */\n    Connection.prototype.onConnectionShutdown_ = function (reason) {\n        this.log_('Connection shutdown command received. Shutting down...');\n        if (this.onKill_) {\n            this.onKill_(reason);\n            this.onKill_ = null;\n        }\n        // We intentionally don't want to fire onDisconnect (kill is a different case),\n        // so clear the callback.\n        this.onDisconnect_ = null;\n        this.close();\n    };\n    Connection.prototype.sendData_ = function (data) {\n        if (this.state_ !== 1 /* CONNECTED */) {\n            throw 'Connection is not connected';\n        }\n        else {\n            this.tx_.send(data);\n        }\n    };\n    /**\n     * Cleans up this connection, calling the appropriate callbacks\n     */\n    Connection.prototype.close = function () {\n        if (this.state_ !== 2 /* DISCONNECTED */) {\n            this.log_('Closing realtime connection.');\n            this.state_ = 2 /* DISCONNECTED */;\n            this.closeConnections_();\n            if (this.onDisconnect_) {\n                this.onDisconnect_();\n                this.onDisconnect_ = null;\n            }\n        }\n    };\n    /**\n     *\n     * @private\n     */\n    Connection.prototype.closeConnections_ = function () {\n        this.log_('Shutting down all connections');\n        if (this.conn_) {\n            this.conn_.close();\n            this.conn_ = null;\n        }\n        if (this.secondaryConn_) {\n            this.secondaryConn_.close();\n            this.secondaryConn_ = null;\n        }\n        if (this.healthyTimeout_) {\n            clearTimeout(this.healthyTimeout_);\n            this.healthyTimeout_ = null;\n        }\n    };\n    return Connection;\n}());\nexport { Connection };\n\n\n"]}