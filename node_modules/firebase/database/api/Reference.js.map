{"version":3,"sources":["src/database/api/Reference.ts","database/api/Reference.js"],"names":["__extends","extendStatics","Object","setPrototypeOf","__proto__","Array","d","b","p","hasOwnProperty","__","constructor","prototype","create","Reference","_super","repo","path","_this","Error","call","DEFAULT","getKey","arguments","length","isEmpty","getBack","child","pathString","String","getFront","getParent","parentPath","parent","getRoot","ref","databaseProp","database","set","newVal","onComplete","deferred","setWithPriority","wrapCallback","promise","update","objectToMerge","isArray","newObjectToMerge","i","newPriority","remove","transaction","transactionUpdate","applyLocally","undefined","promiseComplete","error","committed","snapshot","reject","resolve","startTransaction","setPriority","priority","push","value","now","serverTime","name","thennablePushRef","pushRef","then","bind","catch","onDisconnect","defineProperty","get","enumerable","configurable","__referenceConstructor"],"mappings":"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","file":"Reference.js","sourcesContent":["/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\nimport { OnDisconnect } from './onDisconnect';\nimport { TransactionResult } from './TransactionResult';\nimport { warn } from '../core/util/util';\nimport { nextPushId } from '../core/util/NextPushId';\nimport { Query } from './Query';\nimport { Repo } from '../core/Repo';\nimport { Path } from '../core/util/Path';\nimport { QueryParams } from '../core/view/QueryParams';\nimport {\n  validateRootPathString,\n  validatePathString,\n  validateFirebaseMergeDataArg,\n  validateBoolean,\n  validatePriority,\n  validateFirebaseDataArg,\n  validateWritablePath\n} from '../core/util/validation';\nimport { validateArgCount, validateCallback } from '../../utils/validation';\nimport {\n  Deferred,\n  attachDummyErrorHandler,\n  PromiseImpl\n} from '../../utils/promise';\nimport { SyncPoint } from '../core/SyncPoint';\nimport { Database } from './Database';\nimport { DataSnapshot } from './DataSnapshot';\n\nexport interface ReferenceConstructor {\n  new (repo: Repo, path: Path): Reference;\n}\n\nexport class Reference extends Query {\n  public then: (a?: any) => Promise<any>;\n  public catch: (a?: Error) => Promise<any>;\n\n  /**\n   * Call options:\n   *   new Reference(Repo, Path) or\n   *   new Reference(url: string, string|RepoManager)\n   *\n   * Externally - this is the firebase.database.Reference type.\n   *\n   * @param {!Repo} repo\n   * @param {(!Path)} path\n   * @extends {Query}\n   */\n  constructor(repo: Repo, path: Path) {\n    if (!(repo instanceof Repo)) {\n      throw new Error(\n        'new Reference() no longer supported - use app.database().'\n      );\n    }\n\n    // call Query's constructor, passing in the repo and path.\n    super(repo, path, QueryParams.DEFAULT, false);\n  }\n\n  /** @return {?string} */\n  getKey(): string | null {\n    validateArgCount('Reference.key', 0, 0, arguments.length);\n\n    if (this.path.isEmpty()) return null;\n    else return this.path.getBack();\n  }\n\n  /**\n   * @param {!(string|Path)} pathString\n   * @return {!Reference}\n   */\n  child(pathString: string | Path): Reference {\n    validateArgCount('Reference.child', 1, 1, arguments.length);\n    if (typeof pathString === 'number') {\n      pathString = String(pathString);\n    } else if (!(pathString instanceof Path)) {\n      if (this.path.getFront() === null)\n        validateRootPathString('Reference.child', 1, pathString, false);\n      else validatePathString('Reference.child', 1, pathString, false);\n    }\n\n    return new Reference(this.repo, this.path.child(pathString));\n  }\n\n  /** @return {?Reference} */\n  getParent(): Reference | null {\n    validateArgCount('Reference.parent', 0, 0, arguments.length);\n\n    const parentPath = this.path.parent();\n    return parentPath === null ? null : new Reference(this.repo, parentPath);\n  }\n\n  /** @return {!Reference} */\n  getRoot(): Reference {\n    validateArgCount('Reference.root', 0, 0, arguments.length);\n\n    let ref = this as any;\n    while (ref.getParent() !== null) {\n      ref = ref.getParent();\n    }\n    return ref;\n  }\n\n  /** @return {!Database} */\n  databaseProp(): Database {\n    return this.repo.database;\n  }\n\n  /**\n   * @param {*} newVal\n   * @param {function(?Error)=} onComplete\n   * @return {!Promise}\n   */\n  set(newVal: any, onComplete?: (a: Error | null) => void): Promise<any> {\n    validateArgCount('Reference.set', 1, 2, arguments.length);\n    validateWritablePath('Reference.set', this.path);\n    validateFirebaseDataArg('Reference.set', 1, newVal, this.path, false);\n    validateCallback('Reference.set', 2, onComplete, true);\n\n    const deferred = new Deferred();\n    this.repo.setWithPriority(\n      this.path,\n      newVal,\n      /*priority=*/ null,\n      deferred.wrapCallback(onComplete)\n    );\n    return deferred.promise;\n  }\n\n  /**\n   * @param {!Object} objectToMerge\n   * @param {function(?Error)=} onComplete\n   * @return {!Promise}\n   */\n  update(\n    objectToMerge: Object,\n    onComplete?: (a: Error | null) => void\n  ): Promise<any> {\n    validateArgCount('Reference.update', 1, 2, arguments.length);\n    validateWritablePath('Reference.update', this.path);\n\n    if (Array.isArray(objectToMerge)) {\n      const newObjectToMerge: { [k: string]: any } = {};\n      for (let i = 0; i < objectToMerge.length; ++i) {\n        newObjectToMerge['' + i] = objectToMerge[i];\n      }\n      objectToMerge = newObjectToMerge;\n      warn(\n        'Passing an Array to Firebase.update() is deprecated. ' +\n          'Use set() if you want to overwrite the existing data, or ' +\n          'an Object with integer keys if you really do want to ' +\n          'only update some of the children.'\n      );\n    }\n    validateFirebaseMergeDataArg(\n      'Reference.update',\n      1,\n      objectToMerge,\n      this.path,\n      false\n    );\n    validateCallback('Reference.update', 2, onComplete, true);\n    const deferred = new Deferred();\n    this.repo.update(\n      this.path,\n      objectToMerge,\n      deferred.wrapCallback(onComplete)\n    );\n    return deferred.promise;\n  }\n\n  /**\n   * @param {*} newVal\n   * @param {string|number|null} newPriority\n   * @param {function(?Error)=} onComplete\n   * @return {!Promise}\n   */\n  setWithPriority(\n    newVal: any,\n    newPriority: string | number | null,\n    onComplete?: (a: Error | null) => void\n  ): Promise<any> {\n    validateArgCount('Reference.setWithPriority', 2, 3, arguments.length);\n    validateWritablePath('Reference.setWithPriority', this.path);\n    validateFirebaseDataArg(\n      'Reference.setWithPriority',\n      1,\n      newVal,\n      this.path,\n      false\n    );\n    validatePriority('Reference.setWithPriority', 2, newPriority, false);\n    validateCallback('Reference.setWithPriority', 3, onComplete, true);\n\n    if (this.getKey() === '.length' || this.getKey() === '.keys')\n      throw 'Reference.setWithPriority failed: ' +\n        this.getKey() +\n        ' is a read-only object.';\n\n    const deferred = new Deferred();\n    this.repo.setWithPriority(\n      this.path,\n      newVal,\n      newPriority,\n      deferred.wrapCallback(onComplete)\n    );\n    return deferred.promise;\n  }\n\n  /**\n   * @param {function(?Error)=} onComplete\n   * @return {!Promise}\n   */\n  remove(onComplete?: (a: Error | null) => void): Promise<any> {\n    validateArgCount('Reference.remove', 0, 1, arguments.length);\n    validateWritablePath('Reference.remove', this.path);\n    validateCallback('Reference.remove', 1, onComplete, true);\n\n    return this.set(null, onComplete);\n  }\n\n  /**\n   * @param {function(*):*} transactionUpdate\n   * @param {(function(?Error, boolean, ?DataSnapshot))=} onComplete\n   * @param {boolean=} applyLocally\n   * @return {!Promise}\n   */\n  transaction(\n    transactionUpdate: (a: any) => any,\n    onComplete?: (a: Error | null, b: boolean, c: DataSnapshot | null) => void,\n    applyLocally?: boolean\n  ): Promise<TransactionResult> {\n    validateArgCount('Reference.transaction', 1, 3, arguments.length);\n    validateWritablePath('Reference.transaction', this.path);\n    validateCallback('Reference.transaction', 1, transactionUpdate, false);\n    validateCallback('Reference.transaction', 2, onComplete, true);\n    // NOTE: applyLocally is an internal-only option for now.  We need to decide if we want to keep it and how\n    // to expose it.\n    validateBoolean('Reference.transaction', 3, applyLocally, true);\n\n    if (this.getKey() === '.length' || this.getKey() === '.keys')\n      throw 'Reference.transaction failed: ' +\n        this.getKey() +\n        ' is a read-only object.';\n\n    if (applyLocally === undefined) applyLocally = true;\n\n    const deferred = new Deferred();\n    if (typeof onComplete === 'function') {\n      attachDummyErrorHandler(deferred.promise);\n    }\n\n    const promiseComplete = function(\n      error: Error,\n      committed: boolean,\n      snapshot: DataSnapshot\n    ) {\n      if (error) {\n        deferred.reject(error);\n      } else {\n        deferred.resolve(new TransactionResult(committed, snapshot));\n      }\n      if (typeof onComplete === 'function') {\n        onComplete(error, committed, snapshot);\n      }\n    };\n    this.repo.startTransaction(\n      this.path,\n      transactionUpdate,\n      promiseComplete,\n      applyLocally\n    );\n\n    return deferred.promise;\n  }\n\n  /**\n   * @param {string|number|null} priority\n   * @param {function(?Error)=} onComplete\n   * @return {!Promise}\n   */\n  setPriority(\n    priority: string | number | null,\n    onComplete?: (a: Error | null) => void\n  ): Promise<any> {\n    validateArgCount('Reference.setPriority', 1, 2, arguments.length);\n    validateWritablePath('Reference.setPriority', this.path);\n    validatePriority('Reference.setPriority', 1, priority, false);\n    validateCallback('Reference.setPriority', 2, onComplete, true);\n\n    const deferred = new Deferred();\n    this.repo.setWithPriority(\n      this.path.child('.priority'),\n      priority,\n      null,\n      deferred.wrapCallback(onComplete)\n    );\n    return deferred.promise;\n  }\n\n  /**\n   * @param {*=} value\n   * @param {function(?Error)=} onComplete\n   * @return {!Reference}\n   */\n  push(value?: any, onComplete?: (a: Error | null) => void): Reference {\n    validateArgCount('Reference.push', 0, 2, arguments.length);\n    validateWritablePath('Reference.push', this.path);\n    validateFirebaseDataArg('Reference.push', 1, value, this.path, true);\n    validateCallback('Reference.push', 2, onComplete, true);\n\n    const now = this.repo.serverTime();\n    const name = nextPushId(now);\n\n    // push() returns a ThennableReference whose promise is fulfilled with a regular Reference.\n    // We use child() to create handles to two different references. The first is turned into a\n    // ThennableReference below by adding then() and catch() methods and is used as the\n    // return value of push(). The second remains a regular Reference and is used as the fulfilled\n    // value of the first ThennableReference.\n    const thennablePushRef = this.child(name);\n    const pushRef = this.child(name);\n\n    let promise;\n    if (value != null) {\n      promise = thennablePushRef.set(value, onComplete).then(() => pushRef);\n    } else {\n      promise = PromiseImpl.resolve(pushRef);\n    }\n\n    thennablePushRef.then = promise.then.bind(promise);\n    thennablePushRef.catch = promise.then.bind(promise, undefined);\n\n    if (typeof onComplete === 'function') {\n      attachDummyErrorHandler(promise);\n    }\n\n    return thennablePushRef;\n  }\n\n  /**\n   * @return {!OnDisconnect}\n   */\n  onDisconnect(): OnDisconnect {\n    validateWritablePath('Reference.onDisconnect', this.path);\n    return new OnDisconnect(this.repo, this.path);\n  }\n\n  get database(): Database {\n    return this.databaseProp();\n  }\n\n  get key(): string | null {\n    return this.getKey();\n  }\n\n  get parent(): Reference | null {\n    return this.getParent();\n  }\n\n  get root(): Reference {\n    return this.getRoot();\n  }\n}\n\n/**\n * Define reference constructor in various modules\n *\n * We are doing this here to avoid several circular\n * dependency issues\n */\nQuery.__referenceConstructor = Reference;\nSyncPoint.__referenceConstructor = Reference;\n","/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { OnDisconnect } from './onDisconnect';\nimport { TransactionResult } from './TransactionResult';\nimport { warn } from '../core/util/util';\nimport { nextPushId } from '../core/util/NextPushId';\nimport { Query } from './Query';\nimport { Repo } from '../core/Repo';\nimport { Path } from '../core/util/Path';\nimport { QueryParams } from '../core/view/QueryParams';\nimport { validateRootPathString, validatePathString, validateFirebaseMergeDataArg, validateBoolean, validatePriority, validateFirebaseDataArg, validateWritablePath } from '../core/util/validation';\nimport { validateArgCount, validateCallback } from '../../utils/validation';\nimport { Deferred, attachDummyErrorHandler, PromiseImpl } from '../../utils/promise';\nimport { SyncPoint } from '../core/SyncPoint';\nvar Reference = (function (_super) {\n    __extends(Reference, _super);\n    /**\n     * Call options:\n     *   new Reference(Repo, Path) or\n     *   new Reference(url: string, string|RepoManager)\n     *\n     * Externally - this is the firebase.database.Reference type.\n     *\n     * @param {!Repo} repo\n     * @param {(!Path)} path\n     * @extends {Query}\n     */\n    function Reference(repo, path) {\n        var _this = this;\n        if (!(repo instanceof Repo)) {\n            throw new Error('new Reference() no longer supported - use app.database().');\n        }\n        // call Query's constructor, passing in the repo and path.\n        _this = _super.call(this, repo, path, QueryParams.DEFAULT, false) || this;\n        return _this;\n    }\n    /** @return {?string} */\n    Reference.prototype.getKey = function () {\n        validateArgCount('Reference.key', 0, 0, arguments.length);\n        if (this.path.isEmpty())\n            return null;\n        else\n            return this.path.getBack();\n    };\n    /**\n     * @param {!(string|Path)} pathString\n     * @return {!Reference}\n     */\n    Reference.prototype.child = function (pathString) {\n        validateArgCount('Reference.child', 1, 1, arguments.length);\n        if (typeof pathString === 'number') {\n            pathString = String(pathString);\n        }\n        else if (!(pathString instanceof Path)) {\n            if (this.path.getFront() === null)\n                validateRootPathString('Reference.child', 1, pathString, false);\n            else\n                validatePathString('Reference.child', 1, pathString, false);\n        }\n        return new Reference(this.repo, this.path.child(pathString));\n    };\n    /** @return {?Reference} */\n    Reference.prototype.getParent = function () {\n        validateArgCount('Reference.parent', 0, 0, arguments.length);\n        var parentPath = this.path.parent();\n        return parentPath === null ? null : new Reference(this.repo, parentPath);\n    };\n    /** @return {!Reference} */\n    Reference.prototype.getRoot = function () {\n        validateArgCount('Reference.root', 0, 0, arguments.length);\n        var ref = this;\n        while (ref.getParent() !== null) {\n            ref = ref.getParent();\n        }\n        return ref;\n    };\n    /** @return {!Database} */\n    Reference.prototype.databaseProp = function () {\n        return this.repo.database;\n    };\n    /**\n     * @param {*} newVal\n     * @param {function(?Error)=} onComplete\n     * @return {!Promise}\n     */\n    Reference.prototype.set = function (newVal, onComplete) {\n        validateArgCount('Reference.set', 1, 2, arguments.length);\n        validateWritablePath('Reference.set', this.path);\n        validateFirebaseDataArg('Reference.set', 1, newVal, this.path, false);\n        validateCallback('Reference.set', 2, onComplete, true);\n        var deferred = new Deferred();\n        this.repo.setWithPriority(this.path, newVal, \n        /*priority=*/ null, deferred.wrapCallback(onComplete));\n        return deferred.promise;\n    };\n    /**\n     * @param {!Object} objectToMerge\n     * @param {function(?Error)=} onComplete\n     * @return {!Promise}\n     */\n    Reference.prototype.update = function (objectToMerge, onComplete) {\n        validateArgCount('Reference.update', 1, 2, arguments.length);\n        validateWritablePath('Reference.update', this.path);\n        if (Array.isArray(objectToMerge)) {\n            var newObjectToMerge = {};\n            for (var i = 0; i < objectToMerge.length; ++i) {\n                newObjectToMerge['' + i] = objectToMerge[i];\n            }\n            objectToMerge = newObjectToMerge;\n            warn('Passing an Array to Firebase.update() is deprecated. ' +\n                'Use set() if you want to overwrite the existing data, or ' +\n                'an Object with integer keys if you really do want to ' +\n                'only update some of the children.');\n        }\n        validateFirebaseMergeDataArg('Reference.update', 1, objectToMerge, this.path, false);\n        validateCallback('Reference.update', 2, onComplete, true);\n        var deferred = new Deferred();\n        this.repo.update(this.path, objectToMerge, deferred.wrapCallback(onComplete));\n        return deferred.promise;\n    };\n    /**\n     * @param {*} newVal\n     * @param {string|number|null} newPriority\n     * @param {function(?Error)=} onComplete\n     * @return {!Promise}\n     */\n    Reference.prototype.setWithPriority = function (newVal, newPriority, onComplete) {\n        validateArgCount('Reference.setWithPriority', 2, 3, arguments.length);\n        validateWritablePath('Reference.setWithPriority', this.path);\n        validateFirebaseDataArg('Reference.setWithPriority', 1, newVal, this.path, false);\n        validatePriority('Reference.setWithPriority', 2, newPriority, false);\n        validateCallback('Reference.setWithPriority', 3, onComplete, true);\n        if (this.getKey() === '.length' || this.getKey() === '.keys')\n            throw 'Reference.setWithPriority failed: ' +\n                this.getKey() +\n                ' is a read-only object.';\n        var deferred = new Deferred();\n        this.repo.setWithPriority(this.path, newVal, newPriority, deferred.wrapCallback(onComplete));\n        return deferred.promise;\n    };\n    /**\n     * @param {function(?Error)=} onComplete\n     * @return {!Promise}\n     */\n    Reference.prototype.remove = function (onComplete) {\n        validateArgCount('Reference.remove', 0, 1, arguments.length);\n        validateWritablePath('Reference.remove', this.path);\n        validateCallback('Reference.remove', 1, onComplete, true);\n        return this.set(null, onComplete);\n    };\n    /**\n     * @param {function(*):*} transactionUpdate\n     * @param {(function(?Error, boolean, ?DataSnapshot))=} onComplete\n     * @param {boolean=} applyLocally\n     * @return {!Promise}\n     */\n    Reference.prototype.transaction = function (transactionUpdate, onComplete, applyLocally) {\n        validateArgCount('Reference.transaction', 1, 3, arguments.length);\n        validateWritablePath('Reference.transaction', this.path);\n        validateCallback('Reference.transaction', 1, transactionUpdate, false);\n        validateCallback('Reference.transaction', 2, onComplete, true);\n        // NOTE: applyLocally is an internal-only option for now.  We need to decide if we want to keep it and how\n        // to expose it.\n        validateBoolean('Reference.transaction', 3, applyLocally, true);\n        if (this.getKey() === '.length' || this.getKey() === '.keys')\n            throw 'Reference.transaction failed: ' +\n                this.getKey() +\n                ' is a read-only object.';\n        if (applyLocally === undefined)\n            applyLocally = true;\n        var deferred = new Deferred();\n        if (typeof onComplete === 'function') {\n            attachDummyErrorHandler(deferred.promise);\n        }\n        var promiseComplete = function (error, committed, snapshot) {\n            if (error) {\n                deferred.reject(error);\n            }\n            else {\n                deferred.resolve(new TransactionResult(committed, snapshot));\n            }\n            if (typeof onComplete === 'function') {\n                onComplete(error, committed, snapshot);\n            }\n        };\n        this.repo.startTransaction(this.path, transactionUpdate, promiseComplete, applyLocally);\n        return deferred.promise;\n    };\n    /**\n     * @param {string|number|null} priority\n     * @param {function(?Error)=} onComplete\n     * @return {!Promise}\n     */\n    Reference.prototype.setPriority = function (priority, onComplete) {\n        validateArgCount('Reference.setPriority', 1, 2, arguments.length);\n        validateWritablePath('Reference.setPriority', this.path);\n        validatePriority('Reference.setPriority', 1, priority, false);\n        validateCallback('Reference.setPriority', 2, onComplete, true);\n        var deferred = new Deferred();\n        this.repo.setWithPriority(this.path.child('.priority'), priority, null, deferred.wrapCallback(onComplete));\n        return deferred.promise;\n    };\n    /**\n     * @param {*=} value\n     * @param {function(?Error)=} onComplete\n     * @return {!Reference}\n     */\n    Reference.prototype.push = function (value, onComplete) {\n        validateArgCount('Reference.push', 0, 2, arguments.length);\n        validateWritablePath('Reference.push', this.path);\n        validateFirebaseDataArg('Reference.push', 1, value, this.path, true);\n        validateCallback('Reference.push', 2, onComplete, true);\n        var now = this.repo.serverTime();\n        var name = nextPushId(now);\n        // push() returns a ThennableReference whose promise is fulfilled with a regular Reference.\n        // We use child() to create handles to two different references. The first is turned into a\n        // ThennableReference below by adding then() and catch() methods and is used as the\n        // return value of push(). The second remains a regular Reference and is used as the fulfilled\n        // value of the first ThennableReference.\n        var thennablePushRef = this.child(name);\n        var pushRef = this.child(name);\n        var promise;\n        if (value != null) {\n            promise = thennablePushRef.set(value, onComplete).then(function () { return pushRef; });\n        }\n        else {\n            promise = PromiseImpl.resolve(pushRef);\n        }\n        thennablePushRef.then = promise.then.bind(promise);\n        thennablePushRef.catch = promise.then.bind(promise, undefined);\n        if (typeof onComplete === 'function') {\n            attachDummyErrorHandler(promise);\n        }\n        return thennablePushRef;\n    };\n    /**\n     * @return {!OnDisconnect}\n     */\n    Reference.prototype.onDisconnect = function () {\n        validateWritablePath('Reference.onDisconnect', this.path);\n        return new OnDisconnect(this.repo, this.path);\n    };\n    Object.defineProperty(Reference.prototype, \"database\", {\n        get: function () {\n            return this.databaseProp();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Reference.prototype, \"key\", {\n        get: function () {\n            return this.getKey();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Reference.prototype, \"parent\", {\n        get: function () {\n            return this.getParent();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Reference.prototype, \"root\", {\n        get: function () {\n            return this.getRoot();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return Reference;\n}(Query));\nexport { Reference };\n/**\n * Define reference constructor in various modules\n *\n * We are doing this here to avoid several circular\n * dependency issues\n */\nQuery.__referenceConstructor = Reference;\nSyncPoint.__referenceConstructor = Reference;\n\n\n"]}