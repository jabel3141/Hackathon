{"version":3,"sources":["src/database/api/Query.ts","database/api/Query.js"],"names":["__referenceConstructor","Query","repo","path","queryParams_","orderByCalled_","Object","defineProperty","get","set","val","enumerable","configurable","validateQueryEndpoints_","params","startNode","endNode","hasStart","getIndexStartValue","hasEnd","getIndexEndValue","getIndex","tooManyArgsError","wrongArgTypeError","startName","getIndexStartName","Error","endName","getIndexEndName","validateLimit_","hasLimit","hasAnchoredLimit","prototype","validateNoPreviousOrderByCall_","fnName","getQueryParams","getRef","arguments","length","on","eventType","callback","cancelCallbackOrContext","context","ret","getCancelAndContextArgs_","onValueEvent","cancel","callbacks","onChildEvent","cancelCallback","container","addEventCallbackForQuery","off","valueCallback","removeEventCallbackForQuery","once","userCallback","cancelOrContext","_this","firstCall","deferred","promise","onceCallback","snapshot","bind","resolve","err","reject","limitToFirst","limit","Math","floor","limitToLast","orderByChild","parsedPath","isEmpty","index","newParams","orderBy","orderByKey","orderByPriority","orderByValue","startAt","value","name","undefined","endAt","equalTo","toString","toUrlEncodedString","toJSON","queryObject","getQueryObject","queryIdentifier","obj","id","isEqual","other","error","sameRepo","samePath","equals","sameQueryIdentifier"],"mappings":"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","file":"Query.js","sourcesContent":["/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\nimport { assert } from '../../utils/assert';\nimport { KEY_INDEX } from '../core/snap/indexes/KeyIndex';\nimport { PRIORITY_INDEX } from '../core/snap/indexes/PriorityIndex';\nimport { VALUE_INDEX } from '../core/snap/indexes/ValueIndex';\nimport { PathIndex } from '../core/snap/indexes/PathIndex';\nimport { MIN_NAME, MAX_NAME, ObjectToUniqueKey } from '../core/util/util';\nimport { Path } from '../core/util/Path';\nimport {\n  isValidPriority,\n  validateEventType,\n  validatePathString,\n  validateFirebaseDataArg,\n  validateKey\n} from '../core/util/validation';\nimport {\n  errorPrefix,\n  validateArgCount,\n  validateCallback,\n  validateContextObject\n} from '../../utils/validation';\nimport {\n  ValueEventRegistration,\n  ChildEventRegistration,\n  EventRegistration\n} from '../core/view/EventRegistration';\nimport { Deferred, attachDummyErrorHandler } from '../../utils/promise';\nimport { Repo } from '../core/Repo';\nimport { QueryParams } from '../core/view/QueryParams';\nimport { Reference } from './Reference';\nimport { DataSnapshot } from './DataSnapshot';\n\nlet __referenceConstructor: new (repo: Repo, path: Path) => Query;\n\nexport interface SnapshotCallback {\n  (a: DataSnapshot, b?: string): any;\n}\n\n/**\n * A Query represents a filter to be applied to a firebase location.  This object purely represents the\n * query expression (and exposes our public API to build the query).  The actual query logic is in ViewBase.js.\n *\n * Since every Firebase reference is a query, Firebase inherits from this object.\n */\nexport class Query {\n  static set __referenceConstructor(val) {\n    __referenceConstructor = val;\n  }\n\n  static get __referenceConstructor() {\n    assert(__referenceConstructor, 'Reference.ts has not been loaded');\n    return __referenceConstructor;\n  }\n\n  constructor(\n    public repo: Repo,\n    public path: Path,\n    private queryParams_: QueryParams,\n    private orderByCalled_: boolean\n  ) {}\n\n  /**\n   * Validates start/end values for queries.\n   * @param {!QueryParams} params\n   * @private\n   */\n  private static validateQueryEndpoints_(params: QueryParams) {\n    let startNode = null;\n    let endNode = null;\n    if (params.hasStart()) {\n      startNode = params.getIndexStartValue();\n    }\n    if (params.hasEnd()) {\n      endNode = params.getIndexEndValue();\n    }\n\n    if (params.getIndex() === KEY_INDEX) {\n      const tooManyArgsError =\n        'Query: When ordering by key, you may only pass one argument to ' +\n        'startAt(), endAt(), or equalTo().';\n      const wrongArgTypeError =\n        'Query: When ordering by key, the argument passed to startAt(), endAt(),' +\n        'or equalTo() must be a string.';\n      if (params.hasStart()) {\n        const startName = params.getIndexStartName();\n        if (startName != MIN_NAME) {\n          throw new Error(tooManyArgsError);\n        } else if (typeof startNode !== 'string') {\n          throw new Error(wrongArgTypeError);\n        }\n      }\n      if (params.hasEnd()) {\n        const endName = params.getIndexEndName();\n        if (endName != MAX_NAME) {\n          throw new Error(tooManyArgsError);\n        } else if (typeof endNode !== 'string') {\n          throw new Error(wrongArgTypeError);\n        }\n      }\n    } else if (params.getIndex() === PRIORITY_INDEX) {\n      if (\n        (startNode != null && !isValidPriority(startNode)) ||\n        (endNode != null && !isValidPriority(endNode))\n      ) {\n        throw new Error(\n          'Query: When ordering by priority, the first argument passed to startAt(), ' +\n            'endAt(), or equalTo() must be a valid priority value (null, a number, or a string).'\n        );\n      }\n    } else {\n      assert(\n        params.getIndex() instanceof PathIndex ||\n          params.getIndex() === VALUE_INDEX,\n        'unknown index type.'\n      );\n      if (\n        (startNode != null && typeof startNode === 'object') ||\n        (endNode != null && typeof endNode === 'object')\n      ) {\n        throw new Error(\n          'Query: First argument passed to startAt(), endAt(), or equalTo() cannot be ' +\n            'an object.'\n        );\n      }\n    }\n  }\n\n  /**\n   * Validates that limit* has been called with the correct combination of parameters\n   * @param {!QueryParams} params\n   * @private\n   */\n  private static validateLimit_(params: QueryParams) {\n    if (\n      params.hasStart() &&\n      params.hasEnd() &&\n      params.hasLimit() &&\n      !params.hasAnchoredLimit()\n    ) {\n      throw new Error(\n        \"Query: Can't combine startAt(), endAt(), and limit(). Use limitToFirst() or limitToLast() instead.\"\n      );\n    }\n  }\n\n  /**\n   * Validates that no other order by call has been made\n   * @param {!string} fnName\n   * @private\n   */\n  private validateNoPreviousOrderByCall_(fnName: string) {\n    if (this.orderByCalled_ === true) {\n      throw new Error(fnName + \": You can't combine multiple orderBy calls.\");\n    }\n  }\n\n  /**\n   * @return {!QueryParams}\n   */\n  getQueryParams(): QueryParams {\n    return this.queryParams_;\n  }\n\n  /**\n   * @return {!Reference}\n   */\n  getRef(): Reference {\n    validateArgCount('Query.ref', 0, 0, arguments.length);\n    // This is a slight hack. We cannot goog.require('fb.api.Firebase'), since Firebase requires fb.api.Query.\n    // However, we will always export 'Firebase' to the global namespace, so it's guaranteed to exist by the time this\n    // method gets called.\n    return new Query.__referenceConstructor(this.repo, this.path) as Reference;\n  }\n\n  /**\n   * @param {!string} eventType\n   * @param {!function(DataSnapshot, string=)} callback\n   * @param {(function(Error)|Object)=} cancelCallbackOrContext\n   * @param {Object=} context\n   * @return {!function(DataSnapshot, string=)}\n   */\n  on(\n    eventType: string,\n    callback: SnapshotCallback,\n    cancelCallbackOrContext?: ((a: Error) => any) | Object,\n    context?: Object\n  ): SnapshotCallback {\n    validateArgCount('Query.on', 2, 4, arguments.length);\n    validateEventType('Query.on', 1, eventType, false);\n    validateCallback('Query.on', 2, callback, false);\n\n    const ret = Query.getCancelAndContextArgs_(\n      'Query.on',\n      cancelCallbackOrContext,\n      context\n    );\n\n    if (eventType === 'value') {\n      this.onValueEvent(callback, ret.cancel, ret.context);\n    } else {\n      const callbacks: { [k: string]: typeof callback } = {};\n      callbacks[eventType] = callback;\n      this.onChildEvent(callbacks, ret.cancel, ret.context);\n    }\n    return callback;\n  }\n\n  /**\n   * @param {!function(!DataSnapshot)} callback\n   * @param {?function(Error)} cancelCallback\n   * @param {?Object} context\n   * @protected\n   */\n  protected onValueEvent(\n    callback: (a: DataSnapshot) => void,\n    cancelCallback: ((a: Error) => void) | null,\n    context: Object | null\n  ) {\n    const container = new ValueEventRegistration(\n      callback,\n      cancelCallback || null,\n      context || null\n    );\n    this.repo.addEventCallbackForQuery(this, container);\n  }\n\n  /**\n   * @param {!Object.<string, !function(!DataSnapshot, ?string)>} callbacks\n   * @param {?function(Error)} cancelCallback\n   * @param {?Object} context\n   * @protected\n   */\n  onChildEvent(\n    callbacks: { [k: string]: SnapshotCallback },\n    cancelCallback: ((a: Error) => any) | null,\n    context: Object | null\n  ) {\n    const container = new ChildEventRegistration(\n      callbacks,\n      cancelCallback,\n      context\n    );\n    this.repo.addEventCallbackForQuery(this, container);\n  }\n\n  /**\n   * @param {string=} eventType\n   * @param {(function(!DataSnapshot, ?string=))=} callback\n   * @param {Object=} context\n   */\n  off(eventType?: string, callback?: SnapshotCallback, context?: Object) {\n    validateArgCount('Query.off', 0, 3, arguments.length);\n    validateEventType('Query.off', 1, eventType, true);\n    validateCallback('Query.off', 2, callback, true);\n    validateContextObject('Query.off', 3, context, true);\n\n    let container: EventRegistration | null = null;\n    let callbacks: { [k: string]: typeof callback } | null = null;\n    if (eventType === 'value') {\n      const valueCallback = callback || null;\n      container = new ValueEventRegistration(\n        valueCallback,\n        null,\n        context || null\n      );\n    } else if (eventType) {\n      if (callback) {\n        callbacks = {};\n        callbacks[eventType] = callback;\n      }\n      container = new ChildEventRegistration(callbacks, null, context || null);\n    }\n    this.repo.removeEventCallbackForQuery(this, container);\n  }\n\n  /**\n   * Attaches a listener, waits for the first event, and then removes the listener\n   * @param {!string} eventType\n   * @param {!function(!DataSnapshot, string=)} userCallback\n   * @param cancelOrContext\n   * @param context\n   * @return {!firebase.Promise}\n   */\n  once(\n    eventType: string,\n    userCallback?: SnapshotCallback,\n    cancelOrContext?: ((a: Error) => void) | Object,\n    context?: Object\n  ): Promise<DataSnapshot> {\n    validateArgCount('Query.once', 1, 4, arguments.length);\n    validateEventType('Query.once', 1, eventType, false);\n    validateCallback('Query.once', 2, userCallback, true);\n\n    const ret = Query.getCancelAndContextArgs_(\n      'Query.once',\n      cancelOrContext,\n      context\n    );\n\n    // TODO: Implement this more efficiently (in particular, use 'get' wire protocol for 'value' event)\n    // TODO: consider actually wiring the callbacks into the promise. We cannot do this without a breaking change\n    // because the API currently expects callbacks will be called synchronously if the data is cached, but this is\n    // against the Promise specification.\n    let firstCall = true;\n    const deferred = new Deferred();\n    attachDummyErrorHandler(deferred.promise);\n\n    const onceCallback = (snapshot: DataSnapshot) => {\n      // NOTE: Even though we unsubscribe, we may get called multiple times if a single action (e.g. set() with JSON)\n      // triggers multiple events (e.g. child_added or child_changed).\n      if (firstCall) {\n        firstCall = false;\n        this.off(eventType, onceCallback);\n\n        if (userCallback) {\n          userCallback.bind(ret.context)(snapshot);\n        }\n        deferred.resolve(snapshot);\n      }\n    };\n\n    this.on(\n      eventType,\n      onceCallback,\n      /*cancel=*/ err => {\n        this.off(eventType, onceCallback);\n\n        if (ret.cancel) ret.cancel.bind(ret.context)(err);\n        deferred.reject(err);\n      }\n    );\n    return deferred.promise;\n  }\n\n  /**\n   * Set a limit and anchor it to the start of the window.\n   * @param {!number} limit\n   * @return {!Query}\n   */\n  limitToFirst(limit: number): Query {\n    validateArgCount('Query.limitToFirst', 1, 1, arguments.length);\n    if (\n      typeof limit !== 'number' ||\n      Math.floor(limit) !== limit ||\n      limit <= 0\n    ) {\n      throw new Error(\n        'Query.limitToFirst: First argument must be a positive integer.'\n      );\n    }\n    if (this.queryParams_.hasLimit()) {\n      throw new Error(\n        'Query.limitToFirst: Limit was already set (by another call to limit, ' +\n          'limitToFirst, or limitToLast).'\n      );\n    }\n\n    return new Query(\n      this.repo,\n      this.path,\n      this.queryParams_.limitToFirst(limit),\n      this.orderByCalled_\n    );\n  }\n\n  /**\n   * Set a limit and anchor it to the end of the window.\n   * @param {!number} limit\n   * @return {!Query}\n   */\n  limitToLast(limit: number): Query {\n    validateArgCount('Query.limitToLast', 1, 1, arguments.length);\n    if (\n      typeof limit !== 'number' ||\n      Math.floor(limit) !== limit ||\n      limit <= 0\n    ) {\n      throw new Error(\n        'Query.limitToLast: First argument must be a positive integer.'\n      );\n    }\n    if (this.queryParams_.hasLimit()) {\n      throw new Error(\n        'Query.limitToLast: Limit was already set (by another call to limit, ' +\n          'limitToFirst, or limitToLast).'\n      );\n    }\n\n    return new Query(\n      this.repo,\n      this.path,\n      this.queryParams_.limitToLast(limit),\n      this.orderByCalled_\n    );\n  }\n\n  /**\n   * Given a child path, return a new query ordered by the specified grandchild path.\n   * @param {!string} path\n   * @return {!Query}\n   */\n  orderByChild(path: string): Query {\n    validateArgCount('Query.orderByChild', 1, 1, arguments.length);\n    if (path === '$key') {\n      throw new Error(\n        'Query.orderByChild: \"$key\" is invalid.  Use Query.orderByKey() instead.'\n      );\n    } else if (path === '$priority') {\n      throw new Error(\n        'Query.orderByChild: \"$priority\" is invalid.  Use Query.orderByPriority() instead.'\n      );\n    } else if (path === '$value') {\n      throw new Error(\n        'Query.orderByChild: \"$value\" is invalid.  Use Query.orderByValue() instead.'\n      );\n    }\n    validatePathString('Query.orderByChild', 1, path, false);\n    this.validateNoPreviousOrderByCall_('Query.orderByChild');\n    const parsedPath = new Path(path);\n    if (parsedPath.isEmpty()) {\n      throw new Error(\n        'Query.orderByChild: cannot pass in empty path.  Use Query.orderByValue() instead.'\n      );\n    }\n    const index = new PathIndex(parsedPath);\n    const newParams = this.queryParams_.orderBy(index);\n    Query.validateQueryEndpoints_(newParams);\n\n    return new Query(this.repo, this.path, newParams, /*orderByCalled=*/ true);\n  }\n\n  /**\n   * Return a new query ordered by the KeyIndex\n   * @return {!Query}\n   */\n  orderByKey(): Query {\n    validateArgCount('Query.orderByKey', 0, 0, arguments.length);\n    this.validateNoPreviousOrderByCall_('Query.orderByKey');\n    const newParams = this.queryParams_.orderBy(KEY_INDEX);\n    Query.validateQueryEndpoints_(newParams);\n    return new Query(this.repo, this.path, newParams, /*orderByCalled=*/ true);\n  }\n\n  /**\n   * Return a new query ordered by the PriorityIndex\n   * @return {!Query}\n   */\n  orderByPriority(): Query {\n    validateArgCount('Query.orderByPriority', 0, 0, arguments.length);\n    this.validateNoPreviousOrderByCall_('Query.orderByPriority');\n    const newParams = this.queryParams_.orderBy(PRIORITY_INDEX);\n    Query.validateQueryEndpoints_(newParams);\n    return new Query(this.repo, this.path, newParams, /*orderByCalled=*/ true);\n  }\n\n  /**\n   * Return a new query ordered by the ValueIndex\n   * @return {!Query}\n   */\n  orderByValue(): Query {\n    validateArgCount('Query.orderByValue', 0, 0, arguments.length);\n    this.validateNoPreviousOrderByCall_('Query.orderByValue');\n    const newParams = this.queryParams_.orderBy(VALUE_INDEX);\n    Query.validateQueryEndpoints_(newParams);\n    return new Query(this.repo, this.path, newParams, /*orderByCalled=*/ true);\n  }\n\n  /**\n   * @param {number|string|boolean|null} value\n   * @param {?string=} name\n   * @return {!Query}\n   */\n  startAt(\n    value: number | string | boolean | null = null,\n    name?: string | null\n  ): Query {\n    validateArgCount('Query.startAt', 0, 2, arguments.length);\n    validateFirebaseDataArg('Query.startAt', 1, value, this.path, true);\n    validateKey('Query.startAt', 2, name, true);\n\n    const newParams = this.queryParams_.startAt(value, name);\n    Query.validateLimit_(newParams);\n    Query.validateQueryEndpoints_(newParams);\n    if (this.queryParams_.hasStart()) {\n      throw new Error(\n        'Query.startAt: Starting point was already set (by another call to startAt ' +\n          'or equalTo).'\n      );\n    }\n\n    // Calling with no params tells us to start at the beginning.\n    if (value === undefined) {\n      value = null;\n      name = null;\n    }\n    return new Query(this.repo, this.path, newParams, this.orderByCalled_);\n  }\n\n  /**\n   * @param {number|string|boolean|null} value\n   * @param {?string=} name\n   * @return {!Query}\n   */\n  endAt(\n    value: number | string | boolean | null = null,\n    name?: string | null\n  ): Query {\n    validateArgCount('Query.endAt', 0, 2, arguments.length);\n    validateFirebaseDataArg('Query.endAt', 1, value, this.path, true);\n    validateKey('Query.endAt', 2, name, true);\n\n    const newParams = this.queryParams_.endAt(value, name);\n    Query.validateLimit_(newParams);\n    Query.validateQueryEndpoints_(newParams);\n    if (this.queryParams_.hasEnd()) {\n      throw new Error(\n        'Query.endAt: Ending point was already set (by another call to endAt or ' +\n          'equalTo).'\n      );\n    }\n\n    return new Query(this.repo, this.path, newParams, this.orderByCalled_);\n  }\n\n  /**\n   * Load the selection of children with exactly the specified value, and, optionally,\n   * the specified name.\n   * @param {number|string|boolean|null} value\n   * @param {string=} name\n   * @return {!Query}\n   */\n  equalTo(value: number | string | boolean | null, name?: string) {\n    validateArgCount('Query.equalTo', 1, 2, arguments.length);\n    validateFirebaseDataArg('Query.equalTo', 1, value, this.path, false);\n    validateKey('Query.equalTo', 2, name, true);\n    if (this.queryParams_.hasStart()) {\n      throw new Error(\n        'Query.equalTo: Starting point was already set (by another call to startAt or ' +\n          'equalTo).'\n      );\n    }\n    if (this.queryParams_.hasEnd()) {\n      throw new Error(\n        'Query.equalTo: Ending point was already set (by another call to endAt or ' +\n          'equalTo).'\n      );\n    }\n    return this.startAt(value, name).endAt(value, name);\n  }\n\n  /**\n   * @return {!string} URL for this location.\n   */\n  toString(): string {\n    validateArgCount('Query.toString', 0, 0, arguments.length);\n\n    return this.repo.toString() + this.path.toUrlEncodedString();\n  }\n\n  // Do not create public documentation. This is intended to make JSON serialization work but is otherwise unnecessary\n  // for end-users.\n  toJSON() {\n    // An optional spacer argument is unnecessary for a string.\n    validateArgCount('Query.toJSON', 0, 1, arguments.length);\n    return this.toString();\n  }\n\n  /**\n   * An object representation of the query parameters used by this Query.\n   * @return {!Object}\n   */\n  queryObject(): Object {\n    return this.queryParams_.getQueryObject();\n  }\n\n  /**\n   * @return {!string}\n   */\n  queryIdentifier(): string {\n    const obj = this.queryObject();\n    const id = ObjectToUniqueKey(obj);\n    return id === '{}' ? 'default' : id;\n  }\n\n  /**\n   * Return true if this query and the provided query are equivalent; otherwise, return false.\n   * @param {Query} other\n   * @return {boolean}\n   */\n  isEqual(other: Query): boolean {\n    validateArgCount('Query.isEqual', 1, 1, arguments.length);\n    if (!(other instanceof Query)) {\n      const error =\n        'Query.isEqual failed: First argument must be an instance of firebase.database.Query.';\n      throw new Error(error);\n    }\n\n    const sameRepo = this.repo === other.repo;\n    const samePath = this.path.equals(other.path);\n    const sameQueryIdentifier =\n      this.queryIdentifier() === other.queryIdentifier();\n\n    return sameRepo && samePath && sameQueryIdentifier;\n  }\n\n  /**\n   * Helper used by .on and .once to extract the context and or cancel arguments.\n   * @param {!string} fnName The function name (on or once)\n   * @param {(function(Error)|Object)=} cancelOrContext\n   * @param {Object=} context\n   * @return {{cancel: ?function(Error), context: ?Object}}\n   * @private\n   */\n  private static getCancelAndContextArgs_(\n    fnName: string,\n    cancelOrContext?: ((a: Error) => void) | Object,\n    context?: Object\n  ): { cancel: ((a: Error) => void) | null; context: Object | null } {\n    const ret: {\n      cancel: ((a: Error) => void) | null;\n      context: Object | null;\n    } = { cancel: null, context: null };\n    if (cancelOrContext && context) {\n      ret.cancel = cancelOrContext as (a: Error) => void;\n      validateCallback(fnName, 3, ret.cancel, true);\n\n      ret.context = context;\n      validateContextObject(fnName, 4, ret.context, true);\n    } else if (cancelOrContext) {\n      // we have either a cancel callback or a context.\n      if (typeof cancelOrContext === 'object' && cancelOrContext !== null) {\n        // it's a context!\n        ret.context = cancelOrContext;\n      } else if (typeof cancelOrContext === 'function') {\n        ret.cancel = cancelOrContext;\n      } else {\n        throw new Error(\n          errorPrefix(fnName, 3, true) +\n            ' must either be a cancel callback or a context object.'\n        );\n      }\n    }\n    return ret;\n  }\n\n  get ref(): Reference {\n    return this.getRef();\n  }\n}\n","/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\nimport { assert } from '../../utils/assert';\nimport { KEY_INDEX } from '../core/snap/indexes/KeyIndex';\nimport { PRIORITY_INDEX } from '../core/snap/indexes/PriorityIndex';\nimport { VALUE_INDEX } from '../core/snap/indexes/ValueIndex';\nimport { PathIndex } from '../core/snap/indexes/PathIndex';\nimport { MIN_NAME, MAX_NAME, ObjectToUniqueKey } from '../core/util/util';\nimport { Path } from '../core/util/Path';\nimport { isValidPriority, validateEventType, validatePathString, validateFirebaseDataArg, validateKey } from '../core/util/validation';\nimport { errorPrefix, validateArgCount, validateCallback, validateContextObject } from '../../utils/validation';\nimport { ValueEventRegistration, ChildEventRegistration } from '../core/view/EventRegistration';\nimport { Deferred, attachDummyErrorHandler } from '../../utils/promise';\nvar __referenceConstructor;\n/**\n * A Query represents a filter to be applied to a firebase location.  This object purely represents the\n * query expression (and exposes our public API to build the query).  The actual query logic is in ViewBase.js.\n *\n * Since every Firebase reference is a query, Firebase inherits from this object.\n */\nvar Query = (function () {\n    function Query(repo, path, queryParams_, orderByCalled_) {\n        this.repo = repo;\n        this.path = path;\n        this.queryParams_ = queryParams_;\n        this.orderByCalled_ = orderByCalled_;\n    }\n    Object.defineProperty(Query, \"__referenceConstructor\", {\n        get: function () {\n            assert(__referenceConstructor, 'Reference.ts has not been loaded');\n            return __referenceConstructor;\n        },\n        set: function (val) {\n            __referenceConstructor = val;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Validates start/end values for queries.\n     * @param {!QueryParams} params\n     * @private\n     */\n    Query.validateQueryEndpoints_ = function (params) {\n        var startNode = null;\n        var endNode = null;\n        if (params.hasStart()) {\n            startNode = params.getIndexStartValue();\n        }\n        if (params.hasEnd()) {\n            endNode = params.getIndexEndValue();\n        }\n        if (params.getIndex() === KEY_INDEX) {\n            var tooManyArgsError = 'Query: When ordering by key, you may only pass one argument to ' +\n                'startAt(), endAt(), or equalTo().';\n            var wrongArgTypeError = 'Query: When ordering by key, the argument passed to startAt(), endAt(),' +\n                'or equalTo() must be a string.';\n            if (params.hasStart()) {\n                var startName = params.getIndexStartName();\n                if (startName != MIN_NAME) {\n                    throw new Error(tooManyArgsError);\n                }\n                else if (typeof startNode !== 'string') {\n                    throw new Error(wrongArgTypeError);\n                }\n            }\n            if (params.hasEnd()) {\n                var endName = params.getIndexEndName();\n                if (endName != MAX_NAME) {\n                    throw new Error(tooManyArgsError);\n                }\n                else if (typeof endNode !== 'string') {\n                    throw new Error(wrongArgTypeError);\n                }\n            }\n        }\n        else if (params.getIndex() === PRIORITY_INDEX) {\n            if ((startNode != null && !isValidPriority(startNode)) ||\n                (endNode != null && !isValidPriority(endNode))) {\n                throw new Error('Query: When ordering by priority, the first argument passed to startAt(), ' +\n                    'endAt(), or equalTo() must be a valid priority value (null, a number, or a string).');\n            }\n        }\n        else {\n            assert(params.getIndex() instanceof PathIndex ||\n                params.getIndex() === VALUE_INDEX, 'unknown index type.');\n            if ((startNode != null && typeof startNode === 'object') ||\n                (endNode != null && typeof endNode === 'object')) {\n                throw new Error('Query: First argument passed to startAt(), endAt(), or equalTo() cannot be ' +\n                    'an object.');\n            }\n        }\n    };\n    /**\n     * Validates that limit* has been called with the correct combination of parameters\n     * @param {!QueryParams} params\n     * @private\n     */\n    Query.validateLimit_ = function (params) {\n        if (params.hasStart() &&\n            params.hasEnd() &&\n            params.hasLimit() &&\n            !params.hasAnchoredLimit()) {\n            throw new Error(\"Query: Can't combine startAt(), endAt(), and limit(). Use limitToFirst() or limitToLast() instead.\");\n        }\n    };\n    /**\n     * Validates that no other order by call has been made\n     * @param {!string} fnName\n     * @private\n     */\n    Query.prototype.validateNoPreviousOrderByCall_ = function (fnName) {\n        if (this.orderByCalled_ === true) {\n            throw new Error(fnName + \": You can't combine multiple orderBy calls.\");\n        }\n    };\n    /**\n     * @return {!QueryParams}\n     */\n    Query.prototype.getQueryParams = function () {\n        return this.queryParams_;\n    };\n    /**\n     * @return {!Reference}\n     */\n    Query.prototype.getRef = function () {\n        validateArgCount('Query.ref', 0, 0, arguments.length);\n        // This is a slight hack. We cannot goog.require('fb.api.Firebase'), since Firebase requires fb.api.Query.\n        // However, we will always export 'Firebase' to the global namespace, so it's guaranteed to exist by the time this\n        // method gets called.\n        return new Query.__referenceConstructor(this.repo, this.path);\n    };\n    /**\n     * @param {!string} eventType\n     * @param {!function(DataSnapshot, string=)} callback\n     * @param {(function(Error)|Object)=} cancelCallbackOrContext\n     * @param {Object=} context\n     * @return {!function(DataSnapshot, string=)}\n     */\n    Query.prototype.on = function (eventType, callback, cancelCallbackOrContext, context) {\n        validateArgCount('Query.on', 2, 4, arguments.length);\n        validateEventType('Query.on', 1, eventType, false);\n        validateCallback('Query.on', 2, callback, false);\n        var ret = Query.getCancelAndContextArgs_('Query.on', cancelCallbackOrContext, context);\n        if (eventType === 'value') {\n            this.onValueEvent(callback, ret.cancel, ret.context);\n        }\n        else {\n            var callbacks = {};\n            callbacks[eventType] = callback;\n            this.onChildEvent(callbacks, ret.cancel, ret.context);\n        }\n        return callback;\n    };\n    /**\n     * @param {!function(!DataSnapshot)} callback\n     * @param {?function(Error)} cancelCallback\n     * @param {?Object} context\n     * @protected\n     */\n    Query.prototype.onValueEvent = function (callback, cancelCallback, context) {\n        var container = new ValueEventRegistration(callback, cancelCallback || null, context || null);\n        this.repo.addEventCallbackForQuery(this, container);\n    };\n    /**\n     * @param {!Object.<string, !function(!DataSnapshot, ?string)>} callbacks\n     * @param {?function(Error)} cancelCallback\n     * @param {?Object} context\n     * @protected\n     */\n    Query.prototype.onChildEvent = function (callbacks, cancelCallback, context) {\n        var container = new ChildEventRegistration(callbacks, cancelCallback, context);\n        this.repo.addEventCallbackForQuery(this, container);\n    };\n    /**\n     * @param {string=} eventType\n     * @param {(function(!DataSnapshot, ?string=))=} callback\n     * @param {Object=} context\n     */\n    Query.prototype.off = function (eventType, callback, context) {\n        validateArgCount('Query.off', 0, 3, arguments.length);\n        validateEventType('Query.off', 1, eventType, true);\n        validateCallback('Query.off', 2, callback, true);\n        validateContextObject('Query.off', 3, context, true);\n        var container = null;\n        var callbacks = null;\n        if (eventType === 'value') {\n            var valueCallback = callback || null;\n            container = new ValueEventRegistration(valueCallback, null, context || null);\n        }\n        else if (eventType) {\n            if (callback) {\n                callbacks = {};\n                callbacks[eventType] = callback;\n            }\n            container = new ChildEventRegistration(callbacks, null, context || null);\n        }\n        this.repo.removeEventCallbackForQuery(this, container);\n    };\n    /**\n     * Attaches a listener, waits for the first event, and then removes the listener\n     * @param {!string} eventType\n     * @param {!function(!DataSnapshot, string=)} userCallback\n     * @param cancelOrContext\n     * @param context\n     * @return {!firebase.Promise}\n     */\n    Query.prototype.once = function (eventType, userCallback, cancelOrContext, context) {\n        var _this = this;\n        validateArgCount('Query.once', 1, 4, arguments.length);\n        validateEventType('Query.once', 1, eventType, false);\n        validateCallback('Query.once', 2, userCallback, true);\n        var ret = Query.getCancelAndContextArgs_('Query.once', cancelOrContext, context);\n        // TODO: Implement this more efficiently (in particular, use 'get' wire protocol for 'value' event)\n        // TODO: consider actually wiring the callbacks into the promise. We cannot do this without a breaking change\n        // because the API currently expects callbacks will be called synchronously if the data is cached, but this is\n        // against the Promise specification.\n        var firstCall = true;\n        var deferred = new Deferred();\n        attachDummyErrorHandler(deferred.promise);\n        var onceCallback = function (snapshot) {\n            // NOTE: Even though we unsubscribe, we may get called multiple times if a single action (e.g. set() with JSON)\n            // triggers multiple events (e.g. child_added or child_changed).\n            if (firstCall) {\n                firstCall = false;\n                _this.off(eventType, onceCallback);\n                if (userCallback) {\n                    userCallback.bind(ret.context)(snapshot);\n                }\n                deferred.resolve(snapshot);\n            }\n        };\n        this.on(eventType, onceCallback, \n        /*cancel=*/ function (err) {\n            _this.off(eventType, onceCallback);\n            if (ret.cancel)\n                ret.cancel.bind(ret.context)(err);\n            deferred.reject(err);\n        });\n        return deferred.promise;\n    };\n    /**\n     * Set a limit and anchor it to the start of the window.\n     * @param {!number} limit\n     * @return {!Query}\n     */\n    Query.prototype.limitToFirst = function (limit) {\n        validateArgCount('Query.limitToFirst', 1, 1, arguments.length);\n        if (typeof limit !== 'number' ||\n            Math.floor(limit) !== limit ||\n            limit <= 0) {\n            throw new Error('Query.limitToFirst: First argument must be a positive integer.');\n        }\n        if (this.queryParams_.hasLimit()) {\n            throw new Error('Query.limitToFirst: Limit was already set (by another call to limit, ' +\n                'limitToFirst, or limitToLast).');\n        }\n        return new Query(this.repo, this.path, this.queryParams_.limitToFirst(limit), this.orderByCalled_);\n    };\n    /**\n     * Set a limit and anchor it to the end of the window.\n     * @param {!number} limit\n     * @return {!Query}\n     */\n    Query.prototype.limitToLast = function (limit) {\n        validateArgCount('Query.limitToLast', 1, 1, arguments.length);\n        if (typeof limit !== 'number' ||\n            Math.floor(limit) !== limit ||\n            limit <= 0) {\n            throw new Error('Query.limitToLast: First argument must be a positive integer.');\n        }\n        if (this.queryParams_.hasLimit()) {\n            throw new Error('Query.limitToLast: Limit was already set (by another call to limit, ' +\n                'limitToFirst, or limitToLast).');\n        }\n        return new Query(this.repo, this.path, this.queryParams_.limitToLast(limit), this.orderByCalled_);\n    };\n    /**\n     * Given a child path, return a new query ordered by the specified grandchild path.\n     * @param {!string} path\n     * @return {!Query}\n     */\n    Query.prototype.orderByChild = function (path) {\n        validateArgCount('Query.orderByChild', 1, 1, arguments.length);\n        if (path === '$key') {\n            throw new Error('Query.orderByChild: \"$key\" is invalid.  Use Query.orderByKey() instead.');\n        }\n        else if (path === '$priority') {\n            throw new Error('Query.orderByChild: \"$priority\" is invalid.  Use Query.orderByPriority() instead.');\n        }\n        else if (path === '$value') {\n            throw new Error('Query.orderByChild: \"$value\" is invalid.  Use Query.orderByValue() instead.');\n        }\n        validatePathString('Query.orderByChild', 1, path, false);\n        this.validateNoPreviousOrderByCall_('Query.orderByChild');\n        var parsedPath = new Path(path);\n        if (parsedPath.isEmpty()) {\n            throw new Error('Query.orderByChild: cannot pass in empty path.  Use Query.orderByValue() instead.');\n        }\n        var index = new PathIndex(parsedPath);\n        var newParams = this.queryParams_.orderBy(index);\n        Query.validateQueryEndpoints_(newParams);\n        return new Query(this.repo, this.path, newParams, /*orderByCalled=*/ true);\n    };\n    /**\n     * Return a new query ordered by the KeyIndex\n     * @return {!Query}\n     */\n    Query.prototype.orderByKey = function () {\n        validateArgCount('Query.orderByKey', 0, 0, arguments.length);\n        this.validateNoPreviousOrderByCall_('Query.orderByKey');\n        var newParams = this.queryParams_.orderBy(KEY_INDEX);\n        Query.validateQueryEndpoints_(newParams);\n        return new Query(this.repo, this.path, newParams, /*orderByCalled=*/ true);\n    };\n    /**\n     * Return a new query ordered by the PriorityIndex\n     * @return {!Query}\n     */\n    Query.prototype.orderByPriority = function () {\n        validateArgCount('Query.orderByPriority', 0, 0, arguments.length);\n        this.validateNoPreviousOrderByCall_('Query.orderByPriority');\n        var newParams = this.queryParams_.orderBy(PRIORITY_INDEX);\n        Query.validateQueryEndpoints_(newParams);\n        return new Query(this.repo, this.path, newParams, /*orderByCalled=*/ true);\n    };\n    /**\n     * Return a new query ordered by the ValueIndex\n     * @return {!Query}\n     */\n    Query.prototype.orderByValue = function () {\n        validateArgCount('Query.orderByValue', 0, 0, arguments.length);\n        this.validateNoPreviousOrderByCall_('Query.orderByValue');\n        var newParams = this.queryParams_.orderBy(VALUE_INDEX);\n        Query.validateQueryEndpoints_(newParams);\n        return new Query(this.repo, this.path, newParams, /*orderByCalled=*/ true);\n    };\n    /**\n     * @param {number|string|boolean|null} value\n     * @param {?string=} name\n     * @return {!Query}\n     */\n    Query.prototype.startAt = function (value, name) {\n        if (value === void 0) { value = null; }\n        validateArgCount('Query.startAt', 0, 2, arguments.length);\n        validateFirebaseDataArg('Query.startAt', 1, value, this.path, true);\n        validateKey('Query.startAt', 2, name, true);\n        var newParams = this.queryParams_.startAt(value, name);\n        Query.validateLimit_(newParams);\n        Query.validateQueryEndpoints_(newParams);\n        if (this.queryParams_.hasStart()) {\n            throw new Error('Query.startAt: Starting point was already set (by another call to startAt ' +\n                'or equalTo).');\n        }\n        // Calling with no params tells us to start at the beginning.\n        if (value === undefined) {\n            value = null;\n            name = null;\n        }\n        return new Query(this.repo, this.path, newParams, this.orderByCalled_);\n    };\n    /**\n     * @param {number|string|boolean|null} value\n     * @param {?string=} name\n     * @return {!Query}\n     */\n    Query.prototype.endAt = function (value, name) {\n        if (value === void 0) { value = null; }\n        validateArgCount('Query.endAt', 0, 2, arguments.length);\n        validateFirebaseDataArg('Query.endAt', 1, value, this.path, true);\n        validateKey('Query.endAt', 2, name, true);\n        var newParams = this.queryParams_.endAt(value, name);\n        Query.validateLimit_(newParams);\n        Query.validateQueryEndpoints_(newParams);\n        if (this.queryParams_.hasEnd()) {\n            throw new Error('Query.endAt: Ending point was already set (by another call to endAt or ' +\n                'equalTo).');\n        }\n        return new Query(this.repo, this.path, newParams, this.orderByCalled_);\n    };\n    /**\n     * Load the selection of children with exactly the specified value, and, optionally,\n     * the specified name.\n     * @param {number|string|boolean|null} value\n     * @param {string=} name\n     * @return {!Query}\n     */\n    Query.prototype.equalTo = function (value, name) {\n        validateArgCount('Query.equalTo', 1, 2, arguments.length);\n        validateFirebaseDataArg('Query.equalTo', 1, value, this.path, false);\n        validateKey('Query.equalTo', 2, name, true);\n        if (this.queryParams_.hasStart()) {\n            throw new Error('Query.equalTo: Starting point was already set (by another call to startAt or ' +\n                'equalTo).');\n        }\n        if (this.queryParams_.hasEnd()) {\n            throw new Error('Query.equalTo: Ending point was already set (by another call to endAt or ' +\n                'equalTo).');\n        }\n        return this.startAt(value, name).endAt(value, name);\n    };\n    /**\n     * @return {!string} URL for this location.\n     */\n    Query.prototype.toString = function () {\n        validateArgCount('Query.toString', 0, 0, arguments.length);\n        return this.repo.toString() + this.path.toUrlEncodedString();\n    };\n    // Do not create public documentation. This is intended to make JSON serialization work but is otherwise unnecessary\n    // for end-users.\n    Query.prototype.toJSON = function () {\n        // An optional spacer argument is unnecessary for a string.\n        validateArgCount('Query.toJSON', 0, 1, arguments.length);\n        return this.toString();\n    };\n    /**\n     * An object representation of the query parameters used by this Query.\n     * @return {!Object}\n     */\n    Query.prototype.queryObject = function () {\n        return this.queryParams_.getQueryObject();\n    };\n    /**\n     * @return {!string}\n     */\n    Query.prototype.queryIdentifier = function () {\n        var obj = this.queryObject();\n        var id = ObjectToUniqueKey(obj);\n        return id === '{}' ? 'default' : id;\n    };\n    /**\n     * Return true if this query and the provided query are equivalent; otherwise, return false.\n     * @param {Query} other\n     * @return {boolean}\n     */\n    Query.prototype.isEqual = function (other) {\n        validateArgCount('Query.isEqual', 1, 1, arguments.length);\n        if (!(other instanceof Query)) {\n            var error = 'Query.isEqual failed: First argument must be an instance of firebase.database.Query.';\n            throw new Error(error);\n        }\n        var sameRepo = this.repo === other.repo;\n        var samePath = this.path.equals(other.path);\n        var sameQueryIdentifier = this.queryIdentifier() === other.queryIdentifier();\n        return sameRepo && samePath && sameQueryIdentifier;\n    };\n    /**\n     * Helper used by .on and .once to extract the context and or cancel arguments.\n     * @param {!string} fnName The function name (on or once)\n     * @param {(function(Error)|Object)=} cancelOrContext\n     * @param {Object=} context\n     * @return {{cancel: ?function(Error), context: ?Object}}\n     * @private\n     */\n    Query.getCancelAndContextArgs_ = function (fnName, cancelOrContext, context) {\n        var ret = { cancel: null, context: null };\n        if (cancelOrContext && context) {\n            ret.cancel = cancelOrContext;\n            validateCallback(fnName, 3, ret.cancel, true);\n            ret.context = context;\n            validateContextObject(fnName, 4, ret.context, true);\n        }\n        else if (cancelOrContext) {\n            // we have either a cancel callback or a context.\n            if (typeof cancelOrContext === 'object' && cancelOrContext !== null) {\n                // it's a context!\n                ret.context = cancelOrContext;\n            }\n            else if (typeof cancelOrContext === 'function') {\n                ret.cancel = cancelOrContext;\n            }\n            else {\n                throw new Error(errorPrefix(fnName, 3, true) +\n                    ' must either be a cancel callback or a context object.');\n            }\n        }\n        return ret;\n    };\n    Object.defineProperty(Query.prototype, \"ref\", {\n        get: function () {\n            return this.getRef();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return Query;\n}());\nexport { Query };\n\n\n"]}