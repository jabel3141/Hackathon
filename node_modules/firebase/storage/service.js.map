{"version":3,"sources":["../src/storage/service.ts","storage/service.js"],"names":["args","fbsPromiseImpl","RequestExports","Service","app","pool","url","bucket_","maker","authWrapper","loc","authWrapper_","makeRequest","app_","makeFromBucketSpec","authWrapperBucket","bucket","internals_","ServiceInternals","prototype","ref","path","validator","test","validate","stringSpec","arguments","Error","child","refFromURL","p","makeFromUrl","e","Object","defineProperty","get","maxUploadRetryTime","enumerable","configurable","setMaxUploadRetryTime","time","nonNegativeNumberSpec","maxOperationRetryTime","setMaxOperationRetryTime","service","service_","delete","deleteApp","resolve","undefined"],"mappings":"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","file":"service.js","sourcesContent":["/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\nimport * as args from './implementation/args';\nimport { AuthWrapper } from './implementation/authwrapper';\nimport { Location } from './implementation/location';\nimport * as fbsPromiseImpl from './implementation/promise_external';\nimport * as RequestExports from './implementation/request';\nimport { Request } from './implementation/request';\nimport { XhrIoPool } from './implementation/xhriopool';\nimport { Reference } from './reference';\nimport { FirebaseApp } from '../app/firebase_app';\n\n/**\n * A service that provides firebaseStorage.Reference instances.\n * @param opt_url gs:// url to a custom Storage Bucket\n *\n * @struct\n */\nexport class Service {\n  authWrapper_: AuthWrapper;\n  private app_: FirebaseApp;\n  private bucket_: Location | null = null;\n  private internals_: ServiceInternals;\n\n  constructor(app: FirebaseApp, pool: XhrIoPool, url?: string) {\n    function maker(authWrapper: AuthWrapper, loc: Location) {\n      return new Reference(authWrapper, loc);\n    }\n    this.authWrapper_ = new AuthWrapper(\n      app,\n      maker,\n      RequestExports.makeRequest,\n      this,\n      pool\n    );\n    this.app_ = app;\n    if (url != null) {\n      this.bucket_ = Location.makeFromBucketSpec(url);\n    } else {\n      const authWrapperBucket = this.authWrapper_.bucket();\n      if (authWrapperBucket != null) {\n        this.bucket_ = new Location(authWrapperBucket, '');\n      }\n    }\n    this.internals_ = new ServiceInternals(this);\n  }\n\n  /**\n   * Returns a firebaseStorage.Reference for the given path in the default\n   * bucket.\n   */\n  ref(path?: string): Reference {\n    function validator(path: string) {\n      if (/^[A-Za-z]+:\\/\\//.test(path)) {\n        throw 'Expected child path but got a URL, use refFromURL instead.';\n      }\n    }\n    args.validate('ref', [args.stringSpec(validator, true)], arguments);\n    if (this.bucket_ == null) {\n      throw new Error('No Storage Bucket defined in Firebase Options.');\n    }\n\n    let ref = new Reference(this.authWrapper_, this.bucket_);\n    if (path != null) {\n      return ref.child(path);\n    } else {\n      return ref;\n    }\n  }\n\n  /**\n   * Returns a firebaseStorage.Reference object for the given absolute URL,\n   * which must be a gs:// or http[s]:// URL.\n   */\n  refFromURL(url: string): Reference {\n    function validator(p: string) {\n      if (!/^[A-Za-z]+:\\/\\//.test(p)) {\n        throw 'Expected full URL but got a child path, use ref instead.';\n      }\n      try {\n        Location.makeFromUrl(p);\n      } catch (e) {\n        throw 'Expected valid full URL but got an invalid one.';\n      }\n    }\n    args.validate('refFromURL', [args.stringSpec(validator, false)], arguments);\n    return new Reference(this.authWrapper_, url);\n  }\n\n  get maxUploadRetryTime(): number {\n    return this.authWrapper_.maxUploadRetryTime();\n  }\n\n  setMaxUploadRetryTime(time: number) {\n    args.validate(\n      'setMaxUploadRetryTime',\n      [args.nonNegativeNumberSpec()],\n      arguments\n    );\n    this.authWrapper_.setMaxUploadRetryTime(time);\n  }\n\n  get maxOperationRetryTime(): number {\n    return this.authWrapper_.maxOperationRetryTime();\n  }\n\n  setMaxOperationRetryTime(time: number) {\n    args.validate(\n      'setMaxOperationRetryTime',\n      [args.nonNegativeNumberSpec()],\n      arguments\n    );\n    this.authWrapper_.setMaxOperationRetryTime(time);\n  }\n\n  get app(): FirebaseApp {\n    return this.app_;\n  }\n\n  get INTERNAL(): ServiceInternals {\n    return this.internals_;\n  }\n}\n\n/**\n * @struct\n */\nexport class ServiceInternals {\n  service_: Service;\n\n  constructor(service: Service) {\n    this.service_ = service;\n  }\n\n  /**\n   * Called when the associated app is deleted.\n   * @see {!fbs.AuthWrapper.prototype.deleteApp}\n   */\n  delete(): Promise<void> {\n    this.service_.authWrapper_.deleteApp();\n    return fbsPromiseImpl.resolve<void>(undefined);\n  }\n}\n","/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\nimport * as args from './implementation/args';\nimport { AuthWrapper } from './implementation/authwrapper';\nimport { Location } from './implementation/location';\nimport * as fbsPromiseImpl from './implementation/promise_external';\nimport * as RequestExports from './implementation/request';\nimport { Reference } from './reference';\n/**\n * A service that provides firebaseStorage.Reference instances.\n * @param opt_url gs:// url to a custom Storage Bucket\n *\n * @struct\n */\nvar Service = (function () {\n    function Service(app, pool, url) {\n        this.bucket_ = null;\n        function maker(authWrapper, loc) {\n            return new Reference(authWrapper, loc);\n        }\n        this.authWrapper_ = new AuthWrapper(app, maker, RequestExports.makeRequest, this, pool);\n        this.app_ = app;\n        if (url != null) {\n            this.bucket_ = Location.makeFromBucketSpec(url);\n        }\n        else {\n            var authWrapperBucket = this.authWrapper_.bucket();\n            if (authWrapperBucket != null) {\n                this.bucket_ = new Location(authWrapperBucket, '');\n            }\n        }\n        this.internals_ = new ServiceInternals(this);\n    }\n    /**\n     * Returns a firebaseStorage.Reference for the given path in the default\n     * bucket.\n     */\n    Service.prototype.ref = function (path) {\n        function validator(path) {\n            if (/^[A-Za-z]+:\\/\\//.test(path)) {\n                throw 'Expected child path but got a URL, use refFromURL instead.';\n            }\n        }\n        args.validate('ref', [args.stringSpec(validator, true)], arguments);\n        if (this.bucket_ == null) {\n            throw new Error('No Storage Bucket defined in Firebase Options.');\n        }\n        var ref = new Reference(this.authWrapper_, this.bucket_);\n        if (path != null) {\n            return ref.child(path);\n        }\n        else {\n            return ref;\n        }\n    };\n    /**\n     * Returns a firebaseStorage.Reference object for the given absolute URL,\n     * which must be a gs:// or http[s]:// URL.\n     */\n    Service.prototype.refFromURL = function (url) {\n        function validator(p) {\n            if (!/^[A-Za-z]+:\\/\\//.test(p)) {\n                throw 'Expected full URL but got a child path, use ref instead.';\n            }\n            try {\n                Location.makeFromUrl(p);\n            }\n            catch (e) {\n                throw 'Expected valid full URL but got an invalid one.';\n            }\n        }\n        args.validate('refFromURL', [args.stringSpec(validator, false)], arguments);\n        return new Reference(this.authWrapper_, url);\n    };\n    Object.defineProperty(Service.prototype, \"maxUploadRetryTime\", {\n        get: function () {\n            return this.authWrapper_.maxUploadRetryTime();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Service.prototype.setMaxUploadRetryTime = function (time) {\n        args.validate('setMaxUploadRetryTime', [args.nonNegativeNumberSpec()], arguments);\n        this.authWrapper_.setMaxUploadRetryTime(time);\n    };\n    Object.defineProperty(Service.prototype, \"maxOperationRetryTime\", {\n        get: function () {\n            return this.authWrapper_.maxOperationRetryTime();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Service.prototype.setMaxOperationRetryTime = function (time) {\n        args.validate('setMaxOperationRetryTime', [args.nonNegativeNumberSpec()], arguments);\n        this.authWrapper_.setMaxOperationRetryTime(time);\n    };\n    Object.defineProperty(Service.prototype, \"app\", {\n        get: function () {\n            return this.app_;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Service.prototype, \"INTERNAL\", {\n        get: function () {\n            return this.internals_;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return Service;\n}());\nexport { Service };\n/**\n * @struct\n */\nvar ServiceInternals = (function () {\n    function ServiceInternals(service) {\n        this.service_ = service;\n    }\n    /**\n     * Called when the associated app is deleted.\n     * @see {!fbs.AuthWrapper.prototype.deleteApp}\n     */\n    ServiceInternals.prototype.delete = function () {\n        this.service_.authWrapper_.deleteApp();\n        return fbsPromiseImpl.resolve(undefined);\n    };\n    return ServiceInternals;\n}());\nexport { ServiceInternals };\n\n\n"]}