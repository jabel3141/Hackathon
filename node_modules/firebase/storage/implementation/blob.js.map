{"version":3,"sources":["src/storage/implementation/blob.ts","storage/implementation/blob.js"],"names":["fs","string","type","FbsBlob","data","opt_elideCopy","size","blobType","isNativeBlob","data_","ArrayBuffer","Uint8Array","byteLength","set","length","size_","type_","prototype","slice","startByte","endByte","realBlob","sliced","sliceBlob","buffer","getBlob","var_args","_i","arguments","isNativeBlobDefined","blobby","map","val","apply","uint8Arrays","isString","dataFromString","RAW","finalLength_1","forEach","array","merged_1","index_1","i","uploadData"],"mappings":"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","file":"blob.js","sourcesContent":["/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/**\n * @file Provides a Blob-like wrapper for various binary types (including the\n * native Blob type). This makes it possible to upload types like ArrayBuffers,\n * making uploads possible in environments without the native Blob type.\n */\nimport * as fs from './fs';\nimport * as string from './string';\nimport { StringFormat } from './string';\nimport * as type from './type';\n\n/**\n * @param opt_elideCopy If true, doesn't copy mutable input data\n *     (e.g. Uint8Arrays). Pass true only if you know the objects will not be\n *     modified after this blob's construction.\n */\nexport class FbsBlob {\n  private data_: Blob | Uint8Array;\n  private size_: number;\n  private type_: string;\n\n  constructor(data: Blob | Uint8Array | ArrayBuffer, opt_elideCopy?: boolean) {\n    let size: number = 0;\n    let blobType: string = '';\n    if (type.isNativeBlob(data)) {\n      this.data_ = data as Blob;\n      size = (data as Blob).size;\n      blobType = (data as Blob).type;\n    } else if (data instanceof ArrayBuffer) {\n      if (opt_elideCopy) {\n        this.data_ = new Uint8Array(data);\n      } else {\n        this.data_ = new Uint8Array(data.byteLength);\n        this.data_.set(new Uint8Array(data));\n      }\n      size = this.data_.length;\n    } else if (data instanceof Uint8Array) {\n      if (opt_elideCopy) {\n        this.data_ = data as Uint8Array;\n      } else {\n        this.data_ = new Uint8Array(data.length);\n        this.data_.set(data as Uint8Array);\n      }\n      size = data.length;\n    }\n    this.size_ = size;\n    this.type_ = blobType;\n  }\n\n  size(): number {\n    return this.size_;\n  }\n\n  type(): string {\n    return this.type_;\n  }\n\n  slice(startByte: number, endByte: number): FbsBlob | null {\n    if (type.isNativeBlob(this.data_)) {\n      let realBlob = this.data_ as Blob;\n      let sliced = fs.sliceBlob(realBlob, startByte, endByte);\n      if (sliced === null) {\n        return null;\n      }\n      return new FbsBlob(sliced);\n    } else {\n      let slice = new Uint8Array(\n        (this.data_ as Uint8Array).buffer,\n        startByte,\n        endByte - startByte\n      );\n      return new FbsBlob(slice, true);\n    }\n  }\n\n  static getBlob(...var_args: (string | FbsBlob)[]): FbsBlob | null {\n    if (type.isNativeBlobDefined()) {\n      var blobby: (Blob | Uint8Array | string)[] = var_args.map(function(\n        val: string | FbsBlob\n      ): Blob | Uint8Array | string {\n        if (val instanceof FbsBlob) {\n          return val.data_;\n        } else {\n          return val;\n        }\n      });\n      return new FbsBlob(fs.getBlob.apply(null, blobby));\n    } else {\n      let uint8Arrays: Uint8Array[] = var_args.map(function(\n        val: string | FbsBlob\n      ): Uint8Array {\n        if (type.isString(val)) {\n          return string.dataFromString(StringFormat.RAW, val as string).data;\n        } else {\n          // Blobs don't exist, so this has to be a Uint8Array.\n          return (val as FbsBlob).data_ as Uint8Array;\n        }\n      });\n      let finalLength = 0;\n      uint8Arrays.forEach(function(array: Uint8Array): void {\n        finalLength += array.byteLength;\n      });\n      let merged = new Uint8Array(finalLength);\n      let index = 0;\n      uint8Arrays.forEach(function(array: Uint8Array) {\n        for (let i = 0; i < array.length; i++) {\n          merged[index++] = array[i];\n        }\n      });\n      return new FbsBlob(merged, true);\n    }\n  }\n\n  uploadData(): Blob | Uint8Array {\n    return this.data_;\n  }\n}\n","/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n/**\n * @file Provides a Blob-like wrapper for various binary types (including the\n * native Blob type). This makes it possible to upload types like ArrayBuffers,\n * making uploads possible in environments without the native Blob type.\n */\nimport * as fs from './fs';\nimport * as string from './string';\nimport { StringFormat } from './string';\nimport * as type from './type';\n/**\n * @param opt_elideCopy If true, doesn't copy mutable input data\n *     (e.g. Uint8Arrays). Pass true only if you know the objects will not be\n *     modified after this blob's construction.\n */\nvar FbsBlob = (function () {\n    function FbsBlob(data, opt_elideCopy) {\n        var size = 0;\n        var blobType = '';\n        if (type.isNativeBlob(data)) {\n            this.data_ = data;\n            size = data.size;\n            blobType = data.type;\n        }\n        else if (data instanceof ArrayBuffer) {\n            if (opt_elideCopy) {\n                this.data_ = new Uint8Array(data);\n            }\n            else {\n                this.data_ = new Uint8Array(data.byteLength);\n                this.data_.set(new Uint8Array(data));\n            }\n            size = this.data_.length;\n        }\n        else if (data instanceof Uint8Array) {\n            if (opt_elideCopy) {\n                this.data_ = data;\n            }\n            else {\n                this.data_ = new Uint8Array(data.length);\n                this.data_.set(data);\n            }\n            size = data.length;\n        }\n        this.size_ = size;\n        this.type_ = blobType;\n    }\n    FbsBlob.prototype.size = function () {\n        return this.size_;\n    };\n    FbsBlob.prototype.type = function () {\n        return this.type_;\n    };\n    FbsBlob.prototype.slice = function (startByte, endByte) {\n        if (type.isNativeBlob(this.data_)) {\n            var realBlob = this.data_;\n            var sliced = fs.sliceBlob(realBlob, startByte, endByte);\n            if (sliced === null) {\n                return null;\n            }\n            return new FbsBlob(sliced);\n        }\n        else {\n            var slice = new Uint8Array(this.data_.buffer, startByte, endByte - startByte);\n            return new FbsBlob(slice, true);\n        }\n    };\n    FbsBlob.getBlob = function () {\n        var var_args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            var_args[_i] = arguments[_i];\n        }\n        if (type.isNativeBlobDefined()) {\n            var blobby = var_args.map(function (val) {\n                if (val instanceof FbsBlob) {\n                    return val.data_;\n                }\n                else {\n                    return val;\n                }\n            });\n            return new FbsBlob(fs.getBlob.apply(null, blobby));\n        }\n        else {\n            var uint8Arrays = var_args.map(function (val) {\n                if (type.isString(val)) {\n                    return string.dataFromString(StringFormat.RAW, val).data;\n                }\n                else {\n                    // Blobs don't exist, so this has to be a Uint8Array.\n                    return val.data_;\n                }\n            });\n            var finalLength_1 = 0;\n            uint8Arrays.forEach(function (array) {\n                finalLength_1 += array.byteLength;\n            });\n            var merged_1 = new Uint8Array(finalLength_1);\n            var index_1 = 0;\n            uint8Arrays.forEach(function (array) {\n                for (var i = 0; i < array.length; i++) {\n                    merged_1[index_1++] = array[i];\n                }\n            });\n            return new FbsBlob(merged_1, true);\n        }\n    };\n    FbsBlob.prototype.uploadData = function () {\n        return this.data_;\n    };\n    return FbsBlob;\n}());\nexport { FbsBlob };\n\n\n"]}