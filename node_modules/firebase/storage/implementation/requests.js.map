{"version":3,"sources":["src/storage/implementation/requests.ts","storage/implementation/requests.js"],"names":["handlerCheck","metadataHandler","sharedErrorHandler","objectErrorHandler","getMetadata","updateMetadata","deleteObject","determineContentType_","metadataForUpload_","multipartUpload","checkResumeHeader_","createResumableUpload","getResumableUploadStatus","continueResumableUpload","array","errorsExports","MetadataUtils","object","type","UrlUtils","cndn","unknown","authWrapper","mappings","handler","xhr","text","metadata","fromResourceString","location","errorHandler","err","newErr","getStatus","unauthenticated","quotaExceeded","bucket","unauthorized","path","setServerResponseProp","serverResponseProp","shared","objectNotFound","urlPart","fullServerUrl","url","makeNormalUrl","method","timeout","maxOperationRetryTime","requestInfo","body","toResourceString","headers","successCodes","blob","opt_metadata","clone","size","bucketOnlyServerUrl","genBoundary","str","i","Math","random","toString","slice","boundary","metadataString","preBlobPart","postBlobPart","getBlob","cannotSliceBlob","urlParams","name","makeUploadUrl","maxUploadRetryTime","uploadData","ResumableUploadStatus","current","total","finalized","opt_allowed","status","getResponseHeader","e","allowed","contains","isString","sizeString","parseInt","isNaN","resumableUploadChunkSize","chunkSize","opt_status","opt_progressCallback","serverFileWrongSize","bytesLeft","bytesToUpload","min","startByte","endByte","uploadCommand","uploadStatus","newCurrent","progressCallback"],"mappings":"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","file":"requests.js","sourcesContent":["/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/**\n * @fileoverview Defines methods for interacting with the network.\n */\n\nimport { Metadata } from '../metadata';\n\nimport * as array from './array';\nimport { AuthWrapper } from './authwrapper';\nimport { FbsBlob } from './blob';\nimport * as errorsExports from './error';\nimport { FirebaseStorageError } from './error';\nimport { errors } from './error';\nimport { Location } from './location';\nimport * as MetadataUtils from './metadata';\nimport * as object from './object';\nimport { RequestInfo } from './requestinfo';\nimport * as type from './type';\nimport * as UrlUtils from './url';\nimport { XhrIo } from './xhrio';\n\n/**\n * Throws the UNKNOWN FirebaseStorageError if cndn is false.\n */\nexport function handlerCheck(cndn: boolean) {\n  if (!cndn) {\n    throw errorsExports.unknown();\n  }\n}\n\nexport function metadataHandler(\n  authWrapper: AuthWrapper,\n  mappings: MetadataUtils.Mappings\n): (p1: XhrIo, p2: string) => Metadata {\n  function handler(xhr: XhrIo, text: string): Metadata {\n    let metadata = MetadataUtils.fromResourceString(\n      authWrapper,\n      text,\n      mappings\n    );\n    handlerCheck(metadata !== null);\n    return metadata as Metadata;\n  }\n  return handler;\n}\n\nexport function sharedErrorHandler(\n  location: Location\n): (p1: XhrIo, p2: FirebaseStorageError) => FirebaseStorageError {\n  function errorHandler(\n    xhr: XhrIo,\n    err: FirebaseStorageError\n  ): FirebaseStorageError {\n    let newErr;\n    if (xhr.getStatus() === 401) {\n      newErr = errorsExports.unauthenticated();\n    } else {\n      if (xhr.getStatus() === 402) {\n        newErr = errorsExports.quotaExceeded(location.bucket);\n      } else {\n        if (xhr.getStatus() === 403) {\n          newErr = errorsExports.unauthorized(location.path);\n        } else {\n          newErr = err;\n        }\n      }\n    }\n    newErr.setServerResponseProp(err.serverResponseProp());\n    return newErr;\n  }\n  return errorHandler;\n}\n\nexport function objectErrorHandler(\n  location: Location\n): (p1: XhrIo, p2: FirebaseStorageError) => FirebaseStorageError {\n  let shared = sharedErrorHandler(location);\n\n  function errorHandler(\n    xhr: XhrIo,\n    err: FirebaseStorageError\n  ): FirebaseStorageError {\n    let newErr = shared(xhr, err);\n    if (xhr.getStatus() === 404) {\n      newErr = errorsExports.objectNotFound(location.path);\n    }\n    newErr.setServerResponseProp(err.serverResponseProp());\n    return newErr;\n  }\n  return errorHandler;\n}\n\nexport function getMetadata(\n  authWrapper: AuthWrapper,\n  location: Location,\n  mappings: MetadataUtils.Mappings\n): RequestInfo<Metadata> {\n  let urlPart = location.fullServerUrl();\n  let url = UrlUtils.makeNormalUrl(urlPart);\n  let method = 'GET';\n  let timeout = authWrapper.maxOperationRetryTime();\n  let requestInfo = new RequestInfo(\n    url,\n    method,\n    metadataHandler(authWrapper, mappings),\n    timeout\n  );\n  requestInfo.errorHandler = objectErrorHandler(location);\n  return requestInfo;\n}\n\nexport function updateMetadata(\n  authWrapper: AuthWrapper,\n  location: Location,\n  metadata: Metadata,\n  mappings: MetadataUtils.Mappings\n): RequestInfo<Metadata> {\n  let urlPart = location.fullServerUrl();\n  let url = UrlUtils.makeNormalUrl(urlPart);\n  let method = 'PATCH';\n  let body = MetadataUtils.toResourceString(metadata, mappings);\n  let headers = { 'Content-Type': 'application/json; charset=utf-8' };\n  let timeout = authWrapper.maxOperationRetryTime();\n  let requestInfo = new RequestInfo(\n    url,\n    method,\n    metadataHandler(authWrapper, mappings),\n    timeout\n  );\n  requestInfo.headers = headers;\n  requestInfo.body = body;\n  requestInfo.errorHandler = objectErrorHandler(location);\n  return requestInfo;\n}\n\nexport function deleteObject(\n  authWrapper: AuthWrapper,\n  location: Location\n): RequestInfo<void> {\n  let urlPart = location.fullServerUrl();\n  let url = UrlUtils.makeNormalUrl(urlPart);\n  let method = 'DELETE';\n  let timeout = authWrapper.maxOperationRetryTime();\n\n  function handler(xhr: XhrIo, text: string) {}\n  let requestInfo = new RequestInfo(url, method, handler, timeout);\n  requestInfo.successCodes = [200, 204];\n  requestInfo.errorHandler = objectErrorHandler(location);\n  return requestInfo;\n}\n\nexport function determineContentType_(\n  metadata: Metadata | null,\n  blob: FbsBlob | null\n): string {\n  return (\n    (metadata && metadata['contentType']) ||\n    (blob && blob.type()) ||\n    'application/octet-stream'\n  );\n}\n\nexport function metadataForUpload_(\n  location: Location,\n  blob: FbsBlob,\n  opt_metadata?: Metadata | null\n): Metadata {\n  let metadata = object.clone<Metadata>(opt_metadata);\n  metadata['fullPath'] = location.path;\n  metadata['size'] = blob.size();\n  if (!metadata['contentType']) {\n    metadata['contentType'] = determineContentType_(null, blob);\n  }\n  return metadata;\n}\n\nexport function multipartUpload(\n  authWrapper: AuthWrapper,\n  location: Location,\n  mappings: MetadataUtils.Mappings,\n  blob: FbsBlob,\n  opt_metadata?: Metadata | null\n): RequestInfo<Metadata> {\n  let urlPart = location.bucketOnlyServerUrl();\n  let headers: { [prop: string]: string } = {\n    'X-Goog-Upload-Protocol': 'multipart'\n  };\n\n  function genBoundary() {\n    let str = '';\n    for (let i = 0; i < 2; i++) {\n      str = str + Math.random().toString().slice(2);\n    }\n    return str;\n  }\n  let boundary = genBoundary();\n  headers['Content-Type'] = 'multipart/related; boundary=' + boundary;\n  let metadata = metadataForUpload_(location, blob, opt_metadata);\n  let metadataString = MetadataUtils.toResourceString(metadata, mappings);\n  let preBlobPart =\n    '--' +\n    boundary +\n    '\\r\\n' +\n    'Content-Type: application/json; charset=utf-8\\r\\n\\r\\n' +\n    metadataString +\n    '\\r\\n--' +\n    boundary +\n    '\\r\\n' +\n    'Content-Type: ' +\n    metadata['contentType'] +\n    '\\r\\n\\r\\n';\n  let postBlobPart = '\\r\\n--' + boundary + '--';\n  let body = FbsBlob.getBlob(preBlobPart, blob, postBlobPart);\n  if (body === null) {\n    throw errorsExports.cannotSliceBlob();\n  }\n  let urlParams = { name: metadata['fullPath'] };\n  let url = UrlUtils.makeUploadUrl(urlPart);\n  let method = 'POST';\n  let timeout = authWrapper.maxUploadRetryTime();\n  let requestInfo = new RequestInfo(\n    url,\n    method,\n    metadataHandler(authWrapper, mappings),\n    timeout\n  );\n  requestInfo.urlParams = urlParams;\n  requestInfo.headers = headers;\n  requestInfo.body = body.uploadData();\n  requestInfo.errorHandler = sharedErrorHandler(location);\n  return requestInfo;\n}\n\n/**\n * @param current The number of bytes that have been uploaded so far.\n * @param total The total number of bytes in the upload.\n * @param opt_finalized True if the server has finished the upload.\n * @param opt_metadata The upload metadata, should\n *     only be passed if opt_finalized is true.\n * @struct\n */\nexport class ResumableUploadStatus {\n  finalized: boolean;\n  metadata: Metadata | null;\n\n  constructor(\n    public current: number,\n    public total: number,\n    finalized?: boolean,\n    metadata?: Metadata | null\n  ) {\n    this.finalized = !!finalized;\n    this.metadata = metadata || null;\n  }\n}\n\nexport function checkResumeHeader_(xhr: XhrIo, opt_allowed?: string[]): string {\n  let status;\n  try {\n    status = xhr.getResponseHeader('X-Goog-Upload-Status');\n  } catch (e) {\n    handlerCheck(false);\n  }\n  let allowed = opt_allowed || ['active'];\n  handlerCheck(array.contains(allowed, status));\n  return status as string;\n}\n\nexport function createResumableUpload(\n  authWrapper: AuthWrapper,\n  location: Location,\n  mappings: MetadataUtils.Mappings,\n  blob: FbsBlob,\n  opt_metadata?: Metadata | null\n): RequestInfo<string> {\n  let urlPart = location.bucketOnlyServerUrl();\n  let metadata = metadataForUpload_(location, blob, opt_metadata);\n  let urlParams = { name: metadata['fullPath'] };\n  let url = UrlUtils.makeUploadUrl(urlPart);\n  let method = 'POST';\n  let headers = {\n    'X-Goog-Upload-Protocol': 'resumable',\n    'X-Goog-Upload-Command': 'start',\n    'X-Goog-Upload-Header-Content-Length': blob.size(),\n    'X-Goog-Upload-Header-Content-Type': metadata['contentType'],\n    'Content-Type': 'application/json; charset=utf-8'\n  };\n  let body = MetadataUtils.toResourceString(metadata, mappings);\n  let timeout = authWrapper.maxUploadRetryTime();\n\n  function handler(xhr: XhrIo, text: string): string {\n    checkResumeHeader_(xhr);\n    let url;\n    try {\n      url = xhr.getResponseHeader('X-Goog-Upload-URL');\n    } catch (e) {\n      handlerCheck(false);\n    }\n    handlerCheck(type.isString(url));\n    return url as string;\n  }\n  let requestInfo = new RequestInfo(url, method, handler, timeout);\n  requestInfo.urlParams = urlParams;\n  requestInfo.headers = headers;\n  requestInfo.body = body;\n  requestInfo.errorHandler = sharedErrorHandler(location);\n  return requestInfo;\n}\n\n/**\n * @param url From a call to fbs.requests.createResumableUpload.\n */\nexport function getResumableUploadStatus(\n  authWrapper: AuthWrapper,\n  location: Location,\n  url: string,\n  blob: FbsBlob\n): RequestInfo<ResumableUploadStatus> {\n  let headers = { 'X-Goog-Upload-Command': 'query' };\n\n  function handler(xhr: XhrIo, text: string): ResumableUploadStatus {\n    let status = checkResumeHeader_(xhr, ['active', 'final']);\n    let sizeString;\n    try {\n      sizeString = xhr.getResponseHeader('X-Goog-Upload-Size-Received');\n    } catch (e) {\n      handlerCheck(false);\n    }\n    let size = parseInt(sizeString, 10);\n    handlerCheck(!isNaN(size));\n    return new ResumableUploadStatus(size, blob.size(), status === 'final');\n  }\n  let method = 'POST';\n  let timeout = authWrapper.maxUploadRetryTime();\n  let requestInfo = new RequestInfo(url, method, handler, timeout);\n  requestInfo.headers = headers;\n  requestInfo.errorHandler = sharedErrorHandler(location);\n  return requestInfo;\n}\n\n/**\n * Any uploads via the resumable upload API must transfer a number of bytes\n * that is a multiple of this number.\n */\nexport const resumableUploadChunkSize: number = 256 * 1024;\n\n/**\n * @param url From a call to fbs.requests.createResumableUpload.\n * @param chunkSize Number of bytes to upload.\n * @param opt_status The previous status.\n *     If not passed or null, we start from the beginning.\n * @throws fbs.Error If the upload is already complete, the passed in status\n *     has a final size inconsistent with the blob, or the blob cannot be sliced\n *     for upload.\n */\nexport function continueResumableUpload(\n  location: Location,\n  authWrapper: AuthWrapper,\n  url: string,\n  blob: FbsBlob,\n  chunkSize: number,\n  mappings: MetadataUtils.Mappings,\n  opt_status?: ResumableUploadStatus | null,\n  opt_progressCallback?: ((p1: number, p2: number) => void) | null\n): RequestInfo<ResumableUploadStatus> {\n  // TODO(andysoto): standardize on internal asserts\n  // assert(!(opt_status && opt_status.finalized));\n  let status = new ResumableUploadStatus(0, 0);\n  if (opt_status) {\n    status.current = opt_status.current;\n    status.total = opt_status.total;\n  } else {\n    status.current = 0;\n    status.total = blob.size();\n  }\n  if (blob.size() !== status.total) {\n    throw errorsExports.serverFileWrongSize();\n  }\n  let bytesLeft = status.total - status.current;\n  let bytesToUpload = bytesLeft;\n  if (chunkSize > 0) {\n    bytesToUpload = Math.min(bytesToUpload, chunkSize);\n  }\n  let startByte = status.current;\n  let endByte = startByte + bytesToUpload;\n  let uploadCommand =\n    bytesToUpload === bytesLeft ? 'upload, finalize' : 'upload';\n  let headers = {\n    'X-Goog-Upload-Command': uploadCommand,\n    'X-Goog-Upload-Offset': status.current\n  };\n  let body = blob.slice(startByte, endByte);\n  if (body === null) {\n    throw errorsExports.cannotSliceBlob();\n  }\n\n  function handler(xhr: XhrIo, text: string): ResumableUploadStatus {\n    // TODO(andysoto): Verify the MD5 of each uploaded range:\n    // the 'x-range-md5' header comes back with status code 308 responses.\n    // We'll only be able to bail out though, because you can't re-upload a\n    // range that you previously uploaded.\n    let uploadStatus = checkResumeHeader_(xhr, ['active', 'final']);\n    let newCurrent = status.current + bytesToUpload;\n    let size = blob.size();\n    let metadata;\n    if (uploadStatus === 'final') {\n      metadata = metadataHandler(authWrapper, mappings)(xhr, text);\n    } else {\n      metadata = null;\n    }\n    return new ResumableUploadStatus(\n      newCurrent,\n      size,\n      uploadStatus === 'final',\n      metadata\n    );\n  }\n  let method = 'POST';\n  let timeout = authWrapper.maxUploadRetryTime();\n  let requestInfo = new RequestInfo(url, method, handler, timeout);\n  requestInfo.headers = headers;\n  requestInfo.body = body.uploadData();\n  requestInfo.progressCallback = opt_progressCallback || null;\n  requestInfo.errorHandler = sharedErrorHandler(location);\n  return requestInfo;\n}\n","/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\nimport * as array from './array';\nimport { FbsBlob } from './blob';\nimport * as errorsExports from './error';\nimport * as MetadataUtils from './metadata';\nimport * as object from './object';\nimport { RequestInfo } from './requestinfo';\nimport * as type from './type';\nimport * as UrlUtils from './url';\n/**\n * Throws the UNKNOWN FirebaseStorageError if cndn is false.\n */\nexport function handlerCheck(cndn) {\n    if (!cndn) {\n        throw errorsExports.unknown();\n    }\n}\nexport function metadataHandler(authWrapper, mappings) {\n    function handler(xhr, text) {\n        var metadata = MetadataUtils.fromResourceString(authWrapper, text, mappings);\n        handlerCheck(metadata !== null);\n        return metadata;\n    }\n    return handler;\n}\nexport function sharedErrorHandler(location) {\n    function errorHandler(xhr, err) {\n        var newErr;\n        if (xhr.getStatus() === 401) {\n            newErr = errorsExports.unauthenticated();\n        }\n        else {\n            if (xhr.getStatus() === 402) {\n                newErr = errorsExports.quotaExceeded(location.bucket);\n            }\n            else {\n                if (xhr.getStatus() === 403) {\n                    newErr = errorsExports.unauthorized(location.path);\n                }\n                else {\n                    newErr = err;\n                }\n            }\n        }\n        newErr.setServerResponseProp(err.serverResponseProp());\n        return newErr;\n    }\n    return errorHandler;\n}\nexport function objectErrorHandler(location) {\n    var shared = sharedErrorHandler(location);\n    function errorHandler(xhr, err) {\n        var newErr = shared(xhr, err);\n        if (xhr.getStatus() === 404) {\n            newErr = errorsExports.objectNotFound(location.path);\n        }\n        newErr.setServerResponseProp(err.serverResponseProp());\n        return newErr;\n    }\n    return errorHandler;\n}\nexport function getMetadata(authWrapper, location, mappings) {\n    var urlPart = location.fullServerUrl();\n    var url = UrlUtils.makeNormalUrl(urlPart);\n    var method = 'GET';\n    var timeout = authWrapper.maxOperationRetryTime();\n    var requestInfo = new RequestInfo(url, method, metadataHandler(authWrapper, mappings), timeout);\n    requestInfo.errorHandler = objectErrorHandler(location);\n    return requestInfo;\n}\nexport function updateMetadata(authWrapper, location, metadata, mappings) {\n    var urlPart = location.fullServerUrl();\n    var url = UrlUtils.makeNormalUrl(urlPart);\n    var method = 'PATCH';\n    var body = MetadataUtils.toResourceString(metadata, mappings);\n    var headers = { 'Content-Type': 'application/json; charset=utf-8' };\n    var timeout = authWrapper.maxOperationRetryTime();\n    var requestInfo = new RequestInfo(url, method, metadataHandler(authWrapper, mappings), timeout);\n    requestInfo.headers = headers;\n    requestInfo.body = body;\n    requestInfo.errorHandler = objectErrorHandler(location);\n    return requestInfo;\n}\nexport function deleteObject(authWrapper, location) {\n    var urlPart = location.fullServerUrl();\n    var url = UrlUtils.makeNormalUrl(urlPart);\n    var method = 'DELETE';\n    var timeout = authWrapper.maxOperationRetryTime();\n    function handler(xhr, text) { }\n    var requestInfo = new RequestInfo(url, method, handler, timeout);\n    requestInfo.successCodes = [200, 204];\n    requestInfo.errorHandler = objectErrorHandler(location);\n    return requestInfo;\n}\nexport function determineContentType_(metadata, blob) {\n    return ((metadata && metadata['contentType']) ||\n        (blob && blob.type()) ||\n        'application/octet-stream');\n}\nexport function metadataForUpload_(location, blob, opt_metadata) {\n    var metadata = object.clone(opt_metadata);\n    metadata['fullPath'] = location.path;\n    metadata['size'] = blob.size();\n    if (!metadata['contentType']) {\n        metadata['contentType'] = determineContentType_(null, blob);\n    }\n    return metadata;\n}\nexport function multipartUpload(authWrapper, location, mappings, blob, opt_metadata) {\n    var urlPart = location.bucketOnlyServerUrl();\n    var headers = {\n        'X-Goog-Upload-Protocol': 'multipart'\n    };\n    function genBoundary() {\n        var str = '';\n        for (var i = 0; i < 2; i++) {\n            str = str + Math.random().toString().slice(2);\n        }\n        return str;\n    }\n    var boundary = genBoundary();\n    headers['Content-Type'] = 'multipart/related; boundary=' + boundary;\n    var metadata = metadataForUpload_(location, blob, opt_metadata);\n    var metadataString = MetadataUtils.toResourceString(metadata, mappings);\n    var preBlobPart = '--' +\n        boundary +\n        '\\r\\n' +\n        'Content-Type: application/json; charset=utf-8\\r\\n\\r\\n' +\n        metadataString +\n        '\\r\\n--' +\n        boundary +\n        '\\r\\n' +\n        'Content-Type: ' +\n        metadata['contentType'] +\n        '\\r\\n\\r\\n';\n    var postBlobPart = '\\r\\n--' + boundary + '--';\n    var body = FbsBlob.getBlob(preBlobPart, blob, postBlobPart);\n    if (body === null) {\n        throw errorsExports.cannotSliceBlob();\n    }\n    var urlParams = { name: metadata['fullPath'] };\n    var url = UrlUtils.makeUploadUrl(urlPart);\n    var method = 'POST';\n    var timeout = authWrapper.maxUploadRetryTime();\n    var requestInfo = new RequestInfo(url, method, metadataHandler(authWrapper, mappings), timeout);\n    requestInfo.urlParams = urlParams;\n    requestInfo.headers = headers;\n    requestInfo.body = body.uploadData();\n    requestInfo.errorHandler = sharedErrorHandler(location);\n    return requestInfo;\n}\n/**\n * @param current The number of bytes that have been uploaded so far.\n * @param total The total number of bytes in the upload.\n * @param opt_finalized True if the server has finished the upload.\n * @param opt_metadata The upload metadata, should\n *     only be passed if opt_finalized is true.\n * @struct\n */\nvar ResumableUploadStatus = (function () {\n    function ResumableUploadStatus(current, total, finalized, metadata) {\n        this.current = current;\n        this.total = total;\n        this.finalized = !!finalized;\n        this.metadata = metadata || null;\n    }\n    return ResumableUploadStatus;\n}());\nexport { ResumableUploadStatus };\nexport function checkResumeHeader_(xhr, opt_allowed) {\n    var status;\n    try {\n        status = xhr.getResponseHeader('X-Goog-Upload-Status');\n    }\n    catch (e) {\n        handlerCheck(false);\n    }\n    var allowed = opt_allowed || ['active'];\n    handlerCheck(array.contains(allowed, status));\n    return status;\n}\nexport function createResumableUpload(authWrapper, location, mappings, blob, opt_metadata) {\n    var urlPart = location.bucketOnlyServerUrl();\n    var metadata = metadataForUpload_(location, blob, opt_metadata);\n    var urlParams = { name: metadata['fullPath'] };\n    var url = UrlUtils.makeUploadUrl(urlPart);\n    var method = 'POST';\n    var headers = {\n        'X-Goog-Upload-Protocol': 'resumable',\n        'X-Goog-Upload-Command': 'start',\n        'X-Goog-Upload-Header-Content-Length': blob.size(),\n        'X-Goog-Upload-Header-Content-Type': metadata['contentType'],\n        'Content-Type': 'application/json; charset=utf-8'\n    };\n    var body = MetadataUtils.toResourceString(metadata, mappings);\n    var timeout = authWrapper.maxUploadRetryTime();\n    function handler(xhr, text) {\n        checkResumeHeader_(xhr);\n        var url;\n        try {\n            url = xhr.getResponseHeader('X-Goog-Upload-URL');\n        }\n        catch (e) {\n            handlerCheck(false);\n        }\n        handlerCheck(type.isString(url));\n        return url;\n    }\n    var requestInfo = new RequestInfo(url, method, handler, timeout);\n    requestInfo.urlParams = urlParams;\n    requestInfo.headers = headers;\n    requestInfo.body = body;\n    requestInfo.errorHandler = sharedErrorHandler(location);\n    return requestInfo;\n}\n/**\n * @param url From a call to fbs.requests.createResumableUpload.\n */\nexport function getResumableUploadStatus(authWrapper, location, url, blob) {\n    var headers = { 'X-Goog-Upload-Command': 'query' };\n    function handler(xhr, text) {\n        var status = checkResumeHeader_(xhr, ['active', 'final']);\n        var sizeString;\n        try {\n            sizeString = xhr.getResponseHeader('X-Goog-Upload-Size-Received');\n        }\n        catch (e) {\n            handlerCheck(false);\n        }\n        var size = parseInt(sizeString, 10);\n        handlerCheck(!isNaN(size));\n        return new ResumableUploadStatus(size, blob.size(), status === 'final');\n    }\n    var method = 'POST';\n    var timeout = authWrapper.maxUploadRetryTime();\n    var requestInfo = new RequestInfo(url, method, handler, timeout);\n    requestInfo.headers = headers;\n    requestInfo.errorHandler = sharedErrorHandler(location);\n    return requestInfo;\n}\n/**\n * Any uploads via the resumable upload API must transfer a number of bytes\n * that is a multiple of this number.\n */\nexport var resumableUploadChunkSize = 256 * 1024;\n/**\n * @param url From a call to fbs.requests.createResumableUpload.\n * @param chunkSize Number of bytes to upload.\n * @param opt_status The previous status.\n *     If not passed or null, we start from the beginning.\n * @throws fbs.Error If the upload is already complete, the passed in status\n *     has a final size inconsistent with the blob, or the blob cannot be sliced\n *     for upload.\n */\nexport function continueResumableUpload(location, authWrapper, url, blob, chunkSize, mappings, opt_status, opt_progressCallback) {\n    // TODO(andysoto): standardize on internal asserts\n    // assert(!(opt_status && opt_status.finalized));\n    var status = new ResumableUploadStatus(0, 0);\n    if (opt_status) {\n        status.current = opt_status.current;\n        status.total = opt_status.total;\n    }\n    else {\n        status.current = 0;\n        status.total = blob.size();\n    }\n    if (blob.size() !== status.total) {\n        throw errorsExports.serverFileWrongSize();\n    }\n    var bytesLeft = status.total - status.current;\n    var bytesToUpload = bytesLeft;\n    if (chunkSize > 0) {\n        bytesToUpload = Math.min(bytesToUpload, chunkSize);\n    }\n    var startByte = status.current;\n    var endByte = startByte + bytesToUpload;\n    var uploadCommand = bytesToUpload === bytesLeft ? 'upload, finalize' : 'upload';\n    var headers = {\n        'X-Goog-Upload-Command': uploadCommand,\n        'X-Goog-Upload-Offset': status.current\n    };\n    var body = blob.slice(startByte, endByte);\n    if (body === null) {\n        throw errorsExports.cannotSliceBlob();\n    }\n    function handler(xhr, text) {\n        // TODO(andysoto): Verify the MD5 of each uploaded range:\n        // the 'x-range-md5' header comes back with status code 308 responses.\n        // We'll only be able to bail out though, because you can't re-upload a\n        // range that you previously uploaded.\n        var uploadStatus = checkResumeHeader_(xhr, ['active', 'final']);\n        var newCurrent = status.current + bytesToUpload;\n        var size = blob.size();\n        var metadata;\n        if (uploadStatus === 'final') {\n            metadata = metadataHandler(authWrapper, mappings)(xhr, text);\n        }\n        else {\n            metadata = null;\n        }\n        return new ResumableUploadStatus(newCurrent, size, uploadStatus === 'final', metadata);\n    }\n    var method = 'POST';\n    var timeout = authWrapper.maxUploadRetryTime();\n    var requestInfo = new RequestInfo(url, method, handler, timeout);\n    requestInfo.headers = headers;\n    requestInfo.body = body.uploadData();\n    requestInfo.progressCallback = opt_progressCallback || null;\n    requestInfo.errorHandler = sharedErrorHandler(location);\n    return requestInfo;\n}\n\n\n"]}