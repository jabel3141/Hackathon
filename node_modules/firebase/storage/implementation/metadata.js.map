{"version":3,"sources":["src/storage/implementation/metadata.ts","storage/implementation/metadata.js"],"names":["noXform_","xformPath","getMappings","addRef","fromResource","fromResourceString","toResourceString","metadataValidator","json","path","type","UrlUtils","metadata","value","Mapping","server","opt_local","opt_writable","opt_xform","local","writable","xform","mappings_","fullPath","valid","isString","length","lastComponent","mappings","push","mappingsXformPath","nameMapping","xformSize","size","isDef","sizeMapping","xformTokens","tokens","encode","encodeURIComponent","tokensList","split","urls","map","token","bucket","urlPart","base","makeDownloadUrl","queryString","makeQueryString","alt","authWrapper","generateRef","loc","makeStorageReference","Object","defineProperty","get","resource","len","i","mapping","resourceString","obj","jsonObjectOrNull","JSON","stringify","p","validType","isObject","key","val","isNonNullObject"],"mappings":";;;;;;QA4BMA,Q,GAAAA,Q;QA6BAC,S,GAAAA,S;QAUAC,W,GAAAA,W;QAyEAC,M,GAAAA,M;QAUAC,Y,GAAAA,Y;QAgBAC,kB,GAAAA,kB;QAaAC,gB,GAAAA,gB;QAiBAC,iB,GAAAA,iB;;AA9KN;;IAAYC,I;;AACZ;;AACA;;IAAYC,I;;AACZ;;IAAYC,I;;AACZ;;IAAYC,Q;;;;AAEN,SAAAX,QAAA,CAAmBY,QAAnB,EAAuCC,KAAvC,EAAiD;AACrD,WAAOA,KAAP;AACD;AAED;;;AAhCA;;;;;;;;;;;;;;;AAmCA,IAAAC,UAAA,YAAA;AAKE,aAAAA,OAAA,CACSC,MADT,EAEEC,SAFF,EAGEC,YAHF,EAIEC,SAJF,EAImD;AAH1C,aAAAH,MAAA,GAAAA,MAAA;AAKP,aAAKI,KAAL,GAAaH,aAAaD,MAA1B;AACA,aAAKK,QAAL,GAAgB,CAAC,CAACH,YAAlB;AACA,aAAKI,KAAL,GAAaH,aAAalB,QAA1B;AACD;AACH,WAAAc,OAAA;AAfA,CAAA,EAAA;QCASA,O,GAAAA,O;;ADoBT,IAAIQ,YAA6B,IAAjC;AAEM,SAAArB,SAAA,CAAoBsB,QAApB,EAAiC;AACrC,QAAIC,QAAQd,KAAKe,QAAL,CAAcF,QAAd,CAAZ;AACA,QAAI,CAACC,KAAD,IAAUD,SAASG,MAAT,GAAkB,CAAhC,EAAmC;AACjC,eAAOH,QAAP;AACD,KAFD,MAEO;AACLA,mBAAWA,QAAX;AACA,eAAOd,KAAKkB,aAAL,CAAmBJ,QAAnB,CAAP;AACD;AACF;AAEK,SAAArB,WAAA,GAAA;AACJ,QAAIoB,SAAJ,EAAe;AACb,eAAOA,SAAP;AACD;AACD,QAAIM,WAAW,EAAf;AACAA,aAASC,IAAT,CAAc,IAAIf,OAAJ,CAAY,QAAZ,CAAd;AACAc,aAASC,IAAT,CAAc,IAAIf,OAAJ,CAAY,YAAZ,CAAd;AACAc,aAASC,IAAT,CAAc,IAAIf,OAAJ,CAAY,gBAAZ,CAAd;AACAc,aAASC,IAAT,CAAc,IAAIf,OAAJ,CAAY,MAAZ,EAAoB,UAApB,EAAgC,IAAhC,CAAd;AAEA,aAAAgB,iBAAA,CAA2BlB,QAA3B,EAA+CW,QAA/C,EAA4D;AAC1D,eAAOtB,UAAUsB,QAAV,CAAP;AACD;AACD,QAAIQ,cAAc,IAAIjB,OAAJ,CAAY,MAAZ,CAAlB;AACAiB,gBAAYV,KAAZ,GAAoBS,iBAApB;AACAF,aAASC,IAAT,CAAcE,WAAd;AAEA;;;AAGA,aAAAC,SAAA,CAAmBpB,QAAnB,EAAuCqB,IAAvC,EAAgD;AAC9C,YAAIvB,KAAKwB,KAAL,CAAWD,IAAX,CAAJ,EAAsB;AACpB,mBAAO,CAAEA,IAAT;AACD,SAFD,MAEO;AACL,mBAAOA,IAAP;AACD;AACF;AACD,QAAIE,cAAc,IAAIrB,OAAJ,CAAY,MAAZ,CAAlB;AACAqB,gBAAYd,KAAZ,GAAoBW,SAApB;AACAJ,aAASC,IAAT,CAAcM,WAAd;AACAP,aAASC,IAAT,CAAc,IAAIf,OAAJ,CAAY,aAAZ,CAAd;AACAc,aAASC,IAAT,CAAc,IAAIf,OAAJ,CAAY,SAAZ,CAAd;AACAc,aAASC,IAAT,CAAc,IAAIf,OAAJ,CAAY,SAAZ,EAAuB,IAAvB,EAA6B,IAA7B,CAAd;AACAc,aAASC,IAAT,CAAc,IAAIf,OAAJ,CAAY,cAAZ,EAA4B,IAA5B,EAAkC,IAAlC,CAAd;AACAc,aAASC,IAAT,CAAc,IAAIf,OAAJ,CAAY,oBAAZ,EAAkC,IAAlC,EAAwC,IAAxC,CAAd;AACAc,aAASC,IAAT,CAAc,IAAIf,OAAJ,CAAY,iBAAZ,EAA+B,IAA/B,EAAqC,IAArC,CAAd;AACAc,aAASC,IAAT,CAAc,IAAIf,OAAJ,CAAY,iBAAZ,EAA+B,IAA/B,EAAqC,IAArC,CAAd;AACAc,aAASC,IAAT,CAAc,IAAIf,OAAJ,CAAY,aAAZ,EAA2B,IAA3B,EAAiC,IAAjC,CAAd;AACAc,aAASC,IAAT,CAAc,IAAIf,OAAJ,CAAY,UAAZ,EAAwB,gBAAxB,EAA0C,IAA1C,CAAd;AAEA;;;;AAIA,aAAAsB,WAAA,CAAqBxB,QAArB,EAAyCyB,MAAzC,EAAoD;AAClD,YAAIb,QAAQd,KAAKe,QAAL,CAAcY,MAAd,KAAyBA,OAAOX,MAAP,GAAgB,CAArD;AACA,YAAI,CAACF,KAAL,EAAY;AACV;AACA;AACA,mBAAO,EAAP;AACD;AACD,YAAIc,SAASC,kBAAb;AACA,YAAIC,aAAaH,OAAOI,KAAP,CAAa,GAAb,CAAjB;AACA,YAAIC,OAAOF,WAAWG,GAAX,CAAe,UAASC,KAAT,EAAsB;AAC9C,gBAAIC,SAAiBjC,SAAS,QAAT,CAArB;AACA,gBAAIH,OAAeG,SAAS,UAAT,CAAnB;AACA,gBAAIkC,UAAU,QAAQR,OAAOO,MAAP,CAAR,GAAyB,KAAzB,GAAiCP,OAAO7B,IAAP,CAA/C;AACA,gBAAIsC,OAAOpC,SAASqC,eAAT,CAAyBF,OAAzB,CAAX;AACA,gBAAIG,cAActC,SAASuC,eAAT,CAAyB;AACzCC,qBAAK,OADoC;AAEzCP,uBAAOA;AAFkC,aAAzB,CAAlB;AAIA,mBAAOG,OAAOE,WAAd;AACD,SAVU,CAAX;AAWA,eAAOP,IAAP;AACD;AACDd,aAASC,IAAT,CACE,IAAIf,OAAJ,CAAY,gBAAZ,EAA8B,cAA9B,EAA8C,KAA9C,EAAqDsB,WAArD,CADF;AAGAd,gBAAYM,QAAZ;AACA,WAAON,SAAP;AACD;AAEK,SAAAnB,MAAA,CAAiBS,QAAjB,EAAqCwC,WAArC,EAA6D;AACjE,aAAAC,WAAA,GAAA;AACE,YAAIR,SAAiBjC,SAAS,QAAT,CAArB;AACA,YAAIH,OAAeG,SAAS,UAAT,CAAnB;AACA,YAAI0C,MAAM,uBAAaT,MAAb,EAAqBpC,IAArB,CAAV;AACA,eAAO2C,YAAYG,oBAAZ,CAAiCD,GAAjC,CAAP;AACD;AACDE,WAAOC,cAAP,CAAsB7C,QAAtB,EAAgC,KAAhC,EAAuC,EAAE8C,KAAKL,WAAP,EAAvC;AACD;AAEK,SAAAjD,YAAA,CACJgD,WADI,EAEJO,QAFI,EAGJ/B,QAHI,EAGc;AAElB,QAAIhB,WAAqB,EAAzB;AACAA,aAAS,MAAT,IAAmB,MAAnB;AACA,QAAIgD,MAAMhC,SAASF,MAAnB;AACA,SAAK,IAAImC,IAAI,CAAb,EAAgBA,IAAID,GAApB,EAAyBC,GAAzB,EAA8B;AAC5B,YAAIC,UAAUlC,SAASiC,CAAT,CAAd;AACAjD,iBAASkD,QAAQ3C,KAAjB,IAA0B2C,QAAQzC,KAAR,CAAcT,QAAd,EAAwB+C,SAASG,QAAQ/C,MAAjB,CAAxB,CAA1B;AACD;AACDZ,WAAOS,QAAP,EAAiBwC,WAAjB;AACA,WAAOxC,QAAP;AACD;AAEK,SAAAP,kBAAA,CACJ+C,WADI,EAEJW,cAFI,EAGJnC,QAHI,EAGc;AAElB,QAAIoC,MAAMxD,KAAKyD,gBAAL,CAAsBF,cAAtB,CAAV;AACA,QAAIC,QAAQ,IAAZ,EAAkB;AAChB,eAAO,IAAP;AACD;AACD,QAAIL,WAAWK,GAAf;AACA,WAAO5D,aAAagD,WAAb,EAA0BO,QAA1B,EAAoC/B,QAApC,CAAP;AACD;AAEK,SAAAtB,gBAAA,CACJM,QADI,EAEJgB,QAFI,EAEc;AAElB,QAAI+B,WAEA,EAFJ;AAGA,QAAIC,MAAMhC,SAASF,MAAnB;AACA,SAAK,IAAImC,IAAI,CAAb,EAAgBA,IAAID,GAApB,EAAyBC,GAAzB,EAA8B;AAC5B,YAAIC,UAAUlC,SAASiC,CAAT,CAAd;AACA,YAAIC,QAAQ1C,QAAZ,EAAsB;AACpBuC,qBAASG,QAAQ/C,MAAjB,IAA2BH,SAASkD,QAAQ3C,KAAjB,CAA3B;AACD;AACF;AACD,WAAO+C,KAAKC,SAAL,CAAeR,QAAf,CAAP;AACD;AAEK,SAAApD,iBAAA,CAA4B6D,CAA5B,EAAkC;AACtC,QAAIC,YAAYD,KAAK1D,KAAK4D,QAAL,CAAcF,CAAd,CAArB;AACA,QAAI,CAACC,SAAL,EAAgB;AACd,cAAM,2BAAN;AACD;AACD,SAAK,IAAIE,GAAT,IAAgBH,CAAhB,EAAmB;AACjB,YAAII,MAAMJ,EAAEG,GAAF,CAAV;AACA,YAAIA,QAAQ,gBAAZ,EAA8B;AAC5B,gBAAI,CAAC7D,KAAK4D,QAAL,CAAcE,GAAd,CAAL,EAAyB;AACvB,sBAAM,iDAAN;AACD;AACF,SAJD,MAIO;AACL,gBAAI9D,KAAK+D,eAAL,CAAqBD,GAArB,CAAJ,EAA+B;AAC7B,sBAAM,kBAAkBD,GAAlB,GAAwB,wBAA9B;AACD;AACF;AACF;AACF","file":"metadata.js","sourcesContent":["/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/**\n * @fileoverview Documentation for the metadata format\n */\nimport { Metadata } from '../metadata';\n\nimport { AuthWrapper } from './authwrapper';\nimport * as json from './json';\nimport { Location } from './location';\nimport * as path from './path';\nimport * as type from './type';\nimport * as UrlUtils from './url';\n\nexport function noXform_(metadata: Metadata, value: any): any {\n  return value;\n}\n\n/**\n * @struct\n */\nexport class Mapping {\n  local: string;\n  writable: boolean;\n  xform: (p1: Metadata, p2: any) => any;\n\n  constructor(\n    public server: string,\n    opt_local?: string | null,\n    opt_writable?: boolean,\n    opt_xform?: (p1: Metadata, p2: any) => any | null\n  ) {\n    this.local = opt_local || server;\n    this.writable = !!opt_writable;\n    this.xform = opt_xform || noXform_;\n  }\n}\ntype Mappings = Mapping[];\n\nexport { Mappings };\n\nlet mappings_: Mappings | null = null;\n\nexport function xformPath(fullPath: any): string {\n  let valid = type.isString(fullPath);\n  if (!valid || fullPath.length < 2) {\n    return fullPath;\n  } else {\n    fullPath = fullPath as string;\n    return path.lastComponent(fullPath);\n  }\n}\n\nexport function getMappings(): Mappings {\n  if (mappings_) {\n    return mappings_;\n  }\n  let mappings = [];\n  mappings.push(new Mapping('bucket'));\n  mappings.push(new Mapping('generation'));\n  mappings.push(new Mapping('metageneration'));\n  mappings.push(new Mapping('name', 'fullPath', true));\n\n  function mappingsXformPath(metadata: Metadata, fullPath: any): string {\n    return xformPath(fullPath);\n  }\n  let nameMapping = new Mapping('name');\n  nameMapping.xform = mappingsXformPath;\n  mappings.push(nameMapping);\n\n  /**\n   * Coerces the second param to a number, if it is defined.\n   */\n  function xformSize(metadata: Metadata, size: any): number | null | undefined {\n    if (type.isDef(size)) {\n      return +(size as number);\n    } else {\n      return size;\n    }\n  }\n  let sizeMapping = new Mapping('size');\n  sizeMapping.xform = xformSize;\n  mappings.push(sizeMapping);\n  mappings.push(new Mapping('timeCreated'));\n  mappings.push(new Mapping('updated'));\n  mappings.push(new Mapping('md5Hash', null, true));\n  mappings.push(new Mapping('cacheControl', null, true));\n  mappings.push(new Mapping('contentDisposition', null, true));\n  mappings.push(new Mapping('contentEncoding', null, true));\n  mappings.push(new Mapping('contentLanguage', null, true));\n  mappings.push(new Mapping('contentType', null, true));\n  mappings.push(new Mapping('metadata', 'customMetadata', true));\n\n  /**\n   * Transforms a comma-separated string of tokens into a list of download\n   * URLs.\n   */\n  function xformTokens(metadata: Metadata, tokens: any): string[] {\n    let valid = type.isString(tokens) && tokens.length > 0;\n    if (!valid) {\n      // This can happen if objects are uploaded through GCS and retrieved\n      // through list, so we don't want to throw an Error.\n      return [];\n    }\n    let encode = encodeURIComponent;\n    let tokensList = tokens.split(',');\n    let urls = tokensList.map(function(token: string) {\n      let bucket: string = metadata['bucket'] as string;\n      let path: string = metadata['fullPath'] as string;\n      let urlPart = '/b/' + encode(bucket) + '/o/' + encode(path);\n      let base = UrlUtils.makeDownloadUrl(urlPart);\n      let queryString = UrlUtils.makeQueryString({\n        alt: 'media',\n        token: token\n      });\n      return base + queryString;\n    });\n    return urls;\n  }\n  mappings.push(\n    new Mapping('downloadTokens', 'downloadURLs', false, xformTokens)\n  );\n  mappings_ = mappings;\n  return mappings_;\n}\n\nexport function addRef(metadata: Metadata, authWrapper: AuthWrapper) {\n  function generateRef() {\n    let bucket: string = metadata['bucket'] as string;\n    let path: string = metadata['fullPath'] as string;\n    let loc = new Location(bucket, path);\n    return authWrapper.makeStorageReference(loc);\n  }\n  Object.defineProperty(metadata, 'ref', { get: generateRef });\n}\n\nexport function fromResource(\n  authWrapper: AuthWrapper,\n  resource: { [name: string]: any },\n  mappings: Mappings\n): Metadata {\n  let metadata: Metadata = {} as Metadata;\n  metadata['type'] = 'file';\n  let len = mappings.length;\n  for (let i = 0; i < len; i++) {\n    let mapping = mappings[i];\n    metadata[mapping.local] = mapping.xform(metadata, resource[mapping.server]);\n  }\n  addRef(metadata, authWrapper);\n  return metadata;\n}\n\nexport function fromResourceString(\n  authWrapper: AuthWrapper,\n  resourceString: string,\n  mappings: Mappings\n): Metadata | null {\n  let obj = json.jsonObjectOrNull(resourceString);\n  if (obj === null) {\n    return null;\n  }\n  let resource = obj as Metadata;\n  return fromResource(authWrapper, resource, mappings);\n}\n\nexport function toResourceString(\n  metadata: Metadata,\n  mappings: Mappings\n): string {\n  let resource: {\n    [prop: string]: any;\n  } = {};\n  let len = mappings.length;\n  for (let i = 0; i < len; i++) {\n    let mapping = mappings[i];\n    if (mapping.writable) {\n      resource[mapping.server] = metadata[mapping.local];\n    }\n  }\n  return JSON.stringify(resource);\n}\n\nexport function metadataValidator(p: any) {\n  let validType = p && type.isObject(p);\n  if (!validType) {\n    throw 'Expected Metadata object.';\n  }\n  for (let key in p) {\n    let val = p[key];\n    if (key === 'customMetadata') {\n      if (!type.isObject(val)) {\n        throw 'Expected object for \\'customMetadata\\' mapping.';\n      }\n    } else {\n      if (type.isNonNullObject(val)) {\n        throw \"Mapping for '\" + key + \"' cannot be an object.\";\n      }\n    }\n  }\n}\n","/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\nimport * as json from './json';\nimport { Location } from './location';\nimport * as path from './path';\nimport * as type from './type';\nimport * as UrlUtils from './url';\nexport function noXform_(metadata, value) {\n    return value;\n}\n/**\n * @struct\n */\nvar Mapping = (function () {\n    function Mapping(server, opt_local, opt_writable, opt_xform) {\n        this.server = server;\n        this.local = opt_local || server;\n        this.writable = !!opt_writable;\n        this.xform = opt_xform || noXform_;\n    }\n    return Mapping;\n}());\nexport { Mapping };\nvar mappings_ = null;\nexport function xformPath(fullPath) {\n    var valid = type.isString(fullPath);\n    if (!valid || fullPath.length < 2) {\n        return fullPath;\n    }\n    else {\n        fullPath = fullPath;\n        return path.lastComponent(fullPath);\n    }\n}\nexport function getMappings() {\n    if (mappings_) {\n        return mappings_;\n    }\n    var mappings = [];\n    mappings.push(new Mapping('bucket'));\n    mappings.push(new Mapping('generation'));\n    mappings.push(new Mapping('metageneration'));\n    mappings.push(new Mapping('name', 'fullPath', true));\n    function mappingsXformPath(metadata, fullPath) {\n        return xformPath(fullPath);\n    }\n    var nameMapping = new Mapping('name');\n    nameMapping.xform = mappingsXformPath;\n    mappings.push(nameMapping);\n    /**\n     * Coerces the second param to a number, if it is defined.\n     */\n    function xformSize(metadata, size) {\n        if (type.isDef(size)) {\n            return +size;\n        }\n        else {\n            return size;\n        }\n    }\n    var sizeMapping = new Mapping('size');\n    sizeMapping.xform = xformSize;\n    mappings.push(sizeMapping);\n    mappings.push(new Mapping('timeCreated'));\n    mappings.push(new Mapping('updated'));\n    mappings.push(new Mapping('md5Hash', null, true));\n    mappings.push(new Mapping('cacheControl', null, true));\n    mappings.push(new Mapping('contentDisposition', null, true));\n    mappings.push(new Mapping('contentEncoding', null, true));\n    mappings.push(new Mapping('contentLanguage', null, true));\n    mappings.push(new Mapping('contentType', null, true));\n    mappings.push(new Mapping('metadata', 'customMetadata', true));\n    /**\n     * Transforms a comma-separated string of tokens into a list of download\n     * URLs.\n     */\n    function xformTokens(metadata, tokens) {\n        var valid = type.isString(tokens) && tokens.length > 0;\n        if (!valid) {\n            // This can happen if objects are uploaded through GCS and retrieved\n            // through list, so we don't want to throw an Error.\n            return [];\n        }\n        var encode = encodeURIComponent;\n        var tokensList = tokens.split(',');\n        var urls = tokensList.map(function (token) {\n            var bucket = metadata['bucket'];\n            var path = metadata['fullPath'];\n            var urlPart = '/b/' + encode(bucket) + '/o/' + encode(path);\n            var base = UrlUtils.makeDownloadUrl(urlPart);\n            var queryString = UrlUtils.makeQueryString({\n                alt: 'media',\n                token: token\n            });\n            return base + queryString;\n        });\n        return urls;\n    }\n    mappings.push(new Mapping('downloadTokens', 'downloadURLs', false, xformTokens));\n    mappings_ = mappings;\n    return mappings_;\n}\nexport function addRef(metadata, authWrapper) {\n    function generateRef() {\n        var bucket = metadata['bucket'];\n        var path = metadata['fullPath'];\n        var loc = new Location(bucket, path);\n        return authWrapper.makeStorageReference(loc);\n    }\n    Object.defineProperty(metadata, 'ref', { get: generateRef });\n}\nexport function fromResource(authWrapper, resource, mappings) {\n    var metadata = {};\n    metadata['type'] = 'file';\n    var len = mappings.length;\n    for (var i = 0; i < len; i++) {\n        var mapping = mappings[i];\n        metadata[mapping.local] = mapping.xform(metadata, resource[mapping.server]);\n    }\n    addRef(metadata, authWrapper);\n    return metadata;\n}\nexport function fromResourceString(authWrapper, resourceString, mappings) {\n    var obj = json.jsonObjectOrNull(resourceString);\n    if (obj === null) {\n        return null;\n    }\n    var resource = obj;\n    return fromResource(authWrapper, resource, mappings);\n}\nexport function toResourceString(metadata, mappings) {\n    var resource = {};\n    var len = mappings.length;\n    for (var i = 0; i < len; i++) {\n        var mapping = mappings[i];\n        if (mapping.writable) {\n            resource[mapping.server] = metadata[mapping.local];\n        }\n    }\n    return JSON.stringify(resource);\n}\nexport function metadataValidator(p) {\n    var validType = p && type.isObject(p);\n    if (!validType) {\n        throw 'Expected Metadata object.';\n    }\n    for (var key in p) {\n        var val = p[key];\n        if (key === 'customMetadata') {\n            if (!type.isObject(val)) {\n                throw 'Expected object for \\'customMetadata\\' mapping.';\n            }\n        }\n        else {\n            if (type.isNonNullObject(val)) {\n                throw \"Mapping for '\" + key + \"' cannot be an object.\";\n            }\n        }\n    }\n}\n\n\n"]}