{"version":3,"sources":["src/storage/implementation/backoff.ts","storage/implementation/backoff.js"],"names":["start","stop","f","callback","timeout","waitSeconds","timeoutId","hitTimeout","cancelState","canceled","triggeredCallback","triggerCallback","apply","arguments","callWithDelay","millis","setTimeout","handler","success","var_args","_i","length","mustStop","waitMillis","Math","random","stopped","wasTimeout","clearTimeout","id"],"mappings":";;;;;QA8BMA,K,GAAAA,K;QAkGAC,I,GAAAA,I;AAhIN;;;;;;;;;;;;;;;AAwBA;;;;;;AAMM,SAAAD,KAAA,CACJE,CADI,EAKJC,QALI,EAMJC,OANI,EAMW;AAEf;AACA;AACA,QAAIC,cAAc,CAAlB;AACA;AACA,QAAIC,YAAiB,IAArB;AACA,QAAIC,aAAa,KAAjB;AACA,QAAIC,cAAc,CAAlB;AAEA,aAAAC,QAAA,GAAA;AACE,eAAOD,gBAAgB,CAAvB;AACD;AACD,QAAIE,oBAAoB,KAAxB;AAEA,aAAAC,eAAA,GAAA;AACE,YAAI,CAACD,iBAAL,EAAwB;AACtBA,gCAAoB,IAApB;AACAP,qBAASS,KAAT,CAAe,IAAf,EAAqBC,SAArB;AACD;AACF;AAED,aAAAC,aAAA,CAAuBC,MAAvB,EAAqC;AACnCT,oBAAYU,WAAW,YAAA;AACrBV,wBAAY,IAAZ;AACAJ,cAAEe,OAAF,EAAWR,UAAX;AACD,SAHW,EAGTM,MAHS,CAAZ;AAID;AAED,aAAAE,OAAA,CAAiBC,OAAjB,EAAiC;AAAE,YAAAC,WAAA,EAAA;AClB7B,aDkB6B,IAAAC,KAAA,CClB7B,EDkB6BA,KAAAP,UAAAQ,MClB7B,EDkB6BD,IClB7B,EDkB+C;AAAlBD,qBAAAC,KAAA,CAAA,IAAAP,UAAAO,EAAA,CAAA;AChB5B;ADiBL,YAAIV,iBAAJ,EAAuB;AACrB;AACD;AACD,YAAIQ,OAAJ,EAAa;AACXP,4BAAgBC,KAAhB,CAAsB,IAAtB,EAA4BC,SAA5B;AACA;AACD;AACD,YAAIS,WAAWb,cAAcF,UAA7B;AACA,YAAIe,QAAJ,EAAc;AACZX,4BAAgBC,KAAhB,CAAsB,IAAtB,EAA4BC,SAA5B;AACA;AACD;AACD,YAAIR,cAAc,EAAlB,EAAsB;AACpB;AACAA,2BAAe,CAAf;AACD;AACD,YAAIkB,UAAJ;AACA,YAAIf,gBAAgB,CAApB,EAAuB;AACrBA,0BAAc,CAAd;AACAe,yBAAa,CAAb;AACD,SAHD,MAGO;AACLA,yBAAa,CAAClB,cAAcmB,KAAKC,MAAL,EAAf,IAAgC,IAA7C;AACD;AACDX,sBAAcS,UAAd;AACD;AACD,QAAIG,UAAU,KAAd;AAEA,aAAAzB,IAAA,CAAc0B,UAAd,EAAiC;AAC/B,YAAID,OAAJ,EAAa;AACX;AACD;AACDA,kBAAU,IAAV;AACA,YAAIhB,iBAAJ,EAAuB;AACrB;AACD;AACD,YAAIJ,cAAc,IAAlB,EAAwB;AACtB,gBAAI,CAACqB,UAAL,EAAiB;AACfnB,8BAAc,CAAd;AACD;AACDoB,yBAAatB,SAAb;AACAQ,0BAAc,CAAd;AACD,SAND,MAMO;AACL,gBAAI,CAACa,UAAL,EAAiB;AACfnB,8BAAc,CAAd;AACD;AACF;AACF;AACDM,kBAAc,CAAd;AACAE,eAAW,YAAA;AACTT,qBAAa,IAAb;AACAN,aAAK,IAAL;AACD,KAHD,EAGGG,OAHH;AAIA,WAAOH,IAAP;AACD;AAED;;;;;;;AAOM,SAAAA,IAAA,CAAe4B,EAAf,EAAqB;AACzBA,OAAG,KAAH;AACD","file":"backoff.js","sourcesContent":["/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/**\n * @fileoverview Provides a method for running a function with exponential\n * backoff.\n */\ntype id = (p1: boolean) => void;\n\nexport { id };\n\n/**\n * @param f May be invoked\n *     before the function returns.\n * @param callback Get all the arguments passed to the function\n *     passed to f, including the initial boolean.\n */\nexport function start(\n  f: (\n    p1: (success: boolean, ...rest: any[]) => void,\n    canceled: boolean\n  ) => void,\n  callback: Function,\n  timeout: number\n): id {\n  // TODO(andysoto): make this code cleaner (probably refactor into an actual\n  // type instead of a bunch of functions with state shared in the closure)\n  let waitSeconds = 1;\n  // Would type this as \"number\" but that doesn't work for Node so ¯\\_(ツ)_/¯\n  let timeoutId: any = null;\n  let hitTimeout = false;\n  let cancelState = 0;\n\n  function canceled() {\n    return cancelState === 2;\n  }\n  let triggeredCallback = false;\n\n  function triggerCallback() {\n    if (!triggeredCallback) {\n      triggeredCallback = true;\n      callback.apply(null, arguments);\n    }\n  }\n\n  function callWithDelay(millis: number): void {\n    timeoutId = setTimeout(function() {\n      timeoutId = null;\n      f(handler, canceled());\n    }, millis);\n  }\n\n  function handler(success: boolean, ...var_args: any[]): void {\n    if (triggeredCallback) {\n      return;\n    }\n    if (success) {\n      triggerCallback.apply(null, arguments);\n      return;\n    }\n    let mustStop = canceled() || hitTimeout;\n    if (mustStop) {\n      triggerCallback.apply(null, arguments);\n      return;\n    }\n    if (waitSeconds < 64) {\n      /* TODO(andysoto): don't back off so quickly if we know we're offline. */\n      waitSeconds *= 2;\n    }\n    let waitMillis;\n    if (cancelState === 1) {\n      cancelState = 2;\n      waitMillis = 0;\n    } else {\n      waitMillis = (waitSeconds + Math.random()) * 1000;\n    }\n    callWithDelay(waitMillis);\n  }\n  let stopped = false;\n\n  function stop(wasTimeout: boolean): void {\n    if (stopped) {\n      return;\n    }\n    stopped = true;\n    if (triggeredCallback) {\n      return;\n    }\n    if (timeoutId !== null) {\n      if (!wasTimeout) {\n        cancelState = 2;\n      }\n      clearTimeout(timeoutId);\n      callWithDelay(0);\n    } else {\n      if (!wasTimeout) {\n        cancelState = 1;\n      }\n    }\n  }\n  callWithDelay(0);\n  setTimeout(function() {\n    hitTimeout = true;\n    stop(true);\n  }, timeout);\n  return stop;\n}\n\n/**\n * Stops the retry loop from repeating.\n * If the function is currently \"in between\" retries, it is invoked immediately\n * with the second parameter as \"true\". Otherwise, it will be invoked once more\n * after the current invocation finishes iff the current invocation would have\n * triggered another retry.\n */\nexport function stop(id: id) {\n  id(false);\n}\n","/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n/**\n * @param f May be invoked\n *     before the function returns.\n * @param callback Get all the arguments passed to the function\n *     passed to f, including the initial boolean.\n */\nexport function start(f, callback, timeout) {\n    // TODO(andysoto): make this code cleaner (probably refactor into an actual\n    // type instead of a bunch of functions with state shared in the closure)\n    var waitSeconds = 1;\n    // Would type this as \"number\" but that doesn't work for Node so ¯\\_(ツ)_/¯\n    var timeoutId = null;\n    var hitTimeout = false;\n    var cancelState = 0;\n    function canceled() {\n        return cancelState === 2;\n    }\n    var triggeredCallback = false;\n    function triggerCallback() {\n        if (!triggeredCallback) {\n            triggeredCallback = true;\n            callback.apply(null, arguments);\n        }\n    }\n    function callWithDelay(millis) {\n        timeoutId = setTimeout(function () {\n            timeoutId = null;\n            f(handler, canceled());\n        }, millis);\n    }\n    function handler(success) {\n        var var_args = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            var_args[_i - 1] = arguments[_i];\n        }\n        if (triggeredCallback) {\n            return;\n        }\n        if (success) {\n            triggerCallback.apply(null, arguments);\n            return;\n        }\n        var mustStop = canceled() || hitTimeout;\n        if (mustStop) {\n            triggerCallback.apply(null, arguments);\n            return;\n        }\n        if (waitSeconds < 64) {\n            /* TODO(andysoto): don't back off so quickly if we know we're offline. */\n            waitSeconds *= 2;\n        }\n        var waitMillis;\n        if (cancelState === 1) {\n            cancelState = 2;\n            waitMillis = 0;\n        }\n        else {\n            waitMillis = (waitSeconds + Math.random()) * 1000;\n        }\n        callWithDelay(waitMillis);\n    }\n    var stopped = false;\n    function stop(wasTimeout) {\n        if (stopped) {\n            return;\n        }\n        stopped = true;\n        if (triggeredCallback) {\n            return;\n        }\n        if (timeoutId !== null) {\n            if (!wasTimeout) {\n                cancelState = 2;\n            }\n            clearTimeout(timeoutId);\n            callWithDelay(0);\n        }\n        else {\n            if (!wasTimeout) {\n                cancelState = 1;\n            }\n        }\n    }\n    callWithDelay(0);\n    setTimeout(function () {\n        hitTimeout = true;\n        stop(true);\n    }, timeout);\n    return stop;\n}\n/**\n * Stops the retry loop from repeating.\n * If the function is currently \"in between\" retries, it is invoked immediately\n * with the second parameter as \"true\". Otherwise, it will be invoked once more\n * after the current invocation finishes iff the current invocation would have\n * triggered another retry.\n */\nexport function stop(id) {\n    id(false);\n}\n\n\n"]}