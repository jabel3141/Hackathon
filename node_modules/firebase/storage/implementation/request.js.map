{"version":3,"sources":["src/storage/implementation/request.ts","storage/implementation/request.js"],"names":["addAuthHeader_","addVersionHeader_","makeRequest","array","backoff","errorsExports","object","promiseimpl","type","UrlUtils","XhrIoExports","NetworkRequest","url","method","headers","body","successCodes","additionalRetryCodes","callback","errorCallback","timeout","progressCallback","pool","pendingXhr_","backoffId_","resolve_","reject_","canceled_","appDelete_","url_","method_","headers_","body_","successCodes_","slice","additionalRetryCodes_","callback_","errorCallback_","progressCallback_","timeout_","pool_","self","promise_","make","resolve","reject","start_","prototype","doTheRequest","backoffCallback","canceled","RequestEndStatus","xhr","createXhrIo","progressListener","progressEvent","loaded","total","lengthComputable","addUploadProgressListener","send","then","removeUploadProgressListener","hitServer","getErrorCode","ErrorCode","NO_ERROR","status","getStatus","isRetryStatusCode_","wasCanceled","ABORT","successCode","contains","backoffDone","requestWentThrough","wasSuccessCode","result","getResponseText","isJustDef","e","err","unknown","setServerResponseProp","appDeleted","retryLimitExceeded","start","getPromise","cancel","appDelete","stop","abort","isFiveHundredCode","extraRetryCodes","isExtraRetryCode","isRequestSpecificRetryCode","opt_canceled","authToken","length","number","SDK_VERSION","requestInfo","queryPart","makeQueryString","urlParams","clone","handler","errorHandler"],"mappings":"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","file":"request.js","sourcesContent":["/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/**\n * @fileoverview Defines methods used to actually send HTTP requests from\n * abstract representations.\n */\nimport * as array from './array';\nimport * as backoff from './backoff';\nimport * as errorsExports from './error';\nimport { FirebaseStorageError } from './error';\nimport { errors } from './error';\nimport * as object from './object';\nimport * as promiseimpl from './promise_external';\nimport { RequestInfo } from './requestinfo';\nimport * as type from './type';\nimport * as UrlUtils from './url';\nimport * as XhrIoExports from './xhrio';\nimport { Headers, XhrIo } from './xhrio';\nimport { XhrIoPool } from './xhriopool';\nimport { FirebaseNamespace } from '../../app/firebase_app';\nimport firebase from '../../app';\n\n/**\n * @template T\n */\nexport interface Request<T> {\n  getPromise(): Promise<T>;\n\n  /**\n   * Cancels the request. IMPORTANT: the promise may still be resolved with an\n   * appropriate value (if the request is finished before you call this method,\n   * but the promise has not yet been resolved), so don't just assume it will be\n   * rejected if you call this function.\n   * @param appDelete True if the cancelation came from the app being deleted.\n   */\n  cancel(appDelete?: boolean): void;\n}\n\n/**\n * @struct\n * @template T\n */\nclass NetworkRequest<T> implements Request<T> {\n  private url_: string;\n  private method_: string;\n  private headers_: Headers;\n  private body_: string | Blob | Uint8Array | null;\n  private successCodes_: number[];\n  private additionalRetryCodes_: number[];\n  private pendingXhr_: XhrIo | null = null;\n  private backoffId_: backoff.id | null = null;\n  private resolve_: Function | null = null;\n  private reject_: Function | null = null;\n  private canceled_: boolean = false;\n  private appDelete_: boolean = false;\n  private callback_: (p1: XhrIo, p2: string) => T;\n  private errorCallback_:\n    | ((p1: XhrIo, p2: FirebaseStorageError) => FirebaseStorageError)\n    | null;\n  private progressCallback_: ((p1: number, p2: number) => void) | null;\n  private timeout_: number;\n  private pool_: XhrIoPool;\n  promise_: Promise<T>;\n\n  constructor(\n    url: string,\n    method: string,\n    headers: Headers,\n    body: string | Blob | Uint8Array | null,\n    successCodes: number[],\n    additionalRetryCodes: number[],\n    callback: (p1: XhrIo, p2: string) => T,\n    errorCallback:\n      | ((p1: XhrIo, p2: FirebaseStorageError) => FirebaseStorageError)\n      | null,\n    timeout: number,\n    progressCallback: ((p1: number, p2: number) => void) | null,\n    pool: XhrIoPool\n  ) {\n    this.url_ = url;\n    this.method_ = method;\n    this.headers_ = headers;\n    this.body_ = body;\n    this.successCodes_ = successCodes.slice();\n    this.additionalRetryCodes_ = additionalRetryCodes.slice();\n    this.callback_ = callback;\n    this.errorCallback_ = errorCallback;\n    this.progressCallback_ = progressCallback;\n    this.timeout_ = timeout;\n    this.pool_ = pool;\n    let self = this;\n    this.promise_ = promiseimpl.make(function(resolve, reject) {\n      self.resolve_ = resolve;\n      self.reject_ = reject;\n      self.start_();\n    });\n  }\n\n  /**\n   * Actually starts the retry loop.\n   */\n  private start_() {\n    let self = this;\n\n    function doTheRequest(\n      backoffCallback: (p1: boolean, ...p2: any[]) => void,\n      canceled: boolean\n    ) {\n      if (canceled) {\n        backoffCallback(false, new RequestEndStatus(false, null, true));\n        return;\n      }\n      let xhr = self.pool_.createXhrIo();\n      self.pendingXhr_ = xhr;\n\n      function progressListener(progressEvent: ProgressEvent) {\n        let loaded = progressEvent.loaded;\n        let total = progressEvent.lengthComputable ? progressEvent.total : -1;\n        if (self.progressCallback_ !== null) {\n          self.progressCallback_(loaded, total);\n        }\n      }\n      if (self.progressCallback_ !== null) {\n        xhr.addUploadProgressListener(progressListener);\n      }\n      xhr\n        .send(self.url_, self.method_, self.body_, self.headers_)\n        .then(function(xhr: XhrIo) {\n          if (self.progressCallback_ !== null) {\n            xhr.removeUploadProgressListener(progressListener);\n          }\n          self.pendingXhr_ = null;\n          xhr = xhr as XhrIo;\n          let hitServer =\n            xhr.getErrorCode() === XhrIoExports.ErrorCode.NO_ERROR;\n          let status = xhr.getStatus();\n          if (!hitServer || self.isRetryStatusCode_(status)) {\n            let wasCanceled =\n              xhr.getErrorCode() === XhrIoExports.ErrorCode.ABORT;\n            backoffCallback(\n              false,\n              new RequestEndStatus(false, null, wasCanceled)\n            );\n            return;\n          }\n          let successCode = array.contains(self.successCodes_, status);\n          backoffCallback(true, new RequestEndStatus(successCode, xhr));\n        });\n    }\n\n    /**\n     * @param requestWentThrough True if the request eventually went\n     *     through, false if it hit the retry limit or was canceled.\n     */\n    function backoffDone(\n      requestWentThrough: boolean,\n      status: RequestEndStatus\n    ) {\n      let resolve = self.resolve_ as Function;\n      let reject = self.reject_ as Function;\n      let xhr = status.xhr as XhrIo;\n      if (status.wasSuccessCode) {\n        try {\n          let result = self.callback_(xhr, xhr.getResponseText());\n          if (type.isJustDef(result)) {\n            resolve(result);\n          } else {\n            resolve();\n          }\n        } catch (e) {\n          reject(e);\n        }\n      } else {\n        if (xhr !== null) {\n          let err = errorsExports.unknown();\n          err.setServerResponseProp(xhr.getResponseText());\n          if (self.errorCallback_) {\n            reject(self.errorCallback_(xhr, err));\n          } else {\n            reject(err);\n          }\n        } else {\n          if (status.canceled) {\n            let err = self.appDelete_\n              ? errorsExports.appDeleted()\n              : errorsExports.canceled();\n            reject(err);\n          } else {\n            let err = errorsExports.retryLimitExceeded();\n            reject(err);\n          }\n        }\n      }\n    }\n    if (this.canceled_) {\n      backoffDone(false, new RequestEndStatus(false, null, true));\n    } else {\n      this.backoffId_ = backoff.start(doTheRequest, backoffDone, this.timeout_);\n    }\n  }\n\n  /** @inheritDoc */\n  getPromise() {\n    return this.promise_;\n  }\n\n  /** @inheritDoc */\n  cancel(appDelete?: boolean) {\n    this.canceled_ = true;\n    this.appDelete_ = appDelete || false;\n    if (this.backoffId_ !== null) {\n      backoff.stop(this.backoffId_);\n    }\n    if (this.pendingXhr_ !== null) {\n      this.pendingXhr_.abort();\n    }\n  }\n\n  private isRetryStatusCode_(status: number): boolean {\n    // The codes for which to retry came from this page:\n    // https://cloud.google.com/storage/docs/exponential-backoff\n    let isFiveHundredCode = status >= 500 && status < 600;\n    let extraRetryCodes = [\n      // Request Timeout: web server didn't receive full request in time.\n      408,\n      // Too Many Requests: you're getting rate-limited, basically.\n      429\n    ];\n    let isExtraRetryCode = array.contains(extraRetryCodes, status);\n    let isRequestSpecificRetryCode = array.contains(\n      this.additionalRetryCodes_,\n      status\n    );\n    return isFiveHundredCode || isExtraRetryCode || isRequestSpecificRetryCode;\n  }\n}\n\n/**\n * A collection of information about the result of a network request.\n * @param opt_canceled Defaults to false.\n * @struct\n */\nexport class RequestEndStatus {\n  /**\n   * True if the request was canceled.\n   */\n  canceled: boolean;\n\n  constructor(\n    public wasSuccessCode: boolean,\n    public xhr: XhrIo | null,\n    opt_canceled?: boolean\n  ) {\n    this.canceled = !!opt_canceled;\n  }\n}\n\nexport function addAuthHeader_(headers: Headers, authToken: string | null) {\n  if (authToken !== null && authToken.length > 0) {\n    headers['Authorization'] = 'Firebase ' + authToken;\n  }\n}\n\nexport function addVersionHeader_(headers: Headers) {\n  let number =\n    typeof firebase !== 'undefined' ? firebase.SDK_VERSION : 'AppManager';\n  headers['X-Firebase-Storage-Version'] = 'webjs/' + number;\n}\n\n/**\n * @template T\n */\nexport function makeRequest<T>(\n  requestInfo: RequestInfo<T>,\n  authToken: string | null,\n  pool: XhrIoPool\n): Request<T> {\n  let queryPart = UrlUtils.makeQueryString(requestInfo.urlParams);\n  let url = requestInfo.url + queryPart;\n  let headers = object.clone<Headers>(requestInfo.headers);\n  addAuthHeader_(headers, authToken);\n  addVersionHeader_(headers);\n  return new NetworkRequest<T>(\n    url,\n    requestInfo.method,\n    headers,\n    requestInfo.body,\n    requestInfo.successCodes,\n    requestInfo.additionalRetryCodes,\n    requestInfo.handler,\n    requestInfo.errorHandler,\n    requestInfo.timeout,\n    requestInfo.progressCallback,\n    pool\n  );\n}\n","/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n/**\n * @fileoverview Defines methods used to actually send HTTP requests from\n * abstract representations.\n */\nimport * as array from './array';\nimport * as backoff from './backoff';\nimport * as errorsExports from './error';\nimport * as object from './object';\nimport * as promiseimpl from './promise_external';\nimport * as type from './type';\nimport * as UrlUtils from './url';\nimport * as XhrIoExports from './xhrio';\nimport firebase from '../../app';\n/**\n * @struct\n * @template T\n */\nvar NetworkRequest = (function () {\n    function NetworkRequest(url, method, headers, body, successCodes, additionalRetryCodes, callback, errorCallback, timeout, progressCallback, pool) {\n        this.pendingXhr_ = null;\n        this.backoffId_ = null;\n        this.resolve_ = null;\n        this.reject_ = null;\n        this.canceled_ = false;\n        this.appDelete_ = false;\n        this.url_ = url;\n        this.method_ = method;\n        this.headers_ = headers;\n        this.body_ = body;\n        this.successCodes_ = successCodes.slice();\n        this.additionalRetryCodes_ = additionalRetryCodes.slice();\n        this.callback_ = callback;\n        this.errorCallback_ = errorCallback;\n        this.progressCallback_ = progressCallback;\n        this.timeout_ = timeout;\n        this.pool_ = pool;\n        var self = this;\n        this.promise_ = promiseimpl.make(function (resolve, reject) {\n            self.resolve_ = resolve;\n            self.reject_ = reject;\n            self.start_();\n        });\n    }\n    /**\n     * Actually starts the retry loop.\n     */\n    NetworkRequest.prototype.start_ = function () {\n        var self = this;\n        function doTheRequest(backoffCallback, canceled) {\n            if (canceled) {\n                backoffCallback(false, new RequestEndStatus(false, null, true));\n                return;\n            }\n            var xhr = self.pool_.createXhrIo();\n            self.pendingXhr_ = xhr;\n            function progressListener(progressEvent) {\n                var loaded = progressEvent.loaded;\n                var total = progressEvent.lengthComputable ? progressEvent.total : -1;\n                if (self.progressCallback_ !== null) {\n                    self.progressCallback_(loaded, total);\n                }\n            }\n            if (self.progressCallback_ !== null) {\n                xhr.addUploadProgressListener(progressListener);\n            }\n            xhr\n                .send(self.url_, self.method_, self.body_, self.headers_)\n                .then(function (xhr) {\n                if (self.progressCallback_ !== null) {\n                    xhr.removeUploadProgressListener(progressListener);\n                }\n                self.pendingXhr_ = null;\n                xhr = xhr;\n                var hitServer = xhr.getErrorCode() === XhrIoExports.ErrorCode.NO_ERROR;\n                var status = xhr.getStatus();\n                if (!hitServer || self.isRetryStatusCode_(status)) {\n                    var wasCanceled = xhr.getErrorCode() === XhrIoExports.ErrorCode.ABORT;\n                    backoffCallback(false, new RequestEndStatus(false, null, wasCanceled));\n                    return;\n                }\n                var successCode = array.contains(self.successCodes_, status);\n                backoffCallback(true, new RequestEndStatus(successCode, xhr));\n            });\n        }\n        /**\n         * @param requestWentThrough True if the request eventually went\n         *     through, false if it hit the retry limit or was canceled.\n         */\n        function backoffDone(requestWentThrough, status) {\n            var resolve = self.resolve_;\n            var reject = self.reject_;\n            var xhr = status.xhr;\n            if (status.wasSuccessCode) {\n                try {\n                    var result = self.callback_(xhr, xhr.getResponseText());\n                    if (type.isJustDef(result)) {\n                        resolve(result);\n                    }\n                    else {\n                        resolve();\n                    }\n                }\n                catch (e) {\n                    reject(e);\n                }\n            }\n            else {\n                if (xhr !== null) {\n                    var err = errorsExports.unknown();\n                    err.setServerResponseProp(xhr.getResponseText());\n                    if (self.errorCallback_) {\n                        reject(self.errorCallback_(xhr, err));\n                    }\n                    else {\n                        reject(err);\n                    }\n                }\n                else {\n                    if (status.canceled) {\n                        var err = self.appDelete_\n                            ? errorsExports.appDeleted()\n                            : errorsExports.canceled();\n                        reject(err);\n                    }\n                    else {\n                        var err = errorsExports.retryLimitExceeded();\n                        reject(err);\n                    }\n                }\n            }\n        }\n        if (this.canceled_) {\n            backoffDone(false, new RequestEndStatus(false, null, true));\n        }\n        else {\n            this.backoffId_ = backoff.start(doTheRequest, backoffDone, this.timeout_);\n        }\n    };\n    /** @inheritDoc */\n    NetworkRequest.prototype.getPromise = function () {\n        return this.promise_;\n    };\n    /** @inheritDoc */\n    NetworkRequest.prototype.cancel = function (appDelete) {\n        this.canceled_ = true;\n        this.appDelete_ = appDelete || false;\n        if (this.backoffId_ !== null) {\n            backoff.stop(this.backoffId_);\n        }\n        if (this.pendingXhr_ !== null) {\n            this.pendingXhr_.abort();\n        }\n    };\n    NetworkRequest.prototype.isRetryStatusCode_ = function (status) {\n        // The codes for which to retry came from this page:\n        // https://cloud.google.com/storage/docs/exponential-backoff\n        var isFiveHundredCode = status >= 500 && status < 600;\n        var extraRetryCodes = [\n            // Request Timeout: web server didn't receive full request in time.\n            408,\n            // Too Many Requests: you're getting rate-limited, basically.\n            429\n        ];\n        var isExtraRetryCode = array.contains(extraRetryCodes, status);\n        var isRequestSpecificRetryCode = array.contains(this.additionalRetryCodes_, status);\n        return isFiveHundredCode || isExtraRetryCode || isRequestSpecificRetryCode;\n    };\n    return NetworkRequest;\n}());\n/**\n * A collection of information about the result of a network request.\n * @param opt_canceled Defaults to false.\n * @struct\n */\nvar RequestEndStatus = (function () {\n    function RequestEndStatus(wasSuccessCode, xhr, opt_canceled) {\n        this.wasSuccessCode = wasSuccessCode;\n        this.xhr = xhr;\n        this.canceled = !!opt_canceled;\n    }\n    return RequestEndStatus;\n}());\nexport { RequestEndStatus };\nexport function addAuthHeader_(headers, authToken) {\n    if (authToken !== null && authToken.length > 0) {\n        headers['Authorization'] = 'Firebase ' + authToken;\n    }\n}\nexport function addVersionHeader_(headers) {\n    var number = typeof firebase !== 'undefined' ? firebase.SDK_VERSION : 'AppManager';\n    headers['X-Firebase-Storage-Version'] = 'webjs/' + number;\n}\n/**\n * @template T\n */\nexport function makeRequest(requestInfo, authToken, pool) {\n    var queryPart = UrlUtils.makeQueryString(requestInfo.urlParams);\n    var url = requestInfo.url + queryPart;\n    var headers = object.clone(requestInfo.headers);\n    addAuthHeader_(headers, authToken);\n    addVersionHeader_(headers);\n    return new NetworkRequest(url, requestInfo.method, headers, requestInfo.body, requestInfo.successCodes, requestInfo.additionalRetryCodes, requestInfo.handler, requestInfo.errorHandler, requestInfo.timeout, requestInfo.progressCallback, pool);\n}\n\n\n"]}