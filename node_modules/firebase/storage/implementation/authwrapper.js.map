{"version":3,"sources":["src/storage/implementation/authwrapper.ts","storage/implementation/authwrapper.js"],"names":["constants","errorsExports","promiseimpl","type","AuthWrapper","app","maker","requestMaker","service","pool","bucket_","deleted_","app_","options","isDef","extractBucket_","storageRefMaker_","requestMaker_","pool_","service_","maxOperationRetryTime_","defaultMaxOperationRetryTime","maxUploadRetryTime_","defaultMaxUploadRetryTime","requestMap_","config","bucketString","configOption","loc","makeFromBucketSpec","bucket","prototype","getAuthToken","INTERNAL","getToken","then","response","accessToken","_error","resolve","appDeleted","makeStorageReference","makeRequest","requestInfo","authToken","request","addRequest","deleteApp","clear","maxUploadRetryTime","setMaxUploadRetryTime","time","maxOperationRetryTime","setMaxOperationRetryTime"],"mappings":"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","file":"authwrapper.js","sourcesContent":["/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\nimport { Reference } from '../reference';\nimport { Service } from '../service';\nimport * as constants from './constants';\nimport * as errorsExports from './error';\nimport { errors } from './error';\nimport { FailRequest } from './failrequest';\nimport { Location } from './location';\nimport * as promiseimpl from './promise_external';\nimport { Request } from './request';\nimport { RequestInfo } from './requestinfo';\nimport { requestMaker } from './requestmaker';\nimport { RequestMap } from './requestmap';\nimport * as type from './type';\nimport { XhrIoPool } from './xhriopool';\nimport { FirebaseApp, FirebaseAuthTokenData } from '../../app/firebase_app';\n\n/**\n * @param app If null, getAuthToken always resolves with null.\n * @param service The storage service associated with this auth wrapper.\n *     Untyped to avoid circular type dependencies.\n * @struct\n */\nexport class AuthWrapper {\n  private app_: FirebaseApp | null;\n  private bucket_: string | null = null;\n\n  /**\n  maker\n     */\n  private storageRefMaker_: (p1: AuthWrapper, p2: Location) => Reference;\n  private requestMaker_: requestMaker;\n  private pool_: XhrIoPool;\n  private service_: Service;\n  private maxOperationRetryTime_: number;\n  private maxUploadRetryTime_: number;\n  private requestMap_: RequestMap;\n  private deleted_: boolean = false;\n\n  constructor(\n    app: FirebaseApp | null,\n    maker: (p1: AuthWrapper, p2: Location) => Reference,\n    requestMaker: requestMaker,\n    service: Service,\n    pool: XhrIoPool\n  ) {\n    this.app_ = app;\n    if (this.app_ !== null) {\n      let options = this.app_.options;\n      if (type.isDef(options)) {\n        this.bucket_ = AuthWrapper.extractBucket_(options);\n      }\n    }\n    this.storageRefMaker_ = maker;\n    this.requestMaker_ = requestMaker;\n    this.pool_ = pool;\n    this.service_ = service;\n    this.maxOperationRetryTime_ = constants.defaultMaxOperationRetryTime;\n    this.maxUploadRetryTime_ = constants.defaultMaxUploadRetryTime;\n    this.requestMap_ = new RequestMap();\n  }\n\n  private static extractBucket_(config: {\n    [prop: string]: any;\n  }): string | null {\n    let bucketString = config[constants.configOption] || null;\n    if (bucketString == null) {\n      return null;\n    }\n    let loc: Location = Location.makeFromBucketSpec(bucketString);\n    return loc.bucket;\n  }\n\n  getAuthToken(): Promise<string | null> {\n    // TODO(andysoto): remove ifDef checks after firebase-app implements stubs\n    // (b/28673818).\n    if (\n      this.app_ !== null &&\n      type.isDef(this.app_.INTERNAL) &&\n      type.isDef(this.app_.INTERNAL.getToken)\n    ) {\n      return this.app_.INTERNAL.getToken().then(\n        function(response: FirebaseAuthTokenData | null): string | null {\n          if (response !== null) {\n            return response.accessToken;\n          } else {\n            return null;\n          }\n        },\n        function(_error) {\n          return null;\n        }\n      );\n    } else {\n      return promiseimpl.resolve(null) as Promise<string | null>;\n    }\n  }\n\n  bucket(): string | null {\n    if (this.deleted_) {\n      throw errorsExports.appDeleted();\n    } else {\n      return this.bucket_;\n    }\n  }\n\n  /**\n   * The service associated with this auth wrapper. Untyped to avoid circular\n   * type dependencies.\n   */\n  service(): Service {\n    return this.service_;\n  }\n\n  /**\n   * Returns a new firebaseStorage.Reference object referencing this AuthWrapper\n   * at the given Location.\n   * @param loc The Location.\n   * @return Actually a firebaseStorage.Reference, typing not allowed\n   *     because of circular dependency problems.\n   */\n  makeStorageReference(loc: Location): Reference {\n    return this.storageRefMaker_(this, loc);\n  }\n\n  makeRequest<T>(\n    requestInfo: RequestInfo<T>,\n    authToken: string | null\n  ): Request<T> {\n    if (!this.deleted_) {\n      let request = this.requestMaker_(requestInfo, authToken, this.pool_);\n      this.requestMap_.addRequest(request);\n      return request;\n    } else {\n      return new FailRequest(errorsExports.appDeleted());\n    }\n  }\n\n  /**\n   * Stop running requests and prevent more from being created.\n   */\n  deleteApp() {\n    this.deleted_ = true;\n    this.app_ = null;\n    this.requestMap_.clear();\n  }\n\n  maxUploadRetryTime(): number {\n    return this.maxUploadRetryTime_;\n  }\n\n  setMaxUploadRetryTime(time: number) {\n    this.maxUploadRetryTime_ = time;\n  }\n\n  maxOperationRetryTime(): number {\n    return this.maxOperationRetryTime_;\n  }\n\n  setMaxOperationRetryTime(time: number) {\n    this.maxOperationRetryTime_ = time;\n  }\n}\n","import * as constants from './constants';\nimport * as errorsExports from './error';\nimport { FailRequest } from './failrequest';\nimport { Location } from './location';\nimport * as promiseimpl from './promise_external';\nimport { RequestMap } from './requestmap';\nimport * as type from './type';\n/**\n * @param app If null, getAuthToken always resolves with null.\n * @param service The storage service associated with this auth wrapper.\n *     Untyped to avoid circular type dependencies.\n * @struct\n */\nvar AuthWrapper = (function () {\n    function AuthWrapper(app, maker, requestMaker, service, pool) {\n        this.bucket_ = null;\n        this.deleted_ = false;\n        this.app_ = app;\n        if (this.app_ !== null) {\n            var options = this.app_.options;\n            if (type.isDef(options)) {\n                this.bucket_ = AuthWrapper.extractBucket_(options);\n            }\n        }\n        this.storageRefMaker_ = maker;\n        this.requestMaker_ = requestMaker;\n        this.pool_ = pool;\n        this.service_ = service;\n        this.maxOperationRetryTime_ = constants.defaultMaxOperationRetryTime;\n        this.maxUploadRetryTime_ = constants.defaultMaxUploadRetryTime;\n        this.requestMap_ = new RequestMap();\n    }\n    AuthWrapper.extractBucket_ = function (config) {\n        var bucketString = config[constants.configOption] || null;\n        if (bucketString == null) {\n            return null;\n        }\n        var loc = Location.makeFromBucketSpec(bucketString);\n        return loc.bucket;\n    };\n    AuthWrapper.prototype.getAuthToken = function () {\n        // TODO(andysoto): remove ifDef checks after firebase-app implements stubs\n        // (b/28673818).\n        if (this.app_ !== null &&\n            type.isDef(this.app_.INTERNAL) &&\n            type.isDef(this.app_.INTERNAL.getToken)) {\n            return this.app_.INTERNAL.getToken().then(function (response) {\n                if (response !== null) {\n                    return response.accessToken;\n                }\n                else {\n                    return null;\n                }\n            }, function (_error) {\n                return null;\n            });\n        }\n        else {\n            return promiseimpl.resolve(null);\n        }\n    };\n    AuthWrapper.prototype.bucket = function () {\n        if (this.deleted_) {\n            throw errorsExports.appDeleted();\n        }\n        else {\n            return this.bucket_;\n        }\n    };\n    /**\n     * The service associated with this auth wrapper. Untyped to avoid circular\n     * type dependencies.\n     */\n    AuthWrapper.prototype.service = function () {\n        return this.service_;\n    };\n    /**\n     * Returns a new firebaseStorage.Reference object referencing this AuthWrapper\n     * at the given Location.\n     * @param loc The Location.\n     * @return Actually a firebaseStorage.Reference, typing not allowed\n     *     because of circular dependency problems.\n     */\n    AuthWrapper.prototype.makeStorageReference = function (loc) {\n        return this.storageRefMaker_(this, loc);\n    };\n    AuthWrapper.prototype.makeRequest = function (requestInfo, authToken) {\n        if (!this.deleted_) {\n            var request = this.requestMaker_(requestInfo, authToken, this.pool_);\n            this.requestMap_.addRequest(request);\n            return request;\n        }\n        else {\n            return new FailRequest(errorsExports.appDeleted());\n        }\n    };\n    /**\n     * Stop running requests and prevent more from being created.\n     */\n    AuthWrapper.prototype.deleteApp = function () {\n        this.deleted_ = true;\n        this.app_ = null;\n        this.requestMap_.clear();\n    };\n    AuthWrapper.prototype.maxUploadRetryTime = function () {\n        return this.maxUploadRetryTime_;\n    };\n    AuthWrapper.prototype.setMaxUploadRetryTime = function (time) {\n        this.maxUploadRetryTime_ = time;\n    };\n    AuthWrapper.prototype.maxOperationRetryTime = function () {\n        return this.maxOperationRetryTime_;\n    };\n    AuthWrapper.prototype.setMaxOperationRetryTime = function (time) {\n        this.maxOperationRetryTime_ = time;\n    };\n    return AuthWrapper;\n}());\nexport { AuthWrapper };\n\n\n"]}