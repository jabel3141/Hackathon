{"version":3,"sources":["../src/storage/task.ts","storage/task.js"],"names":["fbsTaskEnums","fbsArgs","fbsArray","errors","fbsPromiseimpl","fbsRequests","typeUtils","UploadTask","ref","authWrapper","location","mappings","blob","metadata","_this","transferred_","needToFetchStatus_","needToFetchMetadata_","observers_","error_","uploadUrl_","request_","chunkMultiplier_","resolve_","reject_","ref_","authWrapper_","location_","blob_","metadata_","mappings_","resumable_","shouldDoResumable_","state_","RUNNING","errorHandler_","error","codeEquals","Code","CANCELED","completeTransitions_","transition_","ERROR","metadataErrorHandler_","promise_","make","resolve","reject","start_","then","prototype","makeProgressCallback_","sizeBefore","loaded","total","updateProgress_","size","createResumable_","fetchStatus_","fetchMetadata_","continueUpload_","oneShotUpload_","resolveToken_","callback","getAuthToken","authToken","CANCELING","PAUSING","PAUSED","requestInfo","createResumableUpload","createRequest","makeRequest","getPromise","url","getResumableUploadStatus","statusRequest","status","current","finalized","chunkSize","resumableUploadChunkSize","ResumableUploadStatus","continueResumableUpload","e","uploadRequest","newStatus","increaseMultiplier_","SUCCESS","currentSize","getMetadata","metadataRequest","multipartUpload","multipartRequest","transferred","old","notifyObservers_","state","cancel","wasPaused","canceled","Object","defineProperty","get","externalState","taskStateFromInternalTaskState","enumerable","configurable","on","type","nextOrObserver","completed","undefined","typeValidator","_p","STATE_CHANGED","nextOrObserverMessage","nextValidator","nullFunctionSpec","validator","observerValidator","looseObjectSpec","nextOrObserverValidator","p","anyDefined","isJustDef","specs","stringSpec","validate","arguments","self","makeBinder","binder","opt_complete","observer","addObserver_","removeObserver_","binderNextOrObserverValidator","binderSpecs","typeOnly","onFulfilled","onRejected","catch","push","notifyObserver_","remove","finishPromise_","observers","clone","forEach","triggered","bind","snapshot","toCall","next","complete","resume","valid","pause"],"mappings":"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","file":"task.js","sourcesContent":["/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n/**\n * @fileoverview Defines types for interacting with blob transfer tasks.\n */\n\nimport { AuthWrapper } from './implementation/authwrapper';\nimport { FbsBlob } from './implementation/blob';\nimport { FirebaseStorageError } from './implementation/error';\nimport { InternalTaskState } from './implementation/taskenums';\nimport { Metadata } from './metadata';\nimport {\n  NextFn,\n  ErrorFn,\n  CompleteFn,\n  Unsubscribe,\n  Observer\n} from './implementation/observer';\nimport { Request } from './implementation/request';\nimport * as RequestExports from './implementation/request';\nimport { Subscribe } from './implementation/observer';\nimport { TaskEvent, TaskState } from './implementation/taskenums';\nimport { UploadTaskSnapshot } from './tasksnapshot';\nimport * as fbsArgs from './implementation/args';\nimport { ArgSpec } from './implementation/args';\nimport * as fbsArray from './implementation/array';\nimport { async as fbsAsync } from './implementation/async';\nimport { errors as fbsErrors } from './implementation/error';\nimport * as errors from './implementation/error';\nimport { Location } from './implementation/location';\nimport * as fbsMetadata from './implementation/metadata';\nimport * as fbsPromiseimpl from './implementation/promise_external';\nimport { RequestInfo } from './implementation/requestinfo';\nimport * as fbsRequests from './implementation/requests';\nimport * as fbsTaskEnums from './implementation/taskenums';\nimport * as typeUtils from './implementation/type';\nimport { Reference } from './reference';\n\n/**\n * Represents a blob being uploaded. Can be used to pause/resume/cancel the\n * upload and manage callbacks for various events.\n */\nexport class UploadTask {\n  private ref_: Reference;\n  private authWrapper_: AuthWrapper;\n  private location_: Location;\n  private blob_: FbsBlob;\n  private metadata_: Metadata | null;\n  private mappings_: fbsMetadata.Mappings;\n  private transferred_: number = 0;\n  private needToFetchStatus_: boolean = false;\n  private needToFetchMetadata_: boolean = false;\n  private observers_: Observer<UploadTaskSnapshot>[] = [];\n  private resumable_: boolean;\n  private state_: InternalTaskState;\n  private error_: Error | null = null;\n  private uploadUrl_: string | null = null;\n  private request_: Request<any> | null = null;\n  private chunkMultiplier_: number = 1;\n  private errorHandler_: (p1: FirebaseStorageError) => void;\n  private metadataErrorHandler_: (p1: FirebaseStorageError) => void;\n  private resolve_: ((p1: UploadTaskSnapshot) => void) | null = null;\n  private reject_: ((p1: Error) => void) | null = null;\n  private promise_: Promise<UploadTaskSnapshot>;\n\n  /**\n   * @param ref The firebaseStorage.Reference object this task came\n   *     from, untyped to avoid cyclic dependencies.\n   * @param blob The blob to upload.\n   */\n  constructor(\n    ref: Reference,\n    authWrapper: AuthWrapper,\n    location: Location,\n    mappings: fbsMetadata.Mappings,\n    blob: FbsBlob,\n    metadata: Metadata | null = null\n  ) {\n    this.ref_ = ref;\n    this.authWrapper_ = authWrapper;\n    this.location_ = location;\n    this.blob_ = blob;\n    this.metadata_ = metadata;\n    this.mappings_ = mappings;\n    this.resumable_ = this.shouldDoResumable_(this.blob_);\n    this.state_ = InternalTaskState.RUNNING;\n    this.errorHandler_ = error => {\n      this.request_ = null;\n      this.chunkMultiplier_ = 1;\n      if (error.codeEquals(errors.Code.CANCELED)) {\n        this.needToFetchStatus_ = true;\n        this.completeTransitions_();\n      } else {\n        this.error_ = error;\n        this.transition_(InternalTaskState.ERROR);\n      }\n    };\n    this.metadataErrorHandler_ = error => {\n      this.request_ = null;\n      if (error.codeEquals(errors.Code.CANCELED)) {\n        this.completeTransitions_();\n      } else {\n        this.error_ = error;\n        this.transition_(InternalTaskState.ERROR);\n      }\n    };\n    this.promise_ = fbsPromiseimpl.make((resolve, reject) => {\n      this.resolve_ = resolve;\n      this.reject_ = reject;\n      this.start_();\n    });\n\n    // Prevent uncaught rejections on the internal promise from bubbling out\n    // to the top level with a dummy handler.\n    this.promise_.then(null, () => {});\n  }\n\n  private makeProgressCallback_(): (p1: number, p2: number) => void {\n    const sizeBefore = this.transferred_;\n    return (loaded, total) => {\n      this.updateProgress_(sizeBefore + loaded);\n    };\n  }\n\n  private shouldDoResumable_(blob: FbsBlob): boolean {\n    return blob.size() > 256 * 1024;\n  }\n\n  private start_() {\n    if (this.state_ !== InternalTaskState.RUNNING) {\n      // This can happen if someone pauses us in a resume callback, for example.\n      return;\n    }\n    if (this.request_ !== null) {\n      return;\n    }\n    if (this.resumable_) {\n      if (this.uploadUrl_ === null) {\n        this.createResumable_();\n      } else {\n        if (this.needToFetchStatus_) {\n          this.fetchStatus_();\n        } else {\n          if (this.needToFetchMetadata_) {\n            // Happens if we miss the metadata on upload completion.\n            this.fetchMetadata_();\n          } else {\n            this.continueUpload_();\n          }\n        }\n      }\n    } else {\n      this.oneShotUpload_();\n    }\n  }\n\n  private resolveToken_(callback: (p1: string | null) => void) {\n    this.authWrapper_.getAuthToken().then(authToken => {\n      switch (this.state_) {\n        case InternalTaskState.RUNNING:\n          callback(authToken);\n          break;\n        case InternalTaskState.CANCELING:\n          this.transition_(InternalTaskState.CANCELED);\n          break;\n        case InternalTaskState.PAUSING:\n          this.transition_(InternalTaskState.PAUSED);\n          break;\n        default:\n      }\n    });\n  }\n\n  // TODO(andysoto): assert false\n\n  private createResumable_() {\n    this.resolveToken_(authToken => {\n      const requestInfo = fbsRequests.createResumableUpload(\n        this.authWrapper_,\n        this.location_,\n        this.mappings_,\n        this.blob_,\n        this.metadata_\n      );\n      const createRequest = this.authWrapper_.makeRequest(\n        requestInfo,\n        authToken\n      );\n      this.request_ = createRequest;\n      createRequest.getPromise().then((url: string) => {\n        this.request_ = null;\n        this.uploadUrl_ = url;\n        this.needToFetchStatus_ = false;\n        this.completeTransitions_();\n      }, this.errorHandler_);\n    });\n  }\n\n  private fetchStatus_() {\n    // TODO(andysoto): assert(this.uploadUrl_ !== null);\n    const url = this.uploadUrl_ as string;\n    this.resolveToken_(authToken => {\n      const requestInfo = fbsRequests.getResumableUploadStatus(\n        this.authWrapper_,\n        this.location_,\n        url,\n        this.blob_\n      );\n      const statusRequest = this.authWrapper_.makeRequest(\n        requestInfo,\n        authToken\n      );\n      this.request_ = statusRequest;\n      statusRequest.getPromise().then(status => {\n        status = status as fbsRequests.ResumableUploadStatus;\n        this.request_ = null;\n        this.updateProgress_(status.current);\n        this.needToFetchStatus_ = false;\n        if (status.finalized) {\n          this.needToFetchMetadata_ = true;\n        }\n        this.completeTransitions_();\n      }, this.errorHandler_);\n    });\n  }\n\n  private continueUpload_() {\n    const chunkSize =\n      fbsRequests.resumableUploadChunkSize * this.chunkMultiplier_;\n    const status = new fbsRequests.ResumableUploadStatus(\n      this.transferred_,\n      this.blob_.size()\n    );\n\n    // TODO(andysoto): assert(this.uploadUrl_ !== null);\n    const url = this.uploadUrl_ as string;\n    this.resolveToken_(authToken => {\n      let requestInfo;\n      try {\n        requestInfo = fbsRequests.continueResumableUpload(\n          this.location_,\n          this.authWrapper_,\n          url,\n          this.blob_,\n          chunkSize,\n          this.mappings_,\n          status,\n          this.makeProgressCallback_()\n        );\n      } catch (e) {\n        this.error_ = e;\n        this.transition_(InternalTaskState.ERROR);\n        return;\n      }\n      const uploadRequest = this.authWrapper_.makeRequest(\n        requestInfo,\n        authToken\n      );\n      this.request_ = uploadRequest;\n      uploadRequest\n        .getPromise()\n        .then((newStatus: fbsRequests.ResumableUploadStatus) => {\n          this.increaseMultiplier_();\n          this.request_ = null;\n          this.updateProgress_(newStatus.current);\n          if (newStatus.finalized) {\n            this.metadata_ = newStatus.metadata;\n            this.transition_(InternalTaskState.SUCCESS);\n          } else {\n            this.completeTransitions_();\n          }\n        }, this.errorHandler_);\n    });\n  }\n\n  private increaseMultiplier_() {\n    const currentSize =\n      fbsRequests.resumableUploadChunkSize * this.chunkMultiplier_;\n\n    // Max chunk size is 32M.\n    if (currentSize < 32 * 1024 * 1024) {\n      this.chunkMultiplier_ *= 2;\n    }\n  }\n\n  private fetchMetadata_() {\n    this.resolveToken_(authToken => {\n      const requestInfo = fbsRequests.getMetadata(\n        this.authWrapper_,\n        this.location_,\n        this.mappings_\n      );\n      const metadataRequest = this.authWrapper_.makeRequest(\n        requestInfo,\n        authToken\n      );\n      this.request_ = metadataRequest;\n      metadataRequest.getPromise().then(metadata => {\n        this.request_ = null;\n        this.metadata_ = metadata;\n        this.transition_(InternalTaskState.SUCCESS);\n      }, this.metadataErrorHandler_);\n    });\n  }\n\n  private oneShotUpload_() {\n    this.resolveToken_(authToken => {\n      const requestInfo = fbsRequests.multipartUpload(\n        this.authWrapper_,\n        this.location_,\n        this.mappings_,\n        this.blob_,\n        this.metadata_\n      );\n      const multipartRequest = this.authWrapper_.makeRequest(\n        requestInfo,\n        authToken\n      );\n      this.request_ = multipartRequest;\n      multipartRequest.getPromise().then(metadata => {\n        this.request_ = null;\n        this.metadata_ = metadata;\n        this.updateProgress_(this.blob_.size());\n        this.transition_(InternalTaskState.SUCCESS);\n      }, this.errorHandler_);\n    });\n  }\n\n  private updateProgress_(transferred: number) {\n    const old = this.transferred_;\n    this.transferred_ = transferred;\n\n    // A progress update can make the \"transferred\" value smaller (e.g. a\n    // partial upload not completed by server, after which the \"transferred\"\n    // value may reset to the value at the beginning of the request).\n    if (this.transferred_ !== old) {\n      this.notifyObservers_();\n    }\n  }\n\n  private transition_(state: InternalTaskState) {\n    if (this.state_ === state) {\n      return;\n    }\n    switch (state) {\n      case InternalTaskState.CANCELING:\n        // TODO(andysoto):\n        // assert(this.state_ === InternalTaskState.RUNNING ||\n        //        this.state_ === InternalTaskState.PAUSING);\n        this.state_ = state;\n        if (this.request_ !== null) {\n          this.request_.cancel();\n        }\n        break;\n      case InternalTaskState.PAUSING:\n        // TODO(andysoto):\n        // assert(this.state_ === InternalTaskState.RUNNING);\n        this.state_ = state;\n        if (this.request_ !== null) {\n          this.request_.cancel();\n        }\n        break;\n      case InternalTaskState.RUNNING:\n        // TODO(andysoto):\n        // assert(this.state_ === InternalTaskState.PAUSED ||\n        //        this.state_ === InternalTaskState.PAUSING);\n        const wasPaused = this.state_ === InternalTaskState.PAUSED;\n        this.state_ = state;\n        if (wasPaused) {\n          this.notifyObservers_();\n          this.start_();\n        }\n        break;\n      case InternalTaskState.PAUSED:\n        // TODO(andysoto):\n        // assert(this.state_ === InternalTaskState.PAUSING);\n        this.state_ = state;\n        this.notifyObservers_();\n        break;\n      case InternalTaskState.CANCELED:\n        // TODO(andysoto):\n        // assert(this.state_ === InternalTaskState.PAUSED ||\n        //        this.state_ === InternalTaskState.CANCELING);\n        this.error_ = errors.canceled();\n        this.state_ = state;\n        this.notifyObservers_();\n        break;\n      case InternalTaskState.ERROR:\n        // TODO(andysoto):\n        // assert(this.state_ === InternalTaskState.RUNNING ||\n        //        this.state_ === InternalTaskState.PAUSING ||\n        //        this.state_ === InternalTaskState.CANCELING);\n        this.state_ = state;\n        this.notifyObservers_();\n        break;\n      case InternalTaskState.SUCCESS:\n        // TODO(andysoto):\n        // assert(this.state_ === InternalTaskState.RUNNING ||\n        //        this.state_ === InternalTaskState.PAUSING ||\n        //        this.state_ === InternalTaskState.CANCELING);\n        this.state_ = state;\n        this.notifyObservers_();\n        break;\n    }\n  }\n\n  private completeTransitions_() {\n    switch (this.state_) {\n      case InternalTaskState.PAUSING:\n        this.transition_(InternalTaskState.PAUSED);\n        break;\n      case InternalTaskState.CANCELING:\n        this.transition_(InternalTaskState.CANCELED);\n        break;\n      case InternalTaskState.RUNNING:\n        this.start_();\n        break;\n      default:\n        // TODO(andysoto): assert(false);\n        break;\n    }\n  }\n\n  get snapshot(): UploadTaskSnapshot {\n    const externalState = fbsTaskEnums.taskStateFromInternalTaskState(\n      this.state_\n    );\n    return new UploadTaskSnapshot(\n      this.transferred_,\n      this.blob_.size(),\n      externalState,\n      this.metadata_,\n      this,\n      this.ref_\n    );\n  }\n\n  /**\n   * Adds a callback for an event.\n   * @param type The type of event to listen for.\n   */\n  on(\n    type: TaskEvent,\n    nextOrObserver = undefined,\n    error = undefined,\n    completed = undefined\n  ): Unsubscribe | Subscribe<UploadTaskSnapshot> {\n    function typeValidator(_p: any) {\n      if (type !== TaskEvent.STATE_CHANGED) {\n        throw `Expected one of the event types: [${TaskEvent.STATE_CHANGED}].`;\n      }\n    }\n    const nextOrObserverMessage =\n      'Expected a function or an Object with one of ' +\n      '`next`, `error`, `complete` properties.';\n    const nextValidator = fbsArgs.nullFunctionSpec(true).validator;\n    const observerValidator = fbsArgs.looseObjectSpec(null, true).validator;\n\n    function nextOrObserverValidator(p: any) {\n      try {\n        nextValidator(p);\n        return;\n      } catch (e) {}\n      try {\n        observerValidator(p);\n        const anyDefined =\n          typeUtils.isJustDef(p['next']) ||\n          typeUtils.isJustDef(p['error']) ||\n          typeUtils.isJustDef(p['complete']);\n        if (!anyDefined) {\n          throw '';\n        }\n        return;\n      } catch (e) {\n        throw nextOrObserverMessage;\n      }\n    }\n    const specs = [\n      fbsArgs.stringSpec(typeValidator),\n      fbsArgs.looseObjectSpec(nextOrObserverValidator, true),\n      fbsArgs.nullFunctionSpec(true),\n      fbsArgs.nullFunctionSpec(true)\n    ];\n    fbsArgs.validate('on', specs, arguments);\n    const self = this;\n\n    function makeBinder(\n      specs: ArgSpec[] | null\n    ): Subscribe<UploadTaskSnapshot> {\n      function binder(\n        nextOrObserver:\n          | NextFn<UploadTaskSnapshot>\n          | { [name: string]: string | null }\n          | null,\n        error?: ErrorFn | null,\n        opt_complete?: CompleteFn | null\n      ) {\n        if (specs !== null) {\n          fbsArgs.validate('on', specs, arguments);\n        }\n        const observer = new Observer(nextOrObserver, error, completed);\n        self.addObserver_(observer);\n        return () => {\n          self.removeObserver_(observer);\n        };\n      }\n      return binder;\n    }\n\n    function binderNextOrObserverValidator(p: any) {\n      if (p === null) {\n        throw nextOrObserverMessage;\n      }\n      nextOrObserverValidator(p);\n    }\n    const binderSpecs = [\n      fbsArgs.looseObjectSpec(binderNextOrObserverValidator),\n      fbsArgs.nullFunctionSpec(true),\n      fbsArgs.nullFunctionSpec(true)\n    ];\n    const typeOnly = !(\n      typeUtils.isJustDef(nextOrObserver) ||\n      typeUtils.isJustDef(error) ||\n      typeUtils.isJustDef(completed)\n    );\n    if (typeOnly) {\n      return makeBinder(binderSpecs);\n    } else {\n      return makeBinder(null)(nextOrObserver, error, completed);\n    }\n  }\n\n  /**\n   * This object behaves like a Promise, and resolves with its snapshot data\n   * when the upload completes.\n   * @param onFulfilled The fulfillment callback. Promise chaining works as normal.\n   * @param onRejected The rejection callback.\n   */\n  then<U>(\n    onFulfilled?: ((value: UploadTaskSnapshot) => U | PromiseLike<U>) | null,\n    onRejected?: ((error: any) => U | PromiseLike<U>) | null\n  ): Promise<U> {\n    // These casts are needed so that TypeScript can infer the types of the\n    // resulting Promise.\n    return this.promise_.then<U>(\n      onFulfilled as (value: UploadTaskSnapshot) => U | PromiseLike<U>,\n      onRejected as ((error: any) => PromiseLike<never>) | null\n    );\n  }\n\n  /**\n   * Equivalent to calling `then(null, onRejected)`.\n   */\n  catch<T>(onRejected: (p1: Error) => T | PromiseLike<T>): Promise<T> {\n    return this.then(null, onRejected);\n  }\n\n  /**\n   * Adds the given observer.\n   */\n  private addObserver_(observer: Observer<UploadTaskSnapshot>) {\n    this.observers_.push(observer);\n    this.notifyObserver_(observer);\n  }\n\n  /**\n   * Removes the given observer.\n   */\n  private removeObserver_(observer: Observer<UploadTaskSnapshot>) {\n    fbsArray.remove(this.observers_, observer);\n  }\n\n  private notifyObservers_() {\n    this.finishPromise_();\n    const observers = fbsArray.clone(this.observers_);\n    observers.forEach(observer => {\n      this.notifyObserver_(observer);\n    });\n  }\n\n  private finishPromise_() {\n    if (this.resolve_ !== null) {\n      let triggered = true;\n      switch (fbsTaskEnums.taskStateFromInternalTaskState(this.state_)) {\n        case TaskState.SUCCESS:\n          fbsAsync(this.resolve_.bind(null, this.snapshot))();\n          break;\n        case TaskState.CANCELED:\n        case TaskState.ERROR:\n          const toCall = this.reject_ as ((p1: Error) => void);\n          fbsAsync(toCall.bind(null, this.error_ as Error))();\n          break;\n        default:\n          triggered = false;\n          break;\n      }\n      if (triggered) {\n        this.resolve_ = null;\n        this.reject_ = null;\n      }\n    }\n  }\n\n  private notifyObserver_(observer: Observer<UploadTaskSnapshot>) {\n    const externalState = fbsTaskEnums.taskStateFromInternalTaskState(\n      this.state_\n    );\n    switch (externalState) {\n      case TaskState.RUNNING:\n      case TaskState.PAUSED:\n        if (observer.next !== null) {\n          fbsAsync(observer.next.bind(observer, this.snapshot))();\n        }\n        break;\n      case TaskState.SUCCESS:\n        if (observer.complete !== null) {\n          fbsAsync(observer.complete.bind(observer))();\n        }\n        break;\n      case TaskState.CANCELED:\n      case TaskState.ERROR:\n        if (observer.error !== null) {\n          fbsAsync(observer.error.bind(observer, this.error_ as Error))();\n        }\n        break;\n      default:\n        // TODO(andysoto): assert(false);\n        if (observer.error !== null) {\n          fbsAsync(observer.error.bind(observer, this.error_ as Error))();\n        }\n    }\n  }\n\n  /**\n   * Resumes a paused task. Has no effect on a currently running or failed task.\n   * @return True if the operation took effect, false if ignored.\n   */\n  resume(): boolean {\n    fbsArgs.validate('resume', [], arguments);\n    const valid =\n      this.state_ === InternalTaskState.PAUSED ||\n      this.state_ === InternalTaskState.PAUSING;\n    if (valid) {\n      this.transition_(InternalTaskState.RUNNING);\n    }\n    return valid;\n  }\n\n  /**\n   * Pauses a currently running task. Has no effect on a paused or failed task.\n   * @return True if the operation took effect, false if ignored.\n   */\n  pause(): boolean {\n    fbsArgs.validate('pause', [], arguments);\n    const valid = this.state_ === InternalTaskState.RUNNING;\n    if (valid) {\n      this.transition_(InternalTaskState.PAUSING);\n    }\n    return valid;\n  }\n\n  /**\n   * Cancels a currently running or paused task. Has no effect on a complete or\n   * failed task.\n   * @return True if the operation took effect, false if ignored.\n   */\n  cancel(): boolean {\n    fbsArgs.validate('cancel', [], arguments);\n    const valid =\n      this.state_ === InternalTaskState.RUNNING ||\n      this.state_ === InternalTaskState.PAUSING;\n    if (valid) {\n      this.transition_(InternalTaskState.CANCELING);\n    }\n    return valid;\n  }\n}\n","/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n/**\n * @fileoverview Defines types for interacting with blob transfer tasks.\n */\nimport { InternalTaskState } from './implementation/taskenums';\nimport { Observer } from './implementation/observer';\nimport { TaskEvent, TaskState } from './implementation/taskenums';\nimport { UploadTaskSnapshot } from './tasksnapshot';\nimport * as fbsArgs from './implementation/args';\nimport * as fbsArray from './implementation/array';\nimport { async as fbsAsync } from './implementation/async';\nimport * as errors from './implementation/error';\nimport * as fbsPromiseimpl from './implementation/promise_external';\nimport * as fbsRequests from './implementation/requests';\nimport * as fbsTaskEnums from './implementation/taskenums';\nimport * as typeUtils from './implementation/type';\n/**\n * Represents a blob being uploaded. Can be used to pause/resume/cancel the\n * upload and manage callbacks for various events.\n */\nvar UploadTask = (function () {\n    /**\n     * @param ref The firebaseStorage.Reference object this task came\n     *     from, untyped to avoid cyclic dependencies.\n     * @param blob The blob to upload.\n     */\n    function UploadTask(ref, authWrapper, location, mappings, blob, metadata) {\n        if (metadata === void 0) { metadata = null; }\n        var _this = this;\n        this.transferred_ = 0;\n        this.needToFetchStatus_ = false;\n        this.needToFetchMetadata_ = false;\n        this.observers_ = [];\n        this.error_ = null;\n        this.uploadUrl_ = null;\n        this.request_ = null;\n        this.chunkMultiplier_ = 1;\n        this.resolve_ = null;\n        this.reject_ = null;\n        this.ref_ = ref;\n        this.authWrapper_ = authWrapper;\n        this.location_ = location;\n        this.blob_ = blob;\n        this.metadata_ = metadata;\n        this.mappings_ = mappings;\n        this.resumable_ = this.shouldDoResumable_(this.blob_);\n        this.state_ = InternalTaskState.RUNNING;\n        this.errorHandler_ = function (error) {\n            _this.request_ = null;\n            _this.chunkMultiplier_ = 1;\n            if (error.codeEquals(errors.Code.CANCELED)) {\n                _this.needToFetchStatus_ = true;\n                _this.completeTransitions_();\n            }\n            else {\n                _this.error_ = error;\n                _this.transition_(InternalTaskState.ERROR);\n            }\n        };\n        this.metadataErrorHandler_ = function (error) {\n            _this.request_ = null;\n            if (error.codeEquals(errors.Code.CANCELED)) {\n                _this.completeTransitions_();\n            }\n            else {\n                _this.error_ = error;\n                _this.transition_(InternalTaskState.ERROR);\n            }\n        };\n        this.promise_ = fbsPromiseimpl.make(function (resolve, reject) {\n            _this.resolve_ = resolve;\n            _this.reject_ = reject;\n            _this.start_();\n        });\n        // Prevent uncaught rejections on the internal promise from bubbling out\n        // to the top level with a dummy handler.\n        this.promise_.then(null, function () { });\n    }\n    UploadTask.prototype.makeProgressCallback_ = function () {\n        var _this = this;\n        var sizeBefore = this.transferred_;\n        return function (loaded, total) {\n            _this.updateProgress_(sizeBefore + loaded);\n        };\n    };\n    UploadTask.prototype.shouldDoResumable_ = function (blob) {\n        return blob.size() > 256 * 1024;\n    };\n    UploadTask.prototype.start_ = function () {\n        if (this.state_ !== InternalTaskState.RUNNING) {\n            // This can happen if someone pauses us in a resume callback, for example.\n            return;\n        }\n        if (this.request_ !== null) {\n            return;\n        }\n        if (this.resumable_) {\n            if (this.uploadUrl_ === null) {\n                this.createResumable_();\n            }\n            else {\n                if (this.needToFetchStatus_) {\n                    this.fetchStatus_();\n                }\n                else {\n                    if (this.needToFetchMetadata_) {\n                        // Happens if we miss the metadata on upload completion.\n                        this.fetchMetadata_();\n                    }\n                    else {\n                        this.continueUpload_();\n                    }\n                }\n            }\n        }\n        else {\n            this.oneShotUpload_();\n        }\n    };\n    UploadTask.prototype.resolveToken_ = function (callback) {\n        var _this = this;\n        this.authWrapper_.getAuthToken().then(function (authToken) {\n            switch (_this.state_) {\n                case InternalTaskState.RUNNING:\n                    callback(authToken);\n                    break;\n                case InternalTaskState.CANCELING:\n                    _this.transition_(InternalTaskState.CANCELED);\n                    break;\n                case InternalTaskState.PAUSING:\n                    _this.transition_(InternalTaskState.PAUSED);\n                    break;\n                default:\n            }\n        });\n    };\n    // TODO(andysoto): assert false\n    UploadTask.prototype.createResumable_ = function () {\n        var _this = this;\n        this.resolveToken_(function (authToken) {\n            var requestInfo = fbsRequests.createResumableUpload(_this.authWrapper_, _this.location_, _this.mappings_, _this.blob_, _this.metadata_);\n            var createRequest = _this.authWrapper_.makeRequest(requestInfo, authToken);\n            _this.request_ = createRequest;\n            createRequest.getPromise().then(function (url) {\n                _this.request_ = null;\n                _this.uploadUrl_ = url;\n                _this.needToFetchStatus_ = false;\n                _this.completeTransitions_();\n            }, _this.errorHandler_);\n        });\n    };\n    UploadTask.prototype.fetchStatus_ = function () {\n        var _this = this;\n        // TODO(andysoto): assert(this.uploadUrl_ !== null);\n        var url = this.uploadUrl_;\n        this.resolveToken_(function (authToken) {\n            var requestInfo = fbsRequests.getResumableUploadStatus(_this.authWrapper_, _this.location_, url, _this.blob_);\n            var statusRequest = _this.authWrapper_.makeRequest(requestInfo, authToken);\n            _this.request_ = statusRequest;\n            statusRequest.getPromise().then(function (status) {\n                status = status;\n                _this.request_ = null;\n                _this.updateProgress_(status.current);\n                _this.needToFetchStatus_ = false;\n                if (status.finalized) {\n                    _this.needToFetchMetadata_ = true;\n                }\n                _this.completeTransitions_();\n            }, _this.errorHandler_);\n        });\n    };\n    UploadTask.prototype.continueUpload_ = function () {\n        var _this = this;\n        var chunkSize = fbsRequests.resumableUploadChunkSize * this.chunkMultiplier_;\n        var status = new fbsRequests.ResumableUploadStatus(this.transferred_, this.blob_.size());\n        // TODO(andysoto): assert(this.uploadUrl_ !== null);\n        var url = this.uploadUrl_;\n        this.resolveToken_(function (authToken) {\n            var requestInfo;\n            try {\n                requestInfo = fbsRequests.continueResumableUpload(_this.location_, _this.authWrapper_, url, _this.blob_, chunkSize, _this.mappings_, status, _this.makeProgressCallback_());\n            }\n            catch (e) {\n                _this.error_ = e;\n                _this.transition_(InternalTaskState.ERROR);\n                return;\n            }\n            var uploadRequest = _this.authWrapper_.makeRequest(requestInfo, authToken);\n            _this.request_ = uploadRequest;\n            uploadRequest\n                .getPromise()\n                .then(function (newStatus) {\n                _this.increaseMultiplier_();\n                _this.request_ = null;\n                _this.updateProgress_(newStatus.current);\n                if (newStatus.finalized) {\n                    _this.metadata_ = newStatus.metadata;\n                    _this.transition_(InternalTaskState.SUCCESS);\n                }\n                else {\n                    _this.completeTransitions_();\n                }\n            }, _this.errorHandler_);\n        });\n    };\n    UploadTask.prototype.increaseMultiplier_ = function () {\n        var currentSize = fbsRequests.resumableUploadChunkSize * this.chunkMultiplier_;\n        // Max chunk size is 32M.\n        if (currentSize < 32 * 1024 * 1024) {\n            this.chunkMultiplier_ *= 2;\n        }\n    };\n    UploadTask.prototype.fetchMetadata_ = function () {\n        var _this = this;\n        this.resolveToken_(function (authToken) {\n            var requestInfo = fbsRequests.getMetadata(_this.authWrapper_, _this.location_, _this.mappings_);\n            var metadataRequest = _this.authWrapper_.makeRequest(requestInfo, authToken);\n            _this.request_ = metadataRequest;\n            metadataRequest.getPromise().then(function (metadata) {\n                _this.request_ = null;\n                _this.metadata_ = metadata;\n                _this.transition_(InternalTaskState.SUCCESS);\n            }, _this.metadataErrorHandler_);\n        });\n    };\n    UploadTask.prototype.oneShotUpload_ = function () {\n        var _this = this;\n        this.resolveToken_(function (authToken) {\n            var requestInfo = fbsRequests.multipartUpload(_this.authWrapper_, _this.location_, _this.mappings_, _this.blob_, _this.metadata_);\n            var multipartRequest = _this.authWrapper_.makeRequest(requestInfo, authToken);\n            _this.request_ = multipartRequest;\n            multipartRequest.getPromise().then(function (metadata) {\n                _this.request_ = null;\n                _this.metadata_ = metadata;\n                _this.updateProgress_(_this.blob_.size());\n                _this.transition_(InternalTaskState.SUCCESS);\n            }, _this.errorHandler_);\n        });\n    };\n    UploadTask.prototype.updateProgress_ = function (transferred) {\n        var old = this.transferred_;\n        this.transferred_ = transferred;\n        // A progress update can make the \"transferred\" value smaller (e.g. a\n        // partial upload not completed by server, after which the \"transferred\"\n        // value may reset to the value at the beginning of the request).\n        if (this.transferred_ !== old) {\n            this.notifyObservers_();\n        }\n    };\n    UploadTask.prototype.transition_ = function (state) {\n        if (this.state_ === state) {\n            return;\n        }\n        switch (state) {\n            case InternalTaskState.CANCELING:\n                // TODO(andysoto):\n                // assert(this.state_ === InternalTaskState.RUNNING ||\n                //        this.state_ === InternalTaskState.PAUSING);\n                this.state_ = state;\n                if (this.request_ !== null) {\n                    this.request_.cancel();\n                }\n                break;\n            case InternalTaskState.PAUSING:\n                // TODO(andysoto):\n                // assert(this.state_ === InternalTaskState.RUNNING);\n                this.state_ = state;\n                if (this.request_ !== null) {\n                    this.request_.cancel();\n                }\n                break;\n            case InternalTaskState.RUNNING:\n                // TODO(andysoto):\n                // assert(this.state_ === InternalTaskState.PAUSED ||\n                //        this.state_ === InternalTaskState.PAUSING);\n                var wasPaused = this.state_ === InternalTaskState.PAUSED;\n                this.state_ = state;\n                if (wasPaused) {\n                    this.notifyObservers_();\n                    this.start_();\n                }\n                break;\n            case InternalTaskState.PAUSED:\n                // TODO(andysoto):\n                // assert(this.state_ === InternalTaskState.PAUSING);\n                this.state_ = state;\n                this.notifyObservers_();\n                break;\n            case InternalTaskState.CANCELED:\n                // TODO(andysoto):\n                // assert(this.state_ === InternalTaskState.PAUSED ||\n                //        this.state_ === InternalTaskState.CANCELING);\n                this.error_ = errors.canceled();\n                this.state_ = state;\n                this.notifyObservers_();\n                break;\n            case InternalTaskState.ERROR:\n                // TODO(andysoto):\n                // assert(this.state_ === InternalTaskState.RUNNING ||\n                //        this.state_ === InternalTaskState.PAUSING ||\n                //        this.state_ === InternalTaskState.CANCELING);\n                this.state_ = state;\n                this.notifyObservers_();\n                break;\n            case InternalTaskState.SUCCESS:\n                // TODO(andysoto):\n                // assert(this.state_ === InternalTaskState.RUNNING ||\n                //        this.state_ === InternalTaskState.PAUSING ||\n                //        this.state_ === InternalTaskState.CANCELING);\n                this.state_ = state;\n                this.notifyObservers_();\n                break;\n        }\n    };\n    UploadTask.prototype.completeTransitions_ = function () {\n        switch (this.state_) {\n            case InternalTaskState.PAUSING:\n                this.transition_(InternalTaskState.PAUSED);\n                break;\n            case InternalTaskState.CANCELING:\n                this.transition_(InternalTaskState.CANCELED);\n                break;\n            case InternalTaskState.RUNNING:\n                this.start_();\n                break;\n            default:\n                // TODO(andysoto): assert(false);\n                break;\n        }\n    };\n    Object.defineProperty(UploadTask.prototype, \"snapshot\", {\n        get: function () {\n            var externalState = fbsTaskEnums.taskStateFromInternalTaskState(this.state_);\n            return new UploadTaskSnapshot(this.transferred_, this.blob_.size(), externalState, this.metadata_, this, this.ref_);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Adds a callback for an event.\n     * @param type The type of event to listen for.\n     */\n    UploadTask.prototype.on = function (type, nextOrObserver, error, completed) {\n        if (nextOrObserver === void 0) { nextOrObserver = undefined; }\n        if (error === void 0) { error = undefined; }\n        if (completed === void 0) { completed = undefined; }\n        function typeValidator(_p) {\n            if (type !== TaskEvent.STATE_CHANGED) {\n                throw \"Expected one of the event types: [\" + TaskEvent.STATE_CHANGED + \"].\";\n            }\n        }\n        var nextOrObserverMessage = 'Expected a function or an Object with one of ' +\n            '`next`, `error`, `complete` properties.';\n        var nextValidator = fbsArgs.nullFunctionSpec(true).validator;\n        var observerValidator = fbsArgs.looseObjectSpec(null, true).validator;\n        function nextOrObserverValidator(p) {\n            try {\n                nextValidator(p);\n                return;\n            }\n            catch (e) { }\n            try {\n                observerValidator(p);\n                var anyDefined = typeUtils.isJustDef(p['next']) ||\n                    typeUtils.isJustDef(p['error']) ||\n                    typeUtils.isJustDef(p['complete']);\n                if (!anyDefined) {\n                    throw '';\n                }\n                return;\n            }\n            catch (e) {\n                throw nextOrObserverMessage;\n            }\n        }\n        var specs = [\n            fbsArgs.stringSpec(typeValidator),\n            fbsArgs.looseObjectSpec(nextOrObserverValidator, true),\n            fbsArgs.nullFunctionSpec(true),\n            fbsArgs.nullFunctionSpec(true)\n        ];\n        fbsArgs.validate('on', specs, arguments);\n        var self = this;\n        function makeBinder(specs) {\n            function binder(nextOrObserver, error, opt_complete) {\n                if (specs !== null) {\n                    fbsArgs.validate('on', specs, arguments);\n                }\n                var observer = new Observer(nextOrObserver, error, completed);\n                self.addObserver_(observer);\n                return function () {\n                    self.removeObserver_(observer);\n                };\n            }\n            return binder;\n        }\n        function binderNextOrObserverValidator(p) {\n            if (p === null) {\n                throw nextOrObserverMessage;\n            }\n            nextOrObserverValidator(p);\n        }\n        var binderSpecs = [\n            fbsArgs.looseObjectSpec(binderNextOrObserverValidator),\n            fbsArgs.nullFunctionSpec(true),\n            fbsArgs.nullFunctionSpec(true)\n        ];\n        var typeOnly = !(typeUtils.isJustDef(nextOrObserver) ||\n            typeUtils.isJustDef(error) ||\n            typeUtils.isJustDef(completed));\n        if (typeOnly) {\n            return makeBinder(binderSpecs);\n        }\n        else {\n            return makeBinder(null)(nextOrObserver, error, completed);\n        }\n    };\n    /**\n     * This object behaves like a Promise, and resolves with its snapshot data\n     * when the upload completes.\n     * @param onFulfilled The fulfillment callback. Promise chaining works as normal.\n     * @param onRejected The rejection callback.\n     */\n    UploadTask.prototype.then = function (onFulfilled, onRejected) {\n        // These casts are needed so that TypeScript can infer the types of the\n        // resulting Promise.\n        return this.promise_.then(onFulfilled, onRejected);\n    };\n    /**\n     * Equivalent to calling `then(null, onRejected)`.\n     */\n    UploadTask.prototype.catch = function (onRejected) {\n        return this.then(null, onRejected);\n    };\n    /**\n     * Adds the given observer.\n     */\n    UploadTask.prototype.addObserver_ = function (observer) {\n        this.observers_.push(observer);\n        this.notifyObserver_(observer);\n    };\n    /**\n     * Removes the given observer.\n     */\n    UploadTask.prototype.removeObserver_ = function (observer) {\n        fbsArray.remove(this.observers_, observer);\n    };\n    UploadTask.prototype.notifyObservers_ = function () {\n        var _this = this;\n        this.finishPromise_();\n        var observers = fbsArray.clone(this.observers_);\n        observers.forEach(function (observer) {\n            _this.notifyObserver_(observer);\n        });\n    };\n    UploadTask.prototype.finishPromise_ = function () {\n        if (this.resolve_ !== null) {\n            var triggered = true;\n            switch (fbsTaskEnums.taskStateFromInternalTaskState(this.state_)) {\n                case TaskState.SUCCESS:\n                    fbsAsync(this.resolve_.bind(null, this.snapshot))();\n                    break;\n                case TaskState.CANCELED:\n                case TaskState.ERROR:\n                    var toCall = this.reject_;\n                    fbsAsync(toCall.bind(null, this.error_))();\n                    break;\n                default:\n                    triggered = false;\n                    break;\n            }\n            if (triggered) {\n                this.resolve_ = null;\n                this.reject_ = null;\n            }\n        }\n    };\n    UploadTask.prototype.notifyObserver_ = function (observer) {\n        var externalState = fbsTaskEnums.taskStateFromInternalTaskState(this.state_);\n        switch (externalState) {\n            case TaskState.RUNNING:\n            case TaskState.PAUSED:\n                if (observer.next !== null) {\n                    fbsAsync(observer.next.bind(observer, this.snapshot))();\n                }\n                break;\n            case TaskState.SUCCESS:\n                if (observer.complete !== null) {\n                    fbsAsync(observer.complete.bind(observer))();\n                }\n                break;\n            case TaskState.CANCELED:\n            case TaskState.ERROR:\n                if (observer.error !== null) {\n                    fbsAsync(observer.error.bind(observer, this.error_))();\n                }\n                break;\n            default:\n                // TODO(andysoto): assert(false);\n                if (observer.error !== null) {\n                    fbsAsync(observer.error.bind(observer, this.error_))();\n                }\n        }\n    };\n    /**\n     * Resumes a paused task. Has no effect on a currently running or failed task.\n     * @return True if the operation took effect, false if ignored.\n     */\n    UploadTask.prototype.resume = function () {\n        fbsArgs.validate('resume', [], arguments);\n        var valid = this.state_ === InternalTaskState.PAUSED ||\n            this.state_ === InternalTaskState.PAUSING;\n        if (valid) {\n            this.transition_(InternalTaskState.RUNNING);\n        }\n        return valid;\n    };\n    /**\n     * Pauses a currently running task. Has no effect on a paused or failed task.\n     * @return True if the operation took effect, false if ignored.\n     */\n    UploadTask.prototype.pause = function () {\n        fbsArgs.validate('pause', [], arguments);\n        var valid = this.state_ === InternalTaskState.RUNNING;\n        if (valid) {\n            this.transition_(InternalTaskState.PAUSING);\n        }\n        return valid;\n    };\n    /**\n     * Cancels a currently running or paused task. Has no effect on a complete or\n     * failed task.\n     * @return True if the operation took effect, false if ignored.\n     */\n    UploadTask.prototype.cancel = function () {\n        fbsArgs.validate('cancel', [], arguments);\n        var valid = this.state_ === InternalTaskState.RUNNING ||\n            this.state_ === InternalTaskState.PAUSING;\n        if (valid) {\n            this.transition_(InternalTaskState.CANCELING);\n        }\n        return valid;\n    };\n    return UploadTask;\n}());\nexport { UploadTask };\n\n\n"]}