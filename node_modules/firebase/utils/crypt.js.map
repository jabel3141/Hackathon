{"version":3,"sources":["../src/utils/crypt.ts"],"names":["stringToByteArray","str","output","p","i","length","c","charCodeAt","byteArrayToString","bytes","CHUNK_SIZE","String","fromCharCode","apply","chunk","slice","base64","byteToCharMap_","charToByteMap_","byteToCharMapWebSafe_","charToByteMapWebSafe_","ENCODED_VALS_BASE","ENCODED_VALS","ENCODED_VALS_WEBSAFE","HAS_NATIVE_SUPPORT","atob","encodeByteArray","input","opt_webSafe","Array","isArray","Error","init_","byteToCharMap","byte1","haveByte2","byte2","haveByte3","byte3","outByte1","outByte2","outByte3","outByte4","push","join","encodeString","btoa","decodeString","decodeStringToByteArray","charToByteMap","charAt","haveByte4","byte4"],"mappings":"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","file":"crypt.js","sourcesContent":["/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\nimport { globalScope } from './globalScope';\n\nconst stringToByteArray = function(str) {\n  var output = [],\n    p = 0;\n  for (var i = 0; i < str.length; i++) {\n    var c = str.charCodeAt(i);\n    while (c > 255) {\n      output[p++] = c & 255;\n      c >>= 8;\n    }\n    output[p++] = c;\n  }\n  return output;\n};\n\n/**\n * Turns an array of numbers into the string given by the concatenation of the\n * characters to which the numbers correspond.\n * @param {Array<number>} bytes Array of numbers representing characters.\n * @return {string} Stringification of the array.\n */\nconst byteArrayToString = function(bytes) {\n  var CHUNK_SIZE = 8192;\n\n  // Special-case the simple case for speed's sake.\n  if (bytes.length < CHUNK_SIZE) {\n    return String.fromCharCode.apply(null, bytes);\n  }\n\n  // The remaining logic splits conversion by chunks since\n  // Function#apply() has a maximum parameter count.\n  // See discussion: http://goo.gl/LrWmZ9\n\n  var str = '';\n  for (var i = 0; i < bytes.length; i += CHUNK_SIZE) {\n    var chunk = bytes.slice(i, i + CHUNK_SIZE);\n    str += String.fromCharCode.apply(null, chunk);\n  }\n  return str;\n};\n\n// Static lookup maps, lazily populated by init_()\nexport const base64 = {\n  /**\n   * Maps bytes to characters.\n   * @type {Object}\n   * @private\n   */\n  byteToCharMap_: null,\n\n  /**\n   * Maps characters to bytes.\n   * @type {Object}\n   * @private\n   */\n  charToByteMap_: null,\n\n  /**\n   * Maps bytes to websafe characters.\n   * @type {Object}\n   * @private\n   */\n  byteToCharMapWebSafe_: null,\n\n  /**\n   * Maps websafe characters to bytes.\n   * @type {Object}\n   * @private\n   */\n  charToByteMapWebSafe_: null,\n\n  /**\n   * Our default alphabet, shared between\n   * ENCODED_VALS and ENCODED_VALS_WEBSAFE\n   * @type {string}\n   */\n  ENCODED_VALS_BASE:\n    'ABCDEFGHIJKLMNOPQRSTUVWXYZ' + 'abcdefghijklmnopqrstuvwxyz' + '0123456789',\n\n  /**\n   * Our default alphabet. Value 64 (=) is special; it means \"nothing.\"\n   * @type {string}\n   */\n  get ENCODED_VALS() {\n    return this.ENCODED_VALS_BASE + '+/=';\n  },\n\n  /**\n   * Our websafe alphabet.\n   * @type {string}\n   */\n  get ENCODED_VALS_WEBSAFE() {\n    return this.ENCODED_VALS_BASE + '-_.';\n  },\n\n  /**\n   * Whether this browser supports the atob and btoa functions. This extension\n   * started at Mozilla but is now implemented by many browsers. We use the\n   * ASSUME_* variables to avoid pulling in the full useragent detection library\n   * but still allowing the standard per-browser compilations.\n   *\n   * @type {boolean}\n   */\n  HAS_NATIVE_SUPPORT: typeof globalScope.atob === 'function',\n\n  /**\n   * Base64-encode an array of bytes.\n   *\n   * @param {Array<number>|Uint8Array} input An array of bytes (numbers with\n   *     value in [0, 255]) to encode.\n   * @param {boolean=} opt_webSafe Boolean indicating we should use the\n   *     alternative alphabet.\n   * @return {string} The base64 encoded string.\n   */\n  encodeByteArray(input, opt_webSafe?) {\n    if (!Array.isArray(input)) {\n      throw Error('encodeByteArray takes an array as a parameter');\n    }\n\n    this.init_();\n\n    var byteToCharMap = opt_webSafe\n      ? this.byteToCharMapWebSafe_\n      : this.byteToCharMap_;\n\n    var output = [];\n\n    for (var i = 0; i < input.length; i += 3) {\n      var byte1 = input[i];\n      var haveByte2 = i + 1 < input.length;\n      var byte2 = haveByte2 ? input[i + 1] : 0;\n      var haveByte3 = i + 2 < input.length;\n      var byte3 = haveByte3 ? input[i + 2] : 0;\n\n      var outByte1 = byte1 >> 2;\n      var outByte2 = ((byte1 & 0x03) << 4) | (byte2 >> 4);\n      var outByte3 = ((byte2 & 0x0f) << 2) | (byte3 >> 6);\n      var outByte4 = byte3 & 0x3f;\n\n      if (!haveByte3) {\n        outByte4 = 64;\n\n        if (!haveByte2) {\n          outByte3 = 64;\n        }\n      }\n\n      output.push(\n        byteToCharMap[outByte1],\n        byteToCharMap[outByte2],\n        byteToCharMap[outByte3],\n        byteToCharMap[outByte4]\n      );\n    }\n\n    return output.join('');\n  },\n\n  /**\n   * Base64-encode a string.\n   *\n   * @param {string} input A string to encode.\n   * @param {boolean=} opt_webSafe If true, we should use the\n   *     alternative alphabet.\n   * @return {string} The base64 encoded string.\n   */\n  encodeString(input, opt_webSafe) {\n    // Shortcut for Mozilla browsers that implement\n    // a native base64 encoder in the form of \"btoa/atob\"\n    if (this.HAS_NATIVE_SUPPORT && !opt_webSafe) {\n      return btoa(input);\n    }\n    return this.encodeByteArray(stringToByteArray(input), opt_webSafe);\n  },\n\n  /**\n   * Base64-decode a string.\n   *\n   * @param {string} input to decode.\n   * @param {boolean=} opt_webSafe True if we should use the\n   *     alternative alphabet.\n   * @return {string} string representing the decoded value.\n   */\n  decodeString(input, opt_webSafe) {\n    // Shortcut for Mozilla browsers that implement\n    // a native base64 encoder in the form of \"btoa/atob\"\n    if (this.HAS_NATIVE_SUPPORT && !opt_webSafe) {\n      return atob(input);\n    }\n    return byteArrayToString(this.decodeStringToByteArray(input, opt_webSafe));\n  },\n\n  /**\n   * Base64-decode a string.\n   *\n   * In base-64 decoding, groups of four characters are converted into three\n   * bytes.  If the encoder did not apply padding, the input length may not\n   * be a multiple of 4.\n   *\n   * In this case, the last group will have fewer than 4 characters, and\n   * padding will be inferred.  If the group has one or two characters, it decodes\n   * to one byte.  If the group has three characters, it decodes to two bytes.\n   *\n   * @param {string} input Input to decode.\n   * @param {boolean=} opt_webSafe True if we should use the web-safe alphabet.\n   * @return {!Array<number>} bytes representing the decoded value.\n   */\n  decodeStringToByteArray(input, opt_webSafe) {\n    this.init_();\n\n    var charToByteMap = opt_webSafe\n      ? this.charToByteMapWebSafe_\n      : this.charToByteMap_;\n\n    var output = [];\n\n    for (var i = 0; i < input.length; ) {\n      var byte1 = charToByteMap[input.charAt(i++)];\n\n      var haveByte2 = i < input.length;\n      var byte2 = haveByte2 ? charToByteMap[input.charAt(i)] : 0;\n      ++i;\n\n      var haveByte3 = i < input.length;\n      var byte3 = haveByte3 ? charToByteMap[input.charAt(i)] : 64;\n      ++i;\n\n      var haveByte4 = i < input.length;\n      var byte4 = haveByte4 ? charToByteMap[input.charAt(i)] : 64;\n      ++i;\n\n      if (byte1 == null || byte2 == null || byte3 == null || byte4 == null) {\n        throw Error();\n      }\n\n      var outByte1 = (byte1 << 2) | (byte2 >> 4);\n      output.push(outByte1);\n\n      if (byte3 != 64) {\n        var outByte2 = ((byte2 << 4) & 0xf0) | (byte3 >> 2);\n        output.push(outByte2);\n\n        if (byte4 != 64) {\n          var outByte3 = ((byte3 << 6) & 0xc0) | byte4;\n          output.push(outByte3);\n        }\n      }\n    }\n\n    return output;\n  },\n\n  /**\n   * Lazy static initialization function. Called before\n   * accessing any of the static map variables.\n   * @private\n   */\n  init_() {\n    if (!this.byteToCharMap_) {\n      this.byteToCharMap_ = {};\n      this.charToByteMap_ = {};\n      this.byteToCharMapWebSafe_ = {};\n      this.charToByteMapWebSafe_ = {};\n\n      // We want quick mappings back and forth, so we precompute two maps.\n      for (var i = 0; i < this.ENCODED_VALS.length; i++) {\n        this.byteToCharMap_[i] = this.ENCODED_VALS.charAt(i);\n        this.charToByteMap_[this.byteToCharMap_[i]] = i;\n        this.byteToCharMapWebSafe_[i] = this.ENCODED_VALS_WEBSAFE.charAt(i);\n        this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[i]] = i;\n\n        // Be forgiving when decoding and correctly decode both encodings.\n        if (i >= this.ENCODED_VALS_BASE.length) {\n          this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(i)] = i;\n          this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(i)] = i;\n        }\n      }\n    }\n  }\n};\n"]}