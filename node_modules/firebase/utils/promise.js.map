{"version":3,"sources":["../src/utils/promise.ts","utils/promise.js"],"names":["PromiseImpl","Promise","require","Deferred","self","resolve","reject","promise","prototype","wrapCallback","opt_nodeCallback","meta","error","opt_value","attachDummyErrorHandler","length","catch"],"mappings":";;;;;;;AAgBA;;AAEO,IAAMA,oCAAc,yBAAYC,OAAZ,IAAuBC,QAAQ,kBAAR,CAA3C;AAEP;;;AApBA;;;;;;;;;;;;;;;AAuBA,IAAAC,WAAA,YAAA;AAKE;AACA,aAAAA,QAAA,GAAA;AACE,YAAIC,OAAO,IAAX;AACA,aAAKC,OAAL,GAAe,IAAf;AACA,aAAKC,MAAL,GAAc,IAAd;AACA,aAAKC,OAAL,GAAe,IAAIP,WAAJ,CAAgB,UAASK,OAAT,EAAkBC,MAAlB,EAAwB;AACrDF,iBAAKC,OAAL,GAAeA,OAAf;AACAD,iBAAKE,MAAL,GAAcA,MAAd;AACD,SAHc,CAAf;AAID;AAED;;;;;;;AAOAH,aAAAK,SAAA,CAAAC,YAAA,GAAA,UAAaC,gBAAb,EAA8B;AAC5B,YAAIN,OAAO,IAAX;AACA;;;;AAIA,iBAAAO,IAAA,CAAcC,KAAd,EAAqBC,SAArB,EAA8B;AAC5B,gBAAID,KAAJ,EAAW;AACTR,qBAAKE,MAAL,CAAYM,KAAZ;AACD,aAFD,MAEO;AACLR,qBAAKC,OAAL,CAAaQ,SAAb;AACD;AACD,gBAAI,OAAOH,gBAAP,KAA4B,UAAhC,EAA4C;AAC1CI,wCAAwBV,KAAKG,OAA7B;AAEA;AACA;AACA,oBAAIG,iBAAiBK,MAAjB,KAA4B,CAAhC,EAAmC;AACjCL,qCAAiBE,KAAjB;AACD,iBAFD,MAEO;AACLF,qCAAiBE,KAAjB,EAAwBC,SAAxB;AACD;AACF;AACF;AACD,eAAOF,IAAP;AACD,KAzBD;AA0BF,WAAAR,QAAA;AAjDA,CAAA,EAAA;QC4CSA,Q,GAAAA,Q;ADOT;;;;;;;;;;;;AAWO,IAAMW,4DAA0B,SAA1BA,uBAA0B,CAASP,OAAT,EAAgB;AACrDA,YAAQS,KAAR,CAAc,YAAA,CAAQ,CAAtB;AACD,CAFM","file":"promise.js","sourcesContent":["/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\nimport { globalScope } from '../utils/globalScope';\n\nexport const PromiseImpl = globalScope.Promise || require('promise-polyfill');\n\n/**\n * A deferred promise implementation.\n */\nexport class Deferred {\n  resolve;\n  reject;\n  promise;\n\n  /** @constructor */\n  constructor() {\n    var self = this;\n    this.resolve = null;\n    this.reject = null;\n    this.promise = new PromiseImpl(function(resolve, reject) {\n      self.resolve = resolve;\n      self.reject = reject;\n    });\n  }\n\n  /**\n   * Our API internals are not promiseified and cannot because our callback APIs have subtle expectations around\n   * invoking promises inline, which Promises are forbidden to do. This method accepts an optional node-style callback\n   * and returns a node-style callback which will resolve or reject the Deferred's promise.\n   * @param {((?function(?(Error)): (?|undefined))| (?function(?(Error),?=): (?|undefined)))=} opt_nodeCallback\n   * @return {!function(?(Error), ?=)}\n   */\n  wrapCallback(opt_nodeCallback?) {\n    var self = this;\n    /**\n       * @param {?Error} error\n       * @param {?=} opt_value\n       */\n    function meta(error, opt_value) {\n      if (error) {\n        self.reject(error);\n      } else {\n        self.resolve(opt_value);\n      }\n      if (typeof opt_nodeCallback === 'function') {\n        attachDummyErrorHandler(self.promise);\n\n        // Some of our callbacks don't expect a value and our own tests\n        // assert that the parameter length is 1\n        if (opt_nodeCallback.length === 1) {\n          opt_nodeCallback(error);\n        } else {\n          opt_nodeCallback(error, opt_value);\n        }\n      }\n    }\n    return meta;\n  }\n}\n\n/**\n * Chrome (and maybe other browsers) report an Error in the console if you reject a promise\n * and nobody handles the error. This is normally a good thing, but this will confuse devs who\n * never intended to use promises in the first place. So in some cases (in particular, if the\n * developer attached a callback), we should attach a dummy resolver to the promise to suppress\n * this error.\n *\n * Note: We can't do this all the time, since it breaks the Promise spec (though in the obscure\n * 3.3.3 section related to upgrading non-compliant promises).\n * @param {!firebase.Promise} promise\n */\nexport const attachDummyErrorHandler = function(promise) {\n  promise.catch(() => {});\n};\n","/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\nimport { globalScope } from '../utils/globalScope';\nexport var PromiseImpl = globalScope.Promise || require('promise-polyfill');\n/**\n * A deferred promise implementation.\n */\nvar Deferred = (function () {\n    /** @constructor */\n    function Deferred() {\n        var self = this;\n        this.resolve = null;\n        this.reject = null;\n        this.promise = new PromiseImpl(function (resolve, reject) {\n            self.resolve = resolve;\n            self.reject = reject;\n        });\n    }\n    /**\n     * Our API internals are not promiseified and cannot because our callback APIs have subtle expectations around\n     * invoking promises inline, which Promises are forbidden to do. This method accepts an optional node-style callback\n     * and returns a node-style callback which will resolve or reject the Deferred's promise.\n     * @param {((?function(?(Error)): (?|undefined))| (?function(?(Error),?=): (?|undefined)))=} opt_nodeCallback\n     * @return {!function(?(Error), ?=)}\n     */\n    Deferred.prototype.wrapCallback = function (opt_nodeCallback) {\n        var self = this;\n        /**\n           * @param {?Error} error\n           * @param {?=} opt_value\n           */\n        function meta(error, opt_value) {\n            if (error) {\n                self.reject(error);\n            }\n            else {\n                self.resolve(opt_value);\n            }\n            if (typeof opt_nodeCallback === 'function') {\n                attachDummyErrorHandler(self.promise);\n                // Some of our callbacks don't expect a value and our own tests\n                // assert that the parameter length is 1\n                if (opt_nodeCallback.length === 1) {\n                    opt_nodeCallback(error);\n                }\n                else {\n                    opt_nodeCallback(error, opt_value);\n                }\n            }\n        }\n        return meta;\n    };\n    return Deferred;\n}());\nexport { Deferred };\n/**\n * Chrome (and maybe other browsers) report an Error in the console if you reject a promise\n * and nobody handles the error. This is normally a good thing, but this will confuse devs who\n * never intended to use promises in the first place. So in some cases (in particular, if the\n * developer attached a callback), we should attach a dummy resolver to the promise to suppress\n * this error.\n *\n * Note: We can't do this all the time, since it breaks the Promise spec (though in the obscure\n * 3.3.3 section related to upgrading non-compliant promises).\n * @param {!firebase.Promise} promise\n */\nexport var attachDummyErrorHandler = function (promise) {\n    promise.catch(function () { });\n};\n\n\n"]}